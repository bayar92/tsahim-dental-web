
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends Prisma.PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model User
 * 
 */
export type User = {
  id: string
  email: string | null
  emailVerified: Date | null
  passwordDigest: string | null
  phoneNumber: string
  phoneNumberVerified: Date | null
  role: UserRole
  inviteToken: string | null
  isTokenUsed: Date | null
  createdAt: Date
  updatedAt: Date
  invitedBy: string | null
  pin: string | null
  pinCreatedAt: Date | null
  pinType: string | null
  pinVerifiedAt: Date | null
  hospitalId: string | null
}

/**
 * Model Account
 * 
 */
export type Account = {
  id: string
  userId: string
  type: string
  provider: string
  providerAccountId: string
  refreshToken: string | null
  accessToken: string | null
  tokenType: string | null
  expiresAt: number | null
  scope: string | null
  idToken: string | null
  sessionState: string | null
  oauthTokenSecret: string | null
  oauthToken: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Profile
 * 
 */
export type Profile = {
  id: string
  userId: string
  firstName: string
  lastName: string
  latinName: string
  sex: string | null
  dob: string | null
  height: number | null
  weight: number | null
  picture: string | null
  priceMin: number | null
  priceMax: number | null
  notifyEmail: boolean
  notifyPush: boolean
  notifyBadge: boolean
  historyId: string | null
  createdAt: Date
  updatedAt: Date
  specialistDesc: string | null
  patientCode: string | null
  allowPatientAssign: Date | null
}

/**
 * Model Session
 * 
 */
export type Session = {
  id: string
  sid: string
  data: string
  expiresAt: Date
}

/**
 * Model SmsRequestAttempt
 * 
 */
export type SmsRequestAttempt = {
  id: string
  phoneNumber: string
  ipAddress: string
  createdAt: Date
}

/**
 * Model FileUpload
 * 
 */
export type FileUpload = {
  id: string
  fileGroup: string | null
  fileLink: string
  fileSource: string
  removedAt: Date | null
  createdBy: string
  createdAt: Date
  updatedAt: Date
  fileCategory: string | null
  fileSourceDate: string | null
  fileMIMEType: string
}

/**
 * Model FirebaseToken
 * 
 */
export type FirebaseToken = {
  id: string
  token: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model WaitListPhoneNumber
 * 
 */
export type WaitListPhoneNumber = {
  id: string
  phoneNumber: string
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Hospital
 * 
 */
export type Hospital = {
  id: string
  hospitalLogo: string | null
  subDomain: string | null
  phoneNumber: string
  name: string
  userId: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Subscription
 * 
 */
export type Subscription = {
  id: number
  startDate: Date | null
  endDate: Date | null
  totalDays: number
  isStart: boolean
  createdAt: Date
  updatedAt: Date
  hospitalId: string | null
}

/**
 * Model Machine
 * 
 */
export type Machine = {
  id: number
  subscriptionId: number
  machineName: string
  machineUniqueId: string
  registeredAt: Date
}

/**
 * Model HospitalUsers
 * 
 */
export type HospitalUsers = {
  id: number
  hospitalId: string
  phoneNumber: string | null
  userName: string
  role: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model DatabaseConnection
 * 
 */
export type DatabaseConnection = {
  id: string
  connectionName: string
  connectionType: string
  host: string
  port: number
  databaseName: string
  username: string
  password: string
  createdAt: Date
  updatedAt: Date
  hospitalId: string | null
}

/**
 * Model Product
 * 
 */
export type Product = {
  id: string
  name: string
  productDescription: Prisma.JsonValue | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model ProductVariant
 * 
 */
export type ProductVariant = {
  id: string
  productId: string
  name: string
  price: number
  unit: number
  duration: number
  discount: number
  createdAt: Date
  updatedAt: Date
  sits: number[]
}

/**
 * Model ProductPayment
 * 
 */
export type ProductPayment = {
  id: string
  paidSource: string | null
  paidAmount: Prisma.Decimal | null
  paidDate: Date | null
  additionalNote: string
  productId: string
  productVariantId: string
  userId: string
  createdAt: Date
  updatedAt: Date
  paymentStatus: string
}

/**
 * Model QPayInvoice
 * 
 */
export type QPayInvoice = {
  id: string
  productId: string
  productVariantId: string
  invoiceData: Prisma.JsonValue | null
  userId: string | null
  payedDate: Date | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Message
 * 
 */
export type Message = {
  id: string
  phoneNumber: string
  message: string
  createdAt: Date
  updatedAt: Date
  hospitalId: string
}

/**
 * Model PromoCode
 * 
 */
export type PromoCode = {
  id: string
  code: string
  promoImageUrl: string
  description: string
  expiryDate: Date | null
  isActive: boolean
  fixedAmount: Prisma.Decimal
  percentageAmount: Prisma.Decimal
  maxUses: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model UserPromoCode
 * 
 */
export type UserPromoCode = {
  id: string
  userId: string
  promoCodeId: string
  promoCodeUsedAt: Date | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model FreeTrial
 * 
 */
export type FreeTrial = {
  id: string
  hospitalName: string
  phoneNumber: string
  hospitalChair: string
  registrationNumber: string
  directorInfo: string
  createdAt: Date
  updatedAt: Date
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const UserRole: {
  ADMIN: 'ADMIN',
  TECHNICAL_SUPPORT: 'TECHNICAL_SUPPORT',
  HOSPITAL_OWNER: 'HOSPITAL_OWNER',
  HOSPITAL_USER: 'HOSPITAL_USER',
  USER: 'USER'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<this, "$connect" | "$disconnect" | "$on" | "$transaction" | "$use">) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<GlobalReject>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.ProfileDelegate<GlobalReject>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<GlobalReject>;

  /**
   * `prisma.smsRequestAttempt`: Exposes CRUD operations for the **SmsRequestAttempt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SmsRequestAttempts
    * const smsRequestAttempts = await prisma.smsRequestAttempt.findMany()
    * ```
    */
  get smsRequestAttempt(): Prisma.SmsRequestAttemptDelegate<GlobalReject>;

  /**
   * `prisma.fileUpload`: Exposes CRUD operations for the **FileUpload** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FileUploads
    * const fileUploads = await prisma.fileUpload.findMany()
    * ```
    */
  get fileUpload(): Prisma.FileUploadDelegate<GlobalReject>;

  /**
   * `prisma.firebaseToken`: Exposes CRUD operations for the **FirebaseToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FirebaseTokens
    * const firebaseTokens = await prisma.firebaseToken.findMany()
    * ```
    */
  get firebaseToken(): Prisma.FirebaseTokenDelegate<GlobalReject>;

  /**
   * `prisma.waitListPhoneNumber`: Exposes CRUD operations for the **WaitListPhoneNumber** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WaitListPhoneNumbers
    * const waitListPhoneNumbers = await prisma.waitListPhoneNumber.findMany()
    * ```
    */
  get waitListPhoneNumber(): Prisma.WaitListPhoneNumberDelegate<GlobalReject>;

  /**
   * `prisma.hospital`: Exposes CRUD operations for the **Hospital** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hospitals
    * const hospitals = await prisma.hospital.findMany()
    * ```
    */
  get hospital(): Prisma.HospitalDelegate<GlobalReject>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<GlobalReject>;

  /**
   * `prisma.machine`: Exposes CRUD operations for the **Machine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Machines
    * const machines = await prisma.machine.findMany()
    * ```
    */
  get machine(): Prisma.MachineDelegate<GlobalReject>;

  /**
   * `prisma.hospitalUsers`: Exposes CRUD operations for the **HospitalUsers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HospitalUsers
    * const hospitalUsers = await prisma.hospitalUsers.findMany()
    * ```
    */
  get hospitalUsers(): Prisma.HospitalUsersDelegate<GlobalReject>;

  /**
   * `prisma.databaseConnection`: Exposes CRUD operations for the **DatabaseConnection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DatabaseConnections
    * const databaseConnections = await prisma.databaseConnection.findMany()
    * ```
    */
  get databaseConnection(): Prisma.DatabaseConnectionDelegate<GlobalReject>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<GlobalReject>;

  /**
   * `prisma.productVariant`: Exposes CRUD operations for the **ProductVariant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductVariants
    * const productVariants = await prisma.productVariant.findMany()
    * ```
    */
  get productVariant(): Prisma.ProductVariantDelegate<GlobalReject>;

  /**
   * `prisma.productPayment`: Exposes CRUD operations for the **ProductPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductPayments
    * const productPayments = await prisma.productPayment.findMany()
    * ```
    */
  get productPayment(): Prisma.ProductPaymentDelegate<GlobalReject>;

  /**
   * `prisma.qPayInvoice`: Exposes CRUD operations for the **QPayInvoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QPayInvoices
    * const qPayInvoices = await prisma.qPayInvoice.findMany()
    * ```
    */
  get qPayInvoice(): Prisma.QPayInvoiceDelegate<GlobalReject>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<GlobalReject>;

  /**
   * `prisma.promoCode`: Exposes CRUD operations for the **PromoCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PromoCodes
    * const promoCodes = await prisma.promoCode.findMany()
    * ```
    */
  get promoCode(): Prisma.PromoCodeDelegate<GlobalReject>;

  /**
   * `prisma.userPromoCode`: Exposes CRUD operations for the **UserPromoCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPromoCodes
    * const userPromoCodes = await prisma.userPromoCode.findMany()
    * ```
    */
  get userPromoCode(): Prisma.UserPromoCodeDelegate<GlobalReject>;

  /**
   * `prisma.freeTrial`: Exposes CRUD operations for the **FreeTrial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FreeTrials
    * const freeTrials = await prisma.freeTrial.findMany()
    * ```
    */
  get freeTrial(): Prisma.FreeTrialDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.11.0
   * Query Engine version: 8fde8fef4033376662cad983758335009d522acb
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Account: 'Account',
    Profile: 'Profile',
    Session: 'Session',
    SmsRequestAttempt: 'SmsRequestAttempt',
    FileUpload: 'FileUpload',
    FirebaseToken: 'FirebaseToken',
    WaitListPhoneNumber: 'WaitListPhoneNumber',
    Hospital: 'Hospital',
    Subscription: 'Subscription',
    Machine: 'Machine',
    HospitalUsers: 'HospitalUsers',
    DatabaseConnection: 'DatabaseConnection',
    Product: 'Product',
    ProductVariant: 'ProductVariant',
    ProductPayment: 'ProductPayment',
    QPayInvoice: 'QPayInvoice',
    Message: 'Message',
    PromoCode: 'PromoCode',
    UserPromoCode: 'UserPromoCode',
    FreeTrial: 'FreeTrial'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    accounts: number
    hospital: number
    ProductPayment: number
    QPayInvoice: number
    UserPromoCode: number
  }

  export type UserCountOutputTypeSelect = {
    accounts?: boolean
    hospital?: boolean
    ProductPayment?: boolean
    QPayInvoice?: boolean
    UserPromoCode?: boolean
  }

  export type UserCountOutputTypeGetPayload<S extends boolean | null | undefined | UserCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (UserCountOutputTypeArgs)
    ? UserCountOutputType 
    : S extends { select: any } & (UserCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
      : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type HospitalCountOutputType
   */


  export type HospitalCountOutputType = {
    HospitalUsers: number
    subscription: number
    databaseConnection: number
    Message: number
  }

  export type HospitalCountOutputTypeSelect = {
    HospitalUsers?: boolean
    subscription?: boolean
    databaseConnection?: boolean
    Message?: boolean
  }

  export type HospitalCountOutputTypeGetPayload<S extends boolean | null | undefined | HospitalCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? HospitalCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (HospitalCountOutputTypeArgs)
    ? HospitalCountOutputType 
    : S extends { select: any } & (HospitalCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof HospitalCountOutputType ? HospitalCountOutputType[P] : never
  } 
      : HospitalCountOutputType




  // Custom InputTypes

  /**
   * HospitalCountOutputType without action
   */
  export type HospitalCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the HospitalCountOutputType
     */
    select?: HospitalCountOutputTypeSelect | null
  }



  /**
   * Count Type SubscriptionCountOutputType
   */


  export type SubscriptionCountOutputType = {
    machines: number
  }

  export type SubscriptionCountOutputTypeSelect = {
    machines?: boolean
  }

  export type SubscriptionCountOutputTypeGetPayload<S extends boolean | null | undefined | SubscriptionCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SubscriptionCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (SubscriptionCountOutputTypeArgs)
    ? SubscriptionCountOutputType 
    : S extends { select: any } & (SubscriptionCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof SubscriptionCountOutputType ? SubscriptionCountOutputType[P] : never
  } 
      : SubscriptionCountOutputType




  // Custom InputTypes

  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SubscriptionCountOutputType
     */
    select?: SubscriptionCountOutputTypeSelect | null
  }



  /**
   * Count Type ProductCountOutputType
   */


  export type ProductCountOutputType = {
    ProductVariant: number
    ProductPayment: number
    QPayInvoice: number
  }

  export type ProductCountOutputTypeSelect = {
    ProductVariant?: boolean
    ProductPayment?: boolean
    QPayInvoice?: boolean
  }

  export type ProductCountOutputTypeGetPayload<S extends boolean | null | undefined | ProductCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ProductCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ProductCountOutputTypeArgs)
    ? ProductCountOutputType 
    : S extends { select: any } & (ProductCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ProductCountOutputType ? ProductCountOutputType[P] : never
  } 
      : ProductCountOutputType




  // Custom InputTypes

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect | null
  }



  /**
   * Count Type ProductVariantCountOutputType
   */


  export type ProductVariantCountOutputType = {
    ProductPayment: number
    QPayInvoice: number
  }

  export type ProductVariantCountOutputTypeSelect = {
    ProductPayment?: boolean
    QPayInvoice?: boolean
  }

  export type ProductVariantCountOutputTypeGetPayload<S extends boolean | null | undefined | ProductVariantCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ProductVariantCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ProductVariantCountOutputTypeArgs)
    ? ProductVariantCountOutputType 
    : S extends { select: any } & (ProductVariantCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ProductVariantCountOutputType ? ProductVariantCountOutputType[P] : never
  } 
      : ProductVariantCountOutputType




  // Custom InputTypes

  /**
   * ProductVariantCountOutputType without action
   */
  export type ProductVariantCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProductVariantCountOutputType
     */
    select?: ProductVariantCountOutputTypeSelect | null
  }



  /**
   * Count Type PromoCodeCountOutputType
   */


  export type PromoCodeCountOutputType = {
    userPromoCode: number
  }

  export type PromoCodeCountOutputTypeSelect = {
    userPromoCode?: boolean
  }

  export type PromoCodeCountOutputTypeGetPayload<S extends boolean | null | undefined | PromoCodeCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PromoCodeCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (PromoCodeCountOutputTypeArgs)
    ? PromoCodeCountOutputType 
    : S extends { select: any } & (PromoCodeCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof PromoCodeCountOutputType ? PromoCodeCountOutputType[P] : never
  } 
      : PromoCodeCountOutputType




  // Custom InputTypes

  /**
   * PromoCodeCountOutputType without action
   */
  export type PromoCodeCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PromoCodeCountOutputType
     */
    select?: PromoCodeCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    emailVerified: Date | null
    passwordDigest: string | null
    phoneNumber: string | null
    phoneNumberVerified: Date | null
    role: UserRole | null
    inviteToken: string | null
    isTokenUsed: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    invitedBy: string | null
    pin: string | null
    pinCreatedAt: Date | null
    pinType: string | null
    pinVerifiedAt: Date | null
    hospitalId: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    emailVerified: Date | null
    passwordDigest: string | null
    phoneNumber: string | null
    phoneNumberVerified: Date | null
    role: UserRole | null
    inviteToken: string | null
    isTokenUsed: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    invitedBy: string | null
    pin: string | null
    pinCreatedAt: Date | null
    pinType: string | null
    pinVerifiedAt: Date | null
    hospitalId: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    emailVerified: number
    passwordDigest: number
    phoneNumber: number
    phoneNumberVerified: number
    role: number
    inviteToken: number
    isTokenUsed: number
    createdAt: number
    updatedAt: number
    invitedBy: number
    pin: number
    pinCreatedAt: number
    pinType: number
    pinVerifiedAt: number
    hospitalId: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    emailVerified?: true
    passwordDigest?: true
    phoneNumber?: true
    phoneNumberVerified?: true
    role?: true
    inviteToken?: true
    isTokenUsed?: true
    createdAt?: true
    updatedAt?: true
    invitedBy?: true
    pin?: true
    pinCreatedAt?: true
    pinType?: true
    pinVerifiedAt?: true
    hospitalId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    emailVerified?: true
    passwordDigest?: true
    phoneNumber?: true
    phoneNumberVerified?: true
    role?: true
    inviteToken?: true
    isTokenUsed?: true
    createdAt?: true
    updatedAt?: true
    invitedBy?: true
    pin?: true
    pinCreatedAt?: true
    pinType?: true
    pinVerifiedAt?: true
    hospitalId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    emailVerified?: true
    passwordDigest?: true
    phoneNumber?: true
    phoneNumberVerified?: true
    role?: true
    inviteToken?: true
    isTokenUsed?: true
    createdAt?: true
    updatedAt?: true
    invitedBy?: true
    pin?: true
    pinCreatedAt?: true
    pinType?: true
    pinVerifiedAt?: true
    hospitalId?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: UserScalarFieldEnum[]
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: string
    email: string | null
    emailVerified: Date | null
    passwordDigest: string | null
    phoneNumber: string
    phoneNumberVerified: Date | null
    role: UserRole
    inviteToken: string | null
    isTokenUsed: Date | null
    createdAt: Date
    updatedAt: Date
    invitedBy: string | null
    pin: string | null
    pinCreatedAt: Date | null
    pinType: string | null
    pinVerifiedAt: Date | null
    hospitalId: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    email?: boolean
    emailVerified?: boolean
    passwordDigest?: boolean
    phoneNumber?: boolean
    phoneNumberVerified?: boolean
    role?: boolean
    inviteToken?: boolean
    isTokenUsed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invitedBy?: boolean
    pin?: boolean
    pinCreatedAt?: boolean
    pinType?: boolean
    pinVerifiedAt?: boolean
    hospitalId?: boolean
    accounts?: boolean | User$accountsArgs
    profile?: boolean | ProfileArgs
    hospital?: boolean | User$hospitalArgs
    ProductPayment?: boolean | User$ProductPaymentArgs
    QPayInvoice?: boolean | User$QPayInvoiceArgs
    UserPromoCode?: boolean | User$UserPromoCodeArgs
    _count?: boolean | UserCountOutputTypeArgs
  }


  export type UserInclude = {
    accounts?: boolean | User$accountsArgs
    profile?: boolean | ProfileArgs
    hospital?: boolean | User$hospitalArgs
    ProductPayment?: boolean | User$ProductPaymentArgs
    QPayInvoice?: boolean | User$QPayInvoiceArgs
    UserPromoCode?: boolean | User$UserPromoCodeArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserGetPayload<S extends boolean | null | undefined | UserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? User :
    S extends undefined ? never :
    S extends { include: any } & (UserArgs | UserFindManyArgs)
    ? User  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'accounts' ? Array < AccountGetPayload<S['include'][P]>>  :
        P extends 'profile' ? ProfileGetPayload<S['include'][P]> | null :
        P extends 'hospital' ? Array < HospitalGetPayload<S['include'][P]>>  :
        P extends 'ProductPayment' ? Array < ProductPaymentGetPayload<S['include'][P]>>  :
        P extends 'QPayInvoice' ? Array < QPayInvoiceGetPayload<S['include'][P]>>  :
        P extends 'UserPromoCode' ? Array < UserPromoCodeGetPayload<S['include'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserArgs | UserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'accounts' ? Array < AccountGetPayload<S['select'][P]>>  :
        P extends 'profile' ? ProfileGetPayload<S['select'][P]> | null :
        P extends 'hospital' ? Array < HospitalGetPayload<S['select'][P]>>  :
        P extends 'ProductPayment' ? Array < ProductPaymentGetPayload<S['select'][P]>>  :
        P extends 'QPayInvoice' ? Array < QPayInvoiceGetPayload<S['select'][P]>>  :
        P extends 'UserPromoCode' ? Array < UserPromoCodeGetPayload<S['select'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof User ? User[P] : never
  } 
      : User


  type UserCountArgs = 
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): Prisma.PrismaPromise<Array<UserGetPayload<T>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    accounts<T extends User$accountsArgs= {}>(args?: Subset<T, User$accountsArgs>): Prisma.PrismaPromise<Array<AccountGetPayload<T>>| Null>;

    profile<T extends ProfileArgs= {}>(args?: Subset<T, ProfileArgs>): Prisma__ProfileClient<ProfileGetPayload<T> | Null>;

    hospital<T extends User$hospitalArgs= {}>(args?: Subset<T, User$hospitalArgs>): Prisma.PrismaPromise<Array<HospitalGetPayload<T>>| Null>;

    ProductPayment<T extends User$ProductPaymentArgs= {}>(args?: Subset<T, User$ProductPaymentArgs>): Prisma.PrismaPromise<Array<ProductPaymentGetPayload<T>>| Null>;

    QPayInvoice<T extends User$QPayInvoiceArgs= {}>(args?: Subset<T, User$QPayInvoiceArgs>): Prisma.PrismaPromise<Array<QPayInvoiceGetPayload<T>>| Null>;

    UserPromoCode<T extends User$UserPromoCodeArgs= {}>(args?: Subset<T, User$UserPromoCodeArgs>): Prisma.PrismaPromise<Array<UserPromoCodeGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUnique
   */
  export interface UserFindUniqueArgs extends UserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User findFirst
   */
  export interface UserFindFirstArgs extends UserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     */
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.accounts
   */
  export type User$accountsArgs = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude | null
    where?: AccountWhereInput
    orderBy?: Enumerable<AccountOrderByWithRelationInput>
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AccountScalarFieldEnum>
  }


  /**
   * User.hospital
   */
  export type User$hospitalArgs = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HospitalInclude | null
    where?: HospitalWhereInput
    orderBy?: Enumerable<HospitalOrderByWithRelationInput>
    cursor?: HospitalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<HospitalScalarFieldEnum>
  }


  /**
   * User.ProductPayment
   */
  export type User$ProductPaymentArgs = {
    /**
     * Select specific fields to fetch from the ProductPayment
     */
    select?: ProductPaymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductPaymentInclude | null
    where?: ProductPaymentWhereInput
    orderBy?: Enumerable<ProductPaymentOrderByWithRelationInput>
    cursor?: ProductPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProductPaymentScalarFieldEnum>
  }


  /**
   * User.QPayInvoice
   */
  export type User$QPayInvoiceArgs = {
    /**
     * Select specific fields to fetch from the QPayInvoice
     */
    select?: QPayInvoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QPayInvoiceInclude | null
    where?: QPayInvoiceWhereInput
    orderBy?: Enumerable<QPayInvoiceOrderByWithRelationInput>
    cursor?: QPayInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<QPayInvoiceScalarFieldEnum>
  }


  /**
   * User.UserPromoCode
   */
  export type User$UserPromoCodeArgs = {
    /**
     * Select specific fields to fetch from the UserPromoCode
     */
    select?: UserPromoCodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPromoCodeInclude | null
    where?: UserPromoCodeWhereInput
    orderBy?: Enumerable<UserPromoCodeOrderByWithRelationInput>
    cursor?: UserPromoCodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserPromoCodeScalarFieldEnum>
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
  }



  /**
   * Model Account
   */


  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expiresAt: number | null
  }

  export type AccountSumAggregateOutputType = {
    expiresAt: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refreshToken: string | null
    accessToken: string | null
    tokenType: string | null
    expiresAt: number | null
    scope: string | null
    idToken: string | null
    sessionState: string | null
    oauthTokenSecret: string | null
    oauthToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refreshToken: string | null
    accessToken: string | null
    tokenType: string | null
    expiresAt: number | null
    scope: string | null
    idToken: string | null
    sessionState: string | null
    oauthTokenSecret: string | null
    oauthToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refreshToken: number
    accessToken: number
    tokenType: number
    expiresAt: number
    scope: number
    idToken: number
    sessionState: number
    oauthTokenSecret: number
    oauthToken: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expiresAt?: true
  }

  export type AccountSumAggregateInputType = {
    expiresAt?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refreshToken?: true
    accessToken?: true
    tokenType?: true
    expiresAt?: true
    scope?: true
    idToken?: true
    sessionState?: true
    oauthTokenSecret?: true
    oauthToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refreshToken?: true
    accessToken?: true
    tokenType?: true
    expiresAt?: true
    scope?: true
    idToken?: true
    sessionState?: true
    oauthTokenSecret?: true
    oauthToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refreshToken?: true
    accessToken?: true
    tokenType?: true
    expiresAt?: true
    scope?: true
    idToken?: true
    sessionState?: true
    oauthTokenSecret?: true
    oauthToken?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: Enumerable<AccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs = {
    where?: AccountWhereInput
    orderBy?: Enumerable<AccountOrderByWithAggregationInput>
    by: AccountScalarFieldEnum[]
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }


  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refreshToken: string | null
    accessToken: string | null
    tokenType: string | null
    expiresAt: number | null
    scope: string | null
    idToken: string | null
    sessionState: string | null
    oauthTokenSecret: string | null
    oauthToken: string | null
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refreshToken?: boolean
    accessToken?: boolean
    tokenType?: boolean
    expiresAt?: boolean
    scope?: boolean
    idToken?: boolean
    sessionState?: boolean
    oauthTokenSecret?: boolean
    oauthToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs
  }


  export type AccountInclude = {
    user?: boolean | UserArgs
  }

  export type AccountGetPayload<S extends boolean | null | undefined | AccountArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Account :
    S extends undefined ? never :
    S extends { include: any } & (AccountArgs | AccountFindManyArgs)
    ? Account  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (AccountArgs | AccountFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof Account ? Account[P] : never
  } 
      : Account


  type AccountCountArgs = 
    Omit<AccountFindManyArgs, 'select' | 'include'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AccountFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AccountFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Account'> extends True ? Prisma__AccountClient<AccountGetPayload<T>> : Prisma__AccountClient<AccountGetPayload<T> | null, null>

    /**
     * Find one Account that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AccountFindUniqueOrThrowArgs>
    ): Prisma__AccountClient<AccountGetPayload<T>>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AccountFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AccountFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Account'> extends True ? Prisma__AccountClient<AccountGetPayload<T>> : Prisma__AccountClient<AccountGetPayload<T> | null, null>

    /**
     * Find the first Account that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AccountFindFirstOrThrowArgs>
    ): Prisma__AccountClient<AccountGetPayload<T>>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AccountFindManyArgs>(
      args?: SelectSubset<T, AccountFindManyArgs>
    ): Prisma.PrismaPromise<Array<AccountGetPayload<T>>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
    **/
    create<T extends AccountCreateArgs>(
      args: SelectSubset<T, AccountCreateArgs>
    ): Prisma__AccountClient<AccountGetPayload<T>>

    /**
     * Create many Accounts.
     *     @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     *     @example
     *     // Create many Accounts
     *     const account = await prisma.account.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AccountCreateManyArgs>(
      args?: SelectSubset<T, AccountCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
    **/
    delete<T extends AccountDeleteArgs>(
      args: SelectSubset<T, AccountDeleteArgs>
    ): Prisma__AccountClient<AccountGetPayload<T>>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AccountUpdateArgs>(
      args: SelectSubset<T, AccountUpdateArgs>
    ): Prisma__AccountClient<AccountGetPayload<T>>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AccountDeleteManyArgs>(
      args?: SelectSubset<T, AccountDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AccountUpdateManyArgs>(
      args: SelectSubset<T, AccountUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
    **/
    upsert<T extends AccountUpsertArgs>(
      args: SelectSubset<T, AccountUpsertArgs>
    ): Prisma__AccountClient<AccountGetPayload<T>>

    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AccountClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Account base type for findUnique actions
   */
  export type AccountFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUnique
   */
  export interface AccountFindUniqueArgs extends AccountFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account base type for findFirst actions
   */
  export type AccountFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: Enumerable<AccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: Enumerable<AccountScalarFieldEnum>
  }

  /**
   * Account findFirst
   */
  export interface AccountFindFirstArgs extends AccountFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: Enumerable<AccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: Enumerable<AccountScalarFieldEnum>
  }


  /**
   * Account findMany
   */
  export type AccountFindManyArgs = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: Enumerable<AccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: Enumerable<AccountScalarFieldEnum>
  }


  /**
   * Account create
   */
  export type AccountCreateArgs = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }


  /**
   * Account createMany
   */
  export type AccountCreateManyArgs = {
    /**
     * The data used to create many Accounts.
     */
    data: Enumerable<AccountCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Account update
   */
  export type AccountUpdateArgs = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
  }


  /**
   * Account upsert
   */
  export type AccountUpsertArgs = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }


  /**
   * Account delete
   */
  export type AccountDeleteArgs = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
  }


  /**
   * Account without action
   */
  export type AccountArgs = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude | null
  }



  /**
   * Model Profile
   */


  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileAvgAggregateOutputType = {
    height: number | null
    weight: number | null
    priceMin: number | null
    priceMax: number | null
  }

  export type ProfileSumAggregateOutputType = {
    height: number | null
    weight: number | null
    priceMin: number | null
    priceMax: number | null
  }

  export type ProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    firstName: string | null
    lastName: string | null
    latinName: string | null
    sex: string | null
    dob: string | null
    height: number | null
    weight: number | null
    picture: string | null
    priceMin: number | null
    priceMax: number | null
    notifyEmail: boolean | null
    notifyPush: boolean | null
    notifyBadge: boolean | null
    historyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    specialistDesc: string | null
    patientCode: string | null
    allowPatientAssign: Date | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    firstName: string | null
    lastName: string | null
    latinName: string | null
    sex: string | null
    dob: string | null
    height: number | null
    weight: number | null
    picture: string | null
    priceMin: number | null
    priceMax: number | null
    notifyEmail: boolean | null
    notifyPush: boolean | null
    notifyBadge: boolean | null
    historyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    specialistDesc: string | null
    patientCode: string | null
    allowPatientAssign: Date | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    userId: number
    firstName: number
    lastName: number
    latinName: number
    sex: number
    dob: number
    height: number
    weight: number
    picture: number
    priceMin: number
    priceMax: number
    notifyEmail: number
    notifyPush: number
    notifyBadge: number
    historyId: number
    createdAt: number
    updatedAt: number
    specialistDesc: number
    patientCode: number
    allowPatientAssign: number
    _all: number
  }


  export type ProfileAvgAggregateInputType = {
    height?: true
    weight?: true
    priceMin?: true
    priceMax?: true
  }

  export type ProfileSumAggregateInputType = {
    height?: true
    weight?: true
    priceMin?: true
    priceMax?: true
  }

  export type ProfileMinAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    latinName?: true
    sex?: true
    dob?: true
    height?: true
    weight?: true
    picture?: true
    priceMin?: true
    priceMax?: true
    notifyEmail?: true
    notifyPush?: true
    notifyBadge?: true
    historyId?: true
    createdAt?: true
    updatedAt?: true
    specialistDesc?: true
    patientCode?: true
    allowPatientAssign?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    latinName?: true
    sex?: true
    dob?: true
    height?: true
    weight?: true
    picture?: true
    priceMin?: true
    priceMax?: true
    notifyEmail?: true
    notifyPush?: true
    notifyBadge?: true
    historyId?: true
    createdAt?: true
    updatedAt?: true
    specialistDesc?: true
    patientCode?: true
    allowPatientAssign?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    latinName?: true
    sex?: true
    dob?: true
    height?: true
    weight?: true
    picture?: true
    priceMin?: true
    priceMax?: true
    notifyEmail?: true
    notifyPush?: true
    notifyBadge?: true
    historyId?: true
    createdAt?: true
    updatedAt?: true
    specialistDesc?: true
    patientCode?: true
    allowPatientAssign?: true
    _all?: true
  }

  export type ProfileAggregateArgs = {
    /**
     * Filter which Profile to aggregate.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: Enumerable<ProfileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type ProfileGroupByArgs = {
    where?: ProfileWhereInput
    orderBy?: Enumerable<ProfileOrderByWithAggregationInput>
    by: ProfileScalarFieldEnum[]
    having?: ProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _avg?: ProfileAvgAggregateInputType
    _sum?: ProfileSumAggregateInputType
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }


  export type ProfileGroupByOutputType = {
    id: string
    userId: string
    firstName: string
    lastName: string
    latinName: string
    sex: string | null
    dob: string | null
    height: number | null
    weight: number | null
    picture: string | null
    priceMin: number | null
    priceMax: number | null
    notifyEmail: boolean
    notifyPush: boolean
    notifyBadge: boolean
    historyId: string | null
    createdAt: Date
    updatedAt: Date
    specialistDesc: string | null
    patientCode: string | null
    allowPatientAssign: Date | null
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends ProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type ProfileSelect = {
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    latinName?: boolean
    sex?: boolean
    dob?: boolean
    height?: boolean
    weight?: boolean
    picture?: boolean
    priceMin?: boolean
    priceMax?: boolean
    notifyEmail?: boolean
    notifyPush?: boolean
    notifyBadge?: boolean
    historyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    specialistDesc?: boolean
    patientCode?: boolean
    allowPatientAssign?: boolean
    user?: boolean | UserArgs
  }


  export type ProfileInclude = {
    user?: boolean | UserArgs
  }

  export type ProfileGetPayload<S extends boolean | null | undefined | ProfileArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Profile :
    S extends undefined ? never :
    S extends { include: any } & (ProfileArgs | ProfileFindManyArgs)
    ? Profile  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ProfileArgs | ProfileFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof Profile ? Profile[P] : never
  } 
      : Profile


  type ProfileCountArgs = 
    Omit<ProfileFindManyArgs, 'select' | 'include'> & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface ProfileDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Profile that matches the filter.
     * @param {ProfileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProfileFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProfileFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Profile'> extends True ? Prisma__ProfileClient<ProfileGetPayload<T>> : Prisma__ProfileClient<ProfileGetPayload<T> | null, null>

    /**
     * Find one Profile that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProfileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProfileFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ProfileFindUniqueOrThrowArgs>
    ): Prisma__ProfileClient<ProfileGetPayload<T>>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProfileFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProfileFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Profile'> extends True ? Prisma__ProfileClient<ProfileGetPayload<T>> : Prisma__ProfileClient<ProfileGetPayload<T> | null, null>

    /**
     * Find the first Profile that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProfileFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProfileFindFirstOrThrowArgs>
    ): Prisma__ProfileClient<ProfileGetPayload<T>>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProfileFindManyArgs>(
      args?: SelectSubset<T, ProfileFindManyArgs>
    ): Prisma.PrismaPromise<Array<ProfileGetPayload<T>>>

    /**
     * Create a Profile.
     * @param {ProfileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
    **/
    create<T extends ProfileCreateArgs>(
      args: SelectSubset<T, ProfileCreateArgs>
    ): Prisma__ProfileClient<ProfileGetPayload<T>>

    /**
     * Create many Profiles.
     *     @param {ProfileCreateManyArgs} args - Arguments to create many Profiles.
     *     @example
     *     // Create many Profiles
     *     const profile = await prisma.profile.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProfileCreateManyArgs>(
      args?: SelectSubset<T, ProfileCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Profile.
     * @param {ProfileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
    **/
    delete<T extends ProfileDeleteArgs>(
      args: SelectSubset<T, ProfileDeleteArgs>
    ): Prisma__ProfileClient<ProfileGetPayload<T>>

    /**
     * Update one Profile.
     * @param {ProfileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProfileUpdateArgs>(
      args: SelectSubset<T, ProfileUpdateArgs>
    ): Prisma__ProfileClient<ProfileGetPayload<T>>

    /**
     * Delete zero or more Profiles.
     * @param {ProfileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProfileDeleteManyArgs>(
      args?: SelectSubset<T, ProfileDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProfileUpdateManyArgs>(
      args: SelectSubset<T, ProfileUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Profile.
     * @param {ProfileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
    **/
    upsert<T extends ProfileUpsertArgs>(
      args: SelectSubset<T, ProfileUpsertArgs>
    ): Prisma__ProfileClient<ProfileGetPayload<T>>

    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends ProfileCountArgs>(
      args?: Subset<T, ProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileGroupByArgs['orderBy'] }
        : { orderBy?: ProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProfileClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Profile base type for findUnique actions
   */
  export type ProfileFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findUnique
   */
  export interface ProfileFindUniqueArgs extends ProfileFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Profile findUniqueOrThrow
   */
  export type ProfileFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }


  /**
   * Profile base type for findFirst actions
   */
  export type ProfileFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: Enumerable<ProfileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: Enumerable<ProfileScalarFieldEnum>
  }

  /**
   * Profile findFirst
   */
  export interface ProfileFindFirstArgs extends ProfileFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Profile findFirstOrThrow
   */
  export type ProfileFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: Enumerable<ProfileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: Enumerable<ProfileScalarFieldEnum>
  }


  /**
   * Profile findMany
   */
  export type ProfileFindManyArgs = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude | null
    /**
     * Filter, which Profiles to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: Enumerable<ProfileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    distinct?: Enumerable<ProfileScalarFieldEnum>
  }


  /**
   * Profile create
   */
  export type ProfileCreateArgs = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude | null
    /**
     * The data needed to create a Profile.
     */
    data: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
  }


  /**
   * Profile createMany
   */
  export type ProfileCreateManyArgs = {
    /**
     * The data used to create many Profiles.
     */
    data: Enumerable<ProfileCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Profile update
   */
  export type ProfileUpdateArgs = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude | null
    /**
     * The data needed to update a Profile.
     */
    data: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
    /**
     * Choose, which Profile to update.
     */
    where: ProfileWhereUniqueInput
  }


  /**
   * Profile updateMany
   */
  export type ProfileUpdateManyArgs = {
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
  }


  /**
   * Profile upsert
   */
  export type ProfileUpsertArgs = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude | null
    /**
     * The filter to search for the Profile to update in case it exists.
     */
    where: ProfileWhereUniqueInput
    /**
     * In case the Profile found by the `where` argument doesn't exist, create a new Profile with this data.
     */
    create: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
    /**
     * In case the Profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
  }


  /**
   * Profile delete
   */
  export type ProfileDeleteArgs = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude | null
    /**
     * Filter which Profile to delete.
     */
    where: ProfileWhereUniqueInput
  }


  /**
   * Profile deleteMany
   */
  export type ProfileDeleteManyArgs = {
    /**
     * Filter which Profiles to delete
     */
    where?: ProfileWhereInput
  }


  /**
   * Profile without action
   */
  export type ProfileArgs = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude | null
  }



  /**
   * Model Session
   */


  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sid: string | null
    data: string | null
    expiresAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sid: string | null
    data: string | null
    expiresAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sid: number
    data: number
    expiresAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sid?: true
    data?: true
    expiresAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sid?: true
    data?: true
    expiresAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sid?: true
    data?: true
    expiresAt?: true
    _all?: true
  }

  export type SessionAggregateArgs = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: Enumerable<SessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs = {
    where?: SessionWhereInput
    orderBy?: Enumerable<SessionOrderByWithAggregationInput>
    by: SessionScalarFieldEnum[]
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }


  export type SessionGroupByOutputType = {
    id: string
    sid: string
    data: string
    expiresAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect = {
    id?: boolean
    sid?: boolean
    data?: boolean
    expiresAt?: boolean
  }


  export type SessionGetPayload<S extends boolean | null | undefined | SessionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Session :
    S extends undefined ? never :
    S extends { include: any } & (SessionArgs | SessionFindManyArgs)
    ? Session 
    : S extends { select: any } & (SessionArgs | SessionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Session ? Session[P] : never
  } 
      : Session


  type SessionCountArgs = 
    Omit<SessionFindManyArgs, 'select' | 'include'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SessionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SessionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Session'> extends True ? Prisma__SessionClient<SessionGetPayload<T>> : Prisma__SessionClient<SessionGetPayload<T> | null, null>

    /**
     * Find one Session that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SessionFindUniqueOrThrowArgs>
    ): Prisma__SessionClient<SessionGetPayload<T>>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SessionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SessionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Session'> extends True ? Prisma__SessionClient<SessionGetPayload<T>> : Prisma__SessionClient<SessionGetPayload<T> | null, null>

    /**
     * Find the first Session that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SessionFindFirstOrThrowArgs>
    ): Prisma__SessionClient<SessionGetPayload<T>>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SessionFindManyArgs>(
      args?: SelectSubset<T, SessionFindManyArgs>
    ): Prisma.PrismaPromise<Array<SessionGetPayload<T>>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
    **/
    create<T extends SessionCreateArgs>(
      args: SelectSubset<T, SessionCreateArgs>
    ): Prisma__SessionClient<SessionGetPayload<T>>

    /**
     * Create many Sessions.
     *     @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     *     @example
     *     // Create many Sessions
     *     const session = await prisma.session.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SessionCreateManyArgs>(
      args?: SelectSubset<T, SessionCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
    **/
    delete<T extends SessionDeleteArgs>(
      args: SelectSubset<T, SessionDeleteArgs>
    ): Prisma__SessionClient<SessionGetPayload<T>>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SessionUpdateArgs>(
      args: SelectSubset<T, SessionUpdateArgs>
    ): Prisma__SessionClient<SessionGetPayload<T>>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SessionDeleteManyArgs>(
      args?: SelectSubset<T, SessionDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SessionUpdateManyArgs>(
      args: SelectSubset<T, SessionUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
    **/
    upsert<T extends SessionUpsertArgs>(
      args: SelectSubset<T, SessionUpsertArgs>
    ): Prisma__SessionClient<SessionGetPayload<T>>

    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SessionClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Session base type for findUnique actions
   */
  export type SessionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUnique
   */
  export interface SessionFindUniqueArgs extends SessionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }


  /**
   * Session base type for findFirst actions
   */
  export type SessionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: Enumerable<SessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: Enumerable<SessionScalarFieldEnum>
  }

  /**
   * Session findFirst
   */
  export interface SessionFindFirstArgs extends SessionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: Enumerable<SessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: Enumerable<SessionScalarFieldEnum>
  }


  /**
   * Session findMany
   */
  export type SessionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: Enumerable<SessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: Enumerable<SessionScalarFieldEnum>
  }


  /**
   * Session create
   */
  export type SessionCreateArgs = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }


  /**
   * Session createMany
   */
  export type SessionCreateManyArgs = {
    /**
     * The data used to create many Sessions.
     */
    data: Enumerable<SessionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Session update
   */
  export type SessionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }


  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }


  /**
   * Session upsert
   */
  export type SessionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }


  /**
   * Session delete
   */
  export type SessionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }


  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }


  /**
   * Session without action
   */
  export type SessionArgs = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect | null
  }



  /**
   * Model SmsRequestAttempt
   */


  export type AggregateSmsRequestAttempt = {
    _count: SmsRequestAttemptCountAggregateOutputType | null
    _min: SmsRequestAttemptMinAggregateOutputType | null
    _max: SmsRequestAttemptMaxAggregateOutputType | null
  }

  export type SmsRequestAttemptMinAggregateOutputType = {
    id: string | null
    phoneNumber: string | null
    ipAddress: string | null
    createdAt: Date | null
  }

  export type SmsRequestAttemptMaxAggregateOutputType = {
    id: string | null
    phoneNumber: string | null
    ipAddress: string | null
    createdAt: Date | null
  }

  export type SmsRequestAttemptCountAggregateOutputType = {
    id: number
    phoneNumber: number
    ipAddress: number
    createdAt: number
    _all: number
  }


  export type SmsRequestAttemptMinAggregateInputType = {
    id?: true
    phoneNumber?: true
    ipAddress?: true
    createdAt?: true
  }

  export type SmsRequestAttemptMaxAggregateInputType = {
    id?: true
    phoneNumber?: true
    ipAddress?: true
    createdAt?: true
  }

  export type SmsRequestAttemptCountAggregateInputType = {
    id?: true
    phoneNumber?: true
    ipAddress?: true
    createdAt?: true
    _all?: true
  }

  export type SmsRequestAttemptAggregateArgs = {
    /**
     * Filter which SmsRequestAttempt to aggregate.
     */
    where?: SmsRequestAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SmsRequestAttempts to fetch.
     */
    orderBy?: Enumerable<SmsRequestAttemptOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SmsRequestAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SmsRequestAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SmsRequestAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SmsRequestAttempts
    **/
    _count?: true | SmsRequestAttemptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SmsRequestAttemptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SmsRequestAttemptMaxAggregateInputType
  }

  export type GetSmsRequestAttemptAggregateType<T extends SmsRequestAttemptAggregateArgs> = {
        [P in keyof T & keyof AggregateSmsRequestAttempt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSmsRequestAttempt[P]>
      : GetScalarType<T[P], AggregateSmsRequestAttempt[P]>
  }




  export type SmsRequestAttemptGroupByArgs = {
    where?: SmsRequestAttemptWhereInput
    orderBy?: Enumerable<SmsRequestAttemptOrderByWithAggregationInput>
    by: SmsRequestAttemptScalarFieldEnum[]
    having?: SmsRequestAttemptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SmsRequestAttemptCountAggregateInputType | true
    _min?: SmsRequestAttemptMinAggregateInputType
    _max?: SmsRequestAttemptMaxAggregateInputType
  }


  export type SmsRequestAttemptGroupByOutputType = {
    id: string
    phoneNumber: string
    ipAddress: string
    createdAt: Date
    _count: SmsRequestAttemptCountAggregateOutputType | null
    _min: SmsRequestAttemptMinAggregateOutputType | null
    _max: SmsRequestAttemptMaxAggregateOutputType | null
  }

  type GetSmsRequestAttemptGroupByPayload<T extends SmsRequestAttemptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SmsRequestAttemptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SmsRequestAttemptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SmsRequestAttemptGroupByOutputType[P]>
            : GetScalarType<T[P], SmsRequestAttemptGroupByOutputType[P]>
        }
      >
    >


  export type SmsRequestAttemptSelect = {
    id?: boolean
    phoneNumber?: boolean
    ipAddress?: boolean
    createdAt?: boolean
  }


  export type SmsRequestAttemptGetPayload<S extends boolean | null | undefined | SmsRequestAttemptArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SmsRequestAttempt :
    S extends undefined ? never :
    S extends { include: any } & (SmsRequestAttemptArgs | SmsRequestAttemptFindManyArgs)
    ? SmsRequestAttempt 
    : S extends { select: any } & (SmsRequestAttemptArgs | SmsRequestAttemptFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof SmsRequestAttempt ? SmsRequestAttempt[P] : never
  } 
      : SmsRequestAttempt


  type SmsRequestAttemptCountArgs = 
    Omit<SmsRequestAttemptFindManyArgs, 'select' | 'include'> & {
      select?: SmsRequestAttemptCountAggregateInputType | true
    }

  export interface SmsRequestAttemptDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one SmsRequestAttempt that matches the filter.
     * @param {SmsRequestAttemptFindUniqueArgs} args - Arguments to find a SmsRequestAttempt
     * @example
     * // Get one SmsRequestAttempt
     * const smsRequestAttempt = await prisma.smsRequestAttempt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SmsRequestAttemptFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SmsRequestAttemptFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SmsRequestAttempt'> extends True ? Prisma__SmsRequestAttemptClient<SmsRequestAttemptGetPayload<T>> : Prisma__SmsRequestAttemptClient<SmsRequestAttemptGetPayload<T> | null, null>

    /**
     * Find one SmsRequestAttempt that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SmsRequestAttemptFindUniqueOrThrowArgs} args - Arguments to find a SmsRequestAttempt
     * @example
     * // Get one SmsRequestAttempt
     * const smsRequestAttempt = await prisma.smsRequestAttempt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SmsRequestAttemptFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SmsRequestAttemptFindUniqueOrThrowArgs>
    ): Prisma__SmsRequestAttemptClient<SmsRequestAttemptGetPayload<T>>

    /**
     * Find the first SmsRequestAttempt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmsRequestAttemptFindFirstArgs} args - Arguments to find a SmsRequestAttempt
     * @example
     * // Get one SmsRequestAttempt
     * const smsRequestAttempt = await prisma.smsRequestAttempt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SmsRequestAttemptFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SmsRequestAttemptFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SmsRequestAttempt'> extends True ? Prisma__SmsRequestAttemptClient<SmsRequestAttemptGetPayload<T>> : Prisma__SmsRequestAttemptClient<SmsRequestAttemptGetPayload<T> | null, null>

    /**
     * Find the first SmsRequestAttempt that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmsRequestAttemptFindFirstOrThrowArgs} args - Arguments to find a SmsRequestAttempt
     * @example
     * // Get one SmsRequestAttempt
     * const smsRequestAttempt = await prisma.smsRequestAttempt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SmsRequestAttemptFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SmsRequestAttemptFindFirstOrThrowArgs>
    ): Prisma__SmsRequestAttemptClient<SmsRequestAttemptGetPayload<T>>

    /**
     * Find zero or more SmsRequestAttempts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmsRequestAttemptFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SmsRequestAttempts
     * const smsRequestAttempts = await prisma.smsRequestAttempt.findMany()
     * 
     * // Get first 10 SmsRequestAttempts
     * const smsRequestAttempts = await prisma.smsRequestAttempt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const smsRequestAttemptWithIdOnly = await prisma.smsRequestAttempt.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SmsRequestAttemptFindManyArgs>(
      args?: SelectSubset<T, SmsRequestAttemptFindManyArgs>
    ): Prisma.PrismaPromise<Array<SmsRequestAttemptGetPayload<T>>>

    /**
     * Create a SmsRequestAttempt.
     * @param {SmsRequestAttemptCreateArgs} args - Arguments to create a SmsRequestAttempt.
     * @example
     * // Create one SmsRequestAttempt
     * const SmsRequestAttempt = await prisma.smsRequestAttempt.create({
     *   data: {
     *     // ... data to create a SmsRequestAttempt
     *   }
     * })
     * 
    **/
    create<T extends SmsRequestAttemptCreateArgs>(
      args: SelectSubset<T, SmsRequestAttemptCreateArgs>
    ): Prisma__SmsRequestAttemptClient<SmsRequestAttemptGetPayload<T>>

    /**
     * Create many SmsRequestAttempts.
     *     @param {SmsRequestAttemptCreateManyArgs} args - Arguments to create many SmsRequestAttempts.
     *     @example
     *     // Create many SmsRequestAttempts
     *     const smsRequestAttempt = await prisma.smsRequestAttempt.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SmsRequestAttemptCreateManyArgs>(
      args?: SelectSubset<T, SmsRequestAttemptCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SmsRequestAttempt.
     * @param {SmsRequestAttemptDeleteArgs} args - Arguments to delete one SmsRequestAttempt.
     * @example
     * // Delete one SmsRequestAttempt
     * const SmsRequestAttempt = await prisma.smsRequestAttempt.delete({
     *   where: {
     *     // ... filter to delete one SmsRequestAttempt
     *   }
     * })
     * 
    **/
    delete<T extends SmsRequestAttemptDeleteArgs>(
      args: SelectSubset<T, SmsRequestAttemptDeleteArgs>
    ): Prisma__SmsRequestAttemptClient<SmsRequestAttemptGetPayload<T>>

    /**
     * Update one SmsRequestAttempt.
     * @param {SmsRequestAttemptUpdateArgs} args - Arguments to update one SmsRequestAttempt.
     * @example
     * // Update one SmsRequestAttempt
     * const smsRequestAttempt = await prisma.smsRequestAttempt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SmsRequestAttemptUpdateArgs>(
      args: SelectSubset<T, SmsRequestAttemptUpdateArgs>
    ): Prisma__SmsRequestAttemptClient<SmsRequestAttemptGetPayload<T>>

    /**
     * Delete zero or more SmsRequestAttempts.
     * @param {SmsRequestAttemptDeleteManyArgs} args - Arguments to filter SmsRequestAttempts to delete.
     * @example
     * // Delete a few SmsRequestAttempts
     * const { count } = await prisma.smsRequestAttempt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SmsRequestAttemptDeleteManyArgs>(
      args?: SelectSubset<T, SmsRequestAttemptDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SmsRequestAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmsRequestAttemptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SmsRequestAttempts
     * const smsRequestAttempt = await prisma.smsRequestAttempt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SmsRequestAttemptUpdateManyArgs>(
      args: SelectSubset<T, SmsRequestAttemptUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SmsRequestAttempt.
     * @param {SmsRequestAttemptUpsertArgs} args - Arguments to update or create a SmsRequestAttempt.
     * @example
     * // Update or create a SmsRequestAttempt
     * const smsRequestAttempt = await prisma.smsRequestAttempt.upsert({
     *   create: {
     *     // ... data to create a SmsRequestAttempt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SmsRequestAttempt we want to update
     *   }
     * })
    **/
    upsert<T extends SmsRequestAttemptUpsertArgs>(
      args: SelectSubset<T, SmsRequestAttemptUpsertArgs>
    ): Prisma__SmsRequestAttemptClient<SmsRequestAttemptGetPayload<T>>

    /**
     * Count the number of SmsRequestAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmsRequestAttemptCountArgs} args - Arguments to filter SmsRequestAttempts to count.
     * @example
     * // Count the number of SmsRequestAttempts
     * const count = await prisma.smsRequestAttempt.count({
     *   where: {
     *     // ... the filter for the SmsRequestAttempts we want to count
     *   }
     * })
    **/
    count<T extends SmsRequestAttemptCountArgs>(
      args?: Subset<T, SmsRequestAttemptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SmsRequestAttemptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SmsRequestAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmsRequestAttemptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SmsRequestAttemptAggregateArgs>(args: Subset<T, SmsRequestAttemptAggregateArgs>): Prisma.PrismaPromise<GetSmsRequestAttemptAggregateType<T>>

    /**
     * Group by SmsRequestAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmsRequestAttemptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SmsRequestAttemptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SmsRequestAttemptGroupByArgs['orderBy'] }
        : { orderBy?: SmsRequestAttemptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SmsRequestAttemptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSmsRequestAttemptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SmsRequestAttempt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SmsRequestAttemptClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SmsRequestAttempt base type for findUnique actions
   */
  export type SmsRequestAttemptFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SmsRequestAttempt
     */
    select?: SmsRequestAttemptSelect | null
    /**
     * Filter, which SmsRequestAttempt to fetch.
     */
    where: SmsRequestAttemptWhereUniqueInput
  }

  /**
   * SmsRequestAttempt findUnique
   */
  export interface SmsRequestAttemptFindUniqueArgs extends SmsRequestAttemptFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SmsRequestAttempt findUniqueOrThrow
   */
  export type SmsRequestAttemptFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SmsRequestAttempt
     */
    select?: SmsRequestAttemptSelect | null
    /**
     * Filter, which SmsRequestAttempt to fetch.
     */
    where: SmsRequestAttemptWhereUniqueInput
  }


  /**
   * SmsRequestAttempt base type for findFirst actions
   */
  export type SmsRequestAttemptFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SmsRequestAttempt
     */
    select?: SmsRequestAttemptSelect | null
    /**
     * Filter, which SmsRequestAttempt to fetch.
     */
    where?: SmsRequestAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SmsRequestAttempts to fetch.
     */
    orderBy?: Enumerable<SmsRequestAttemptOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SmsRequestAttempts.
     */
    cursor?: SmsRequestAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SmsRequestAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SmsRequestAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SmsRequestAttempts.
     */
    distinct?: Enumerable<SmsRequestAttemptScalarFieldEnum>
  }

  /**
   * SmsRequestAttempt findFirst
   */
  export interface SmsRequestAttemptFindFirstArgs extends SmsRequestAttemptFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SmsRequestAttempt findFirstOrThrow
   */
  export type SmsRequestAttemptFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SmsRequestAttempt
     */
    select?: SmsRequestAttemptSelect | null
    /**
     * Filter, which SmsRequestAttempt to fetch.
     */
    where?: SmsRequestAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SmsRequestAttempts to fetch.
     */
    orderBy?: Enumerable<SmsRequestAttemptOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SmsRequestAttempts.
     */
    cursor?: SmsRequestAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SmsRequestAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SmsRequestAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SmsRequestAttempts.
     */
    distinct?: Enumerable<SmsRequestAttemptScalarFieldEnum>
  }


  /**
   * SmsRequestAttempt findMany
   */
  export type SmsRequestAttemptFindManyArgs = {
    /**
     * Select specific fields to fetch from the SmsRequestAttempt
     */
    select?: SmsRequestAttemptSelect | null
    /**
     * Filter, which SmsRequestAttempts to fetch.
     */
    where?: SmsRequestAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SmsRequestAttempts to fetch.
     */
    orderBy?: Enumerable<SmsRequestAttemptOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SmsRequestAttempts.
     */
    cursor?: SmsRequestAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SmsRequestAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SmsRequestAttempts.
     */
    skip?: number
    distinct?: Enumerable<SmsRequestAttemptScalarFieldEnum>
  }


  /**
   * SmsRequestAttempt create
   */
  export type SmsRequestAttemptCreateArgs = {
    /**
     * Select specific fields to fetch from the SmsRequestAttempt
     */
    select?: SmsRequestAttemptSelect | null
    /**
     * The data needed to create a SmsRequestAttempt.
     */
    data: XOR<SmsRequestAttemptCreateInput, SmsRequestAttemptUncheckedCreateInput>
  }


  /**
   * SmsRequestAttempt createMany
   */
  export type SmsRequestAttemptCreateManyArgs = {
    /**
     * The data used to create many SmsRequestAttempts.
     */
    data: Enumerable<SmsRequestAttemptCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SmsRequestAttempt update
   */
  export type SmsRequestAttemptUpdateArgs = {
    /**
     * Select specific fields to fetch from the SmsRequestAttempt
     */
    select?: SmsRequestAttemptSelect | null
    /**
     * The data needed to update a SmsRequestAttempt.
     */
    data: XOR<SmsRequestAttemptUpdateInput, SmsRequestAttemptUncheckedUpdateInput>
    /**
     * Choose, which SmsRequestAttempt to update.
     */
    where: SmsRequestAttemptWhereUniqueInput
  }


  /**
   * SmsRequestAttempt updateMany
   */
  export type SmsRequestAttemptUpdateManyArgs = {
    /**
     * The data used to update SmsRequestAttempts.
     */
    data: XOR<SmsRequestAttemptUpdateManyMutationInput, SmsRequestAttemptUncheckedUpdateManyInput>
    /**
     * Filter which SmsRequestAttempts to update
     */
    where?: SmsRequestAttemptWhereInput
  }


  /**
   * SmsRequestAttempt upsert
   */
  export type SmsRequestAttemptUpsertArgs = {
    /**
     * Select specific fields to fetch from the SmsRequestAttempt
     */
    select?: SmsRequestAttemptSelect | null
    /**
     * The filter to search for the SmsRequestAttempt to update in case it exists.
     */
    where: SmsRequestAttemptWhereUniqueInput
    /**
     * In case the SmsRequestAttempt found by the `where` argument doesn't exist, create a new SmsRequestAttempt with this data.
     */
    create: XOR<SmsRequestAttemptCreateInput, SmsRequestAttemptUncheckedCreateInput>
    /**
     * In case the SmsRequestAttempt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SmsRequestAttemptUpdateInput, SmsRequestAttemptUncheckedUpdateInput>
  }


  /**
   * SmsRequestAttempt delete
   */
  export type SmsRequestAttemptDeleteArgs = {
    /**
     * Select specific fields to fetch from the SmsRequestAttempt
     */
    select?: SmsRequestAttemptSelect | null
    /**
     * Filter which SmsRequestAttempt to delete.
     */
    where: SmsRequestAttemptWhereUniqueInput
  }


  /**
   * SmsRequestAttempt deleteMany
   */
  export type SmsRequestAttemptDeleteManyArgs = {
    /**
     * Filter which SmsRequestAttempts to delete
     */
    where?: SmsRequestAttemptWhereInput
  }


  /**
   * SmsRequestAttempt without action
   */
  export type SmsRequestAttemptArgs = {
    /**
     * Select specific fields to fetch from the SmsRequestAttempt
     */
    select?: SmsRequestAttemptSelect | null
  }



  /**
   * Model FileUpload
   */


  export type AggregateFileUpload = {
    _count: FileUploadCountAggregateOutputType | null
    _min: FileUploadMinAggregateOutputType | null
    _max: FileUploadMaxAggregateOutputType | null
  }

  export type FileUploadMinAggregateOutputType = {
    id: string | null
    fileGroup: string | null
    fileLink: string | null
    fileSource: string | null
    removedAt: Date | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    fileCategory: string | null
    fileSourceDate: string | null
    fileMIMEType: string | null
  }

  export type FileUploadMaxAggregateOutputType = {
    id: string | null
    fileGroup: string | null
    fileLink: string | null
    fileSource: string | null
    removedAt: Date | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    fileCategory: string | null
    fileSourceDate: string | null
    fileMIMEType: string | null
  }

  export type FileUploadCountAggregateOutputType = {
    id: number
    fileGroup: number
    fileLink: number
    fileSource: number
    removedAt: number
    createdBy: number
    createdAt: number
    updatedAt: number
    fileCategory: number
    fileSourceDate: number
    fileMIMEType: number
    _all: number
  }


  export type FileUploadMinAggregateInputType = {
    id?: true
    fileGroup?: true
    fileLink?: true
    fileSource?: true
    removedAt?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    fileCategory?: true
    fileSourceDate?: true
    fileMIMEType?: true
  }

  export type FileUploadMaxAggregateInputType = {
    id?: true
    fileGroup?: true
    fileLink?: true
    fileSource?: true
    removedAt?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    fileCategory?: true
    fileSourceDate?: true
    fileMIMEType?: true
  }

  export type FileUploadCountAggregateInputType = {
    id?: true
    fileGroup?: true
    fileLink?: true
    fileSource?: true
    removedAt?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    fileCategory?: true
    fileSourceDate?: true
    fileMIMEType?: true
    _all?: true
  }

  export type FileUploadAggregateArgs = {
    /**
     * Filter which FileUpload to aggregate.
     */
    where?: FileUploadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileUploads to fetch.
     */
    orderBy?: Enumerable<FileUploadOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FileUploadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileUploads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileUploads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FileUploads
    **/
    _count?: true | FileUploadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileUploadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileUploadMaxAggregateInputType
  }

  export type GetFileUploadAggregateType<T extends FileUploadAggregateArgs> = {
        [P in keyof T & keyof AggregateFileUpload]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFileUpload[P]>
      : GetScalarType<T[P], AggregateFileUpload[P]>
  }




  export type FileUploadGroupByArgs = {
    where?: FileUploadWhereInput
    orderBy?: Enumerable<FileUploadOrderByWithAggregationInput>
    by: FileUploadScalarFieldEnum[]
    having?: FileUploadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileUploadCountAggregateInputType | true
    _min?: FileUploadMinAggregateInputType
    _max?: FileUploadMaxAggregateInputType
  }


  export type FileUploadGroupByOutputType = {
    id: string
    fileGroup: string | null
    fileLink: string
    fileSource: string
    removedAt: Date | null
    createdBy: string
    createdAt: Date
    updatedAt: Date
    fileCategory: string | null
    fileSourceDate: string | null
    fileMIMEType: string
    _count: FileUploadCountAggregateOutputType | null
    _min: FileUploadMinAggregateOutputType | null
    _max: FileUploadMaxAggregateOutputType | null
  }

  type GetFileUploadGroupByPayload<T extends FileUploadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FileUploadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileUploadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileUploadGroupByOutputType[P]>
            : GetScalarType<T[P], FileUploadGroupByOutputType[P]>
        }
      >
    >


  export type FileUploadSelect = {
    id?: boolean
    fileGroup?: boolean
    fileLink?: boolean
    fileSource?: boolean
    removedAt?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fileCategory?: boolean
    fileSourceDate?: boolean
    fileMIMEType?: boolean
  }


  export type FileUploadGetPayload<S extends boolean | null | undefined | FileUploadArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FileUpload :
    S extends undefined ? never :
    S extends { include: any } & (FileUploadArgs | FileUploadFindManyArgs)
    ? FileUpload 
    : S extends { select: any } & (FileUploadArgs | FileUploadFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof FileUpload ? FileUpload[P] : never
  } 
      : FileUpload


  type FileUploadCountArgs = 
    Omit<FileUploadFindManyArgs, 'select' | 'include'> & {
      select?: FileUploadCountAggregateInputType | true
    }

  export interface FileUploadDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one FileUpload that matches the filter.
     * @param {FileUploadFindUniqueArgs} args - Arguments to find a FileUpload
     * @example
     * // Get one FileUpload
     * const fileUpload = await prisma.fileUpload.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FileUploadFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FileUploadFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FileUpload'> extends True ? Prisma__FileUploadClient<FileUploadGetPayload<T>> : Prisma__FileUploadClient<FileUploadGetPayload<T> | null, null>

    /**
     * Find one FileUpload that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FileUploadFindUniqueOrThrowArgs} args - Arguments to find a FileUpload
     * @example
     * // Get one FileUpload
     * const fileUpload = await prisma.fileUpload.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FileUploadFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FileUploadFindUniqueOrThrowArgs>
    ): Prisma__FileUploadClient<FileUploadGetPayload<T>>

    /**
     * Find the first FileUpload that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileUploadFindFirstArgs} args - Arguments to find a FileUpload
     * @example
     * // Get one FileUpload
     * const fileUpload = await prisma.fileUpload.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FileUploadFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FileUploadFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FileUpload'> extends True ? Prisma__FileUploadClient<FileUploadGetPayload<T>> : Prisma__FileUploadClient<FileUploadGetPayload<T> | null, null>

    /**
     * Find the first FileUpload that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileUploadFindFirstOrThrowArgs} args - Arguments to find a FileUpload
     * @example
     * // Get one FileUpload
     * const fileUpload = await prisma.fileUpload.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FileUploadFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FileUploadFindFirstOrThrowArgs>
    ): Prisma__FileUploadClient<FileUploadGetPayload<T>>

    /**
     * Find zero or more FileUploads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileUploadFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FileUploads
     * const fileUploads = await prisma.fileUpload.findMany()
     * 
     * // Get first 10 FileUploads
     * const fileUploads = await prisma.fileUpload.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileUploadWithIdOnly = await prisma.fileUpload.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FileUploadFindManyArgs>(
      args?: SelectSubset<T, FileUploadFindManyArgs>
    ): Prisma.PrismaPromise<Array<FileUploadGetPayload<T>>>

    /**
     * Create a FileUpload.
     * @param {FileUploadCreateArgs} args - Arguments to create a FileUpload.
     * @example
     * // Create one FileUpload
     * const FileUpload = await prisma.fileUpload.create({
     *   data: {
     *     // ... data to create a FileUpload
     *   }
     * })
     * 
    **/
    create<T extends FileUploadCreateArgs>(
      args: SelectSubset<T, FileUploadCreateArgs>
    ): Prisma__FileUploadClient<FileUploadGetPayload<T>>

    /**
     * Create many FileUploads.
     *     @param {FileUploadCreateManyArgs} args - Arguments to create many FileUploads.
     *     @example
     *     // Create many FileUploads
     *     const fileUpload = await prisma.fileUpload.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FileUploadCreateManyArgs>(
      args?: SelectSubset<T, FileUploadCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FileUpload.
     * @param {FileUploadDeleteArgs} args - Arguments to delete one FileUpload.
     * @example
     * // Delete one FileUpload
     * const FileUpload = await prisma.fileUpload.delete({
     *   where: {
     *     // ... filter to delete one FileUpload
     *   }
     * })
     * 
    **/
    delete<T extends FileUploadDeleteArgs>(
      args: SelectSubset<T, FileUploadDeleteArgs>
    ): Prisma__FileUploadClient<FileUploadGetPayload<T>>

    /**
     * Update one FileUpload.
     * @param {FileUploadUpdateArgs} args - Arguments to update one FileUpload.
     * @example
     * // Update one FileUpload
     * const fileUpload = await prisma.fileUpload.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FileUploadUpdateArgs>(
      args: SelectSubset<T, FileUploadUpdateArgs>
    ): Prisma__FileUploadClient<FileUploadGetPayload<T>>

    /**
     * Delete zero or more FileUploads.
     * @param {FileUploadDeleteManyArgs} args - Arguments to filter FileUploads to delete.
     * @example
     * // Delete a few FileUploads
     * const { count } = await prisma.fileUpload.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FileUploadDeleteManyArgs>(
      args?: SelectSubset<T, FileUploadDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FileUploads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileUploadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FileUploads
     * const fileUpload = await prisma.fileUpload.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FileUploadUpdateManyArgs>(
      args: SelectSubset<T, FileUploadUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FileUpload.
     * @param {FileUploadUpsertArgs} args - Arguments to update or create a FileUpload.
     * @example
     * // Update or create a FileUpload
     * const fileUpload = await prisma.fileUpload.upsert({
     *   create: {
     *     // ... data to create a FileUpload
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FileUpload we want to update
     *   }
     * })
    **/
    upsert<T extends FileUploadUpsertArgs>(
      args: SelectSubset<T, FileUploadUpsertArgs>
    ): Prisma__FileUploadClient<FileUploadGetPayload<T>>

    /**
     * Count the number of FileUploads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileUploadCountArgs} args - Arguments to filter FileUploads to count.
     * @example
     * // Count the number of FileUploads
     * const count = await prisma.fileUpload.count({
     *   where: {
     *     // ... the filter for the FileUploads we want to count
     *   }
     * })
    **/
    count<T extends FileUploadCountArgs>(
      args?: Subset<T, FileUploadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileUploadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FileUpload.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileUploadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileUploadAggregateArgs>(args: Subset<T, FileUploadAggregateArgs>): Prisma.PrismaPromise<GetFileUploadAggregateType<T>>

    /**
     * Group by FileUpload.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileUploadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileUploadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileUploadGroupByArgs['orderBy'] }
        : { orderBy?: FileUploadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileUploadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileUploadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FileUpload.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FileUploadClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FileUpload base type for findUnique actions
   */
  export type FileUploadFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the FileUpload
     */
    select?: FileUploadSelect | null
    /**
     * Filter, which FileUpload to fetch.
     */
    where: FileUploadWhereUniqueInput
  }

  /**
   * FileUpload findUnique
   */
  export interface FileUploadFindUniqueArgs extends FileUploadFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FileUpload findUniqueOrThrow
   */
  export type FileUploadFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FileUpload
     */
    select?: FileUploadSelect | null
    /**
     * Filter, which FileUpload to fetch.
     */
    where: FileUploadWhereUniqueInput
  }


  /**
   * FileUpload base type for findFirst actions
   */
  export type FileUploadFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the FileUpload
     */
    select?: FileUploadSelect | null
    /**
     * Filter, which FileUpload to fetch.
     */
    where?: FileUploadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileUploads to fetch.
     */
    orderBy?: Enumerable<FileUploadOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FileUploads.
     */
    cursor?: FileUploadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileUploads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileUploads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FileUploads.
     */
    distinct?: Enumerable<FileUploadScalarFieldEnum>
  }

  /**
   * FileUpload findFirst
   */
  export interface FileUploadFindFirstArgs extends FileUploadFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FileUpload findFirstOrThrow
   */
  export type FileUploadFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FileUpload
     */
    select?: FileUploadSelect | null
    /**
     * Filter, which FileUpload to fetch.
     */
    where?: FileUploadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileUploads to fetch.
     */
    orderBy?: Enumerable<FileUploadOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FileUploads.
     */
    cursor?: FileUploadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileUploads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileUploads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FileUploads.
     */
    distinct?: Enumerable<FileUploadScalarFieldEnum>
  }


  /**
   * FileUpload findMany
   */
  export type FileUploadFindManyArgs = {
    /**
     * Select specific fields to fetch from the FileUpload
     */
    select?: FileUploadSelect | null
    /**
     * Filter, which FileUploads to fetch.
     */
    where?: FileUploadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileUploads to fetch.
     */
    orderBy?: Enumerable<FileUploadOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FileUploads.
     */
    cursor?: FileUploadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileUploads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileUploads.
     */
    skip?: number
    distinct?: Enumerable<FileUploadScalarFieldEnum>
  }


  /**
   * FileUpload create
   */
  export type FileUploadCreateArgs = {
    /**
     * Select specific fields to fetch from the FileUpload
     */
    select?: FileUploadSelect | null
    /**
     * The data needed to create a FileUpload.
     */
    data: XOR<FileUploadCreateInput, FileUploadUncheckedCreateInput>
  }


  /**
   * FileUpload createMany
   */
  export type FileUploadCreateManyArgs = {
    /**
     * The data used to create many FileUploads.
     */
    data: Enumerable<FileUploadCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FileUpload update
   */
  export type FileUploadUpdateArgs = {
    /**
     * Select specific fields to fetch from the FileUpload
     */
    select?: FileUploadSelect | null
    /**
     * The data needed to update a FileUpload.
     */
    data: XOR<FileUploadUpdateInput, FileUploadUncheckedUpdateInput>
    /**
     * Choose, which FileUpload to update.
     */
    where: FileUploadWhereUniqueInput
  }


  /**
   * FileUpload updateMany
   */
  export type FileUploadUpdateManyArgs = {
    /**
     * The data used to update FileUploads.
     */
    data: XOR<FileUploadUpdateManyMutationInput, FileUploadUncheckedUpdateManyInput>
    /**
     * Filter which FileUploads to update
     */
    where?: FileUploadWhereInput
  }


  /**
   * FileUpload upsert
   */
  export type FileUploadUpsertArgs = {
    /**
     * Select specific fields to fetch from the FileUpload
     */
    select?: FileUploadSelect | null
    /**
     * The filter to search for the FileUpload to update in case it exists.
     */
    where: FileUploadWhereUniqueInput
    /**
     * In case the FileUpload found by the `where` argument doesn't exist, create a new FileUpload with this data.
     */
    create: XOR<FileUploadCreateInput, FileUploadUncheckedCreateInput>
    /**
     * In case the FileUpload was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FileUploadUpdateInput, FileUploadUncheckedUpdateInput>
  }


  /**
   * FileUpload delete
   */
  export type FileUploadDeleteArgs = {
    /**
     * Select specific fields to fetch from the FileUpload
     */
    select?: FileUploadSelect | null
    /**
     * Filter which FileUpload to delete.
     */
    where: FileUploadWhereUniqueInput
  }


  /**
   * FileUpload deleteMany
   */
  export type FileUploadDeleteManyArgs = {
    /**
     * Filter which FileUploads to delete
     */
    where?: FileUploadWhereInput
  }


  /**
   * FileUpload without action
   */
  export type FileUploadArgs = {
    /**
     * Select specific fields to fetch from the FileUpload
     */
    select?: FileUploadSelect | null
  }



  /**
   * Model FirebaseToken
   */


  export type AggregateFirebaseToken = {
    _count: FirebaseTokenCountAggregateOutputType | null
    _min: FirebaseTokenMinAggregateOutputType | null
    _max: FirebaseTokenMaxAggregateOutputType | null
  }

  export type FirebaseTokenMinAggregateOutputType = {
    id: string | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FirebaseTokenMaxAggregateOutputType = {
    id: string | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FirebaseTokenCountAggregateOutputType = {
    id: number
    token: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FirebaseTokenMinAggregateInputType = {
    id?: true
    token?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FirebaseTokenMaxAggregateInputType = {
    id?: true
    token?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FirebaseTokenCountAggregateInputType = {
    id?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FirebaseTokenAggregateArgs = {
    /**
     * Filter which FirebaseToken to aggregate.
     */
    where?: FirebaseTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FirebaseTokens to fetch.
     */
    orderBy?: Enumerable<FirebaseTokenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FirebaseTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FirebaseTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FirebaseTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FirebaseTokens
    **/
    _count?: true | FirebaseTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FirebaseTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FirebaseTokenMaxAggregateInputType
  }

  export type GetFirebaseTokenAggregateType<T extends FirebaseTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateFirebaseToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFirebaseToken[P]>
      : GetScalarType<T[P], AggregateFirebaseToken[P]>
  }




  export type FirebaseTokenGroupByArgs = {
    where?: FirebaseTokenWhereInput
    orderBy?: Enumerable<FirebaseTokenOrderByWithAggregationInput>
    by: FirebaseTokenScalarFieldEnum[]
    having?: FirebaseTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FirebaseTokenCountAggregateInputType | true
    _min?: FirebaseTokenMinAggregateInputType
    _max?: FirebaseTokenMaxAggregateInputType
  }


  export type FirebaseTokenGroupByOutputType = {
    id: string
    token: string
    createdAt: Date
    updatedAt: Date
    _count: FirebaseTokenCountAggregateOutputType | null
    _min: FirebaseTokenMinAggregateOutputType | null
    _max: FirebaseTokenMaxAggregateOutputType | null
  }

  type GetFirebaseTokenGroupByPayload<T extends FirebaseTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FirebaseTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FirebaseTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FirebaseTokenGroupByOutputType[P]>
            : GetScalarType<T[P], FirebaseTokenGroupByOutputType[P]>
        }
      >
    >


  export type FirebaseTokenSelect = {
    id?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type FirebaseTokenGetPayload<S extends boolean | null | undefined | FirebaseTokenArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FirebaseToken :
    S extends undefined ? never :
    S extends { include: any } & (FirebaseTokenArgs | FirebaseTokenFindManyArgs)
    ? FirebaseToken 
    : S extends { select: any } & (FirebaseTokenArgs | FirebaseTokenFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof FirebaseToken ? FirebaseToken[P] : never
  } 
      : FirebaseToken


  type FirebaseTokenCountArgs = 
    Omit<FirebaseTokenFindManyArgs, 'select' | 'include'> & {
      select?: FirebaseTokenCountAggregateInputType | true
    }

  export interface FirebaseTokenDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one FirebaseToken that matches the filter.
     * @param {FirebaseTokenFindUniqueArgs} args - Arguments to find a FirebaseToken
     * @example
     * // Get one FirebaseToken
     * const firebaseToken = await prisma.firebaseToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FirebaseTokenFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FirebaseTokenFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FirebaseToken'> extends True ? Prisma__FirebaseTokenClient<FirebaseTokenGetPayload<T>> : Prisma__FirebaseTokenClient<FirebaseTokenGetPayload<T> | null, null>

    /**
     * Find one FirebaseToken that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FirebaseTokenFindUniqueOrThrowArgs} args - Arguments to find a FirebaseToken
     * @example
     * // Get one FirebaseToken
     * const firebaseToken = await prisma.firebaseToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FirebaseTokenFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FirebaseTokenFindUniqueOrThrowArgs>
    ): Prisma__FirebaseTokenClient<FirebaseTokenGetPayload<T>>

    /**
     * Find the first FirebaseToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FirebaseTokenFindFirstArgs} args - Arguments to find a FirebaseToken
     * @example
     * // Get one FirebaseToken
     * const firebaseToken = await prisma.firebaseToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FirebaseTokenFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FirebaseTokenFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FirebaseToken'> extends True ? Prisma__FirebaseTokenClient<FirebaseTokenGetPayload<T>> : Prisma__FirebaseTokenClient<FirebaseTokenGetPayload<T> | null, null>

    /**
     * Find the first FirebaseToken that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FirebaseTokenFindFirstOrThrowArgs} args - Arguments to find a FirebaseToken
     * @example
     * // Get one FirebaseToken
     * const firebaseToken = await prisma.firebaseToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FirebaseTokenFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FirebaseTokenFindFirstOrThrowArgs>
    ): Prisma__FirebaseTokenClient<FirebaseTokenGetPayload<T>>

    /**
     * Find zero or more FirebaseTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FirebaseTokenFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FirebaseTokens
     * const firebaseTokens = await prisma.firebaseToken.findMany()
     * 
     * // Get first 10 FirebaseTokens
     * const firebaseTokens = await prisma.firebaseToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const firebaseTokenWithIdOnly = await prisma.firebaseToken.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FirebaseTokenFindManyArgs>(
      args?: SelectSubset<T, FirebaseTokenFindManyArgs>
    ): Prisma.PrismaPromise<Array<FirebaseTokenGetPayload<T>>>

    /**
     * Create a FirebaseToken.
     * @param {FirebaseTokenCreateArgs} args - Arguments to create a FirebaseToken.
     * @example
     * // Create one FirebaseToken
     * const FirebaseToken = await prisma.firebaseToken.create({
     *   data: {
     *     // ... data to create a FirebaseToken
     *   }
     * })
     * 
    **/
    create<T extends FirebaseTokenCreateArgs>(
      args: SelectSubset<T, FirebaseTokenCreateArgs>
    ): Prisma__FirebaseTokenClient<FirebaseTokenGetPayload<T>>

    /**
     * Create many FirebaseTokens.
     *     @param {FirebaseTokenCreateManyArgs} args - Arguments to create many FirebaseTokens.
     *     @example
     *     // Create many FirebaseTokens
     *     const firebaseToken = await prisma.firebaseToken.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FirebaseTokenCreateManyArgs>(
      args?: SelectSubset<T, FirebaseTokenCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FirebaseToken.
     * @param {FirebaseTokenDeleteArgs} args - Arguments to delete one FirebaseToken.
     * @example
     * // Delete one FirebaseToken
     * const FirebaseToken = await prisma.firebaseToken.delete({
     *   where: {
     *     // ... filter to delete one FirebaseToken
     *   }
     * })
     * 
    **/
    delete<T extends FirebaseTokenDeleteArgs>(
      args: SelectSubset<T, FirebaseTokenDeleteArgs>
    ): Prisma__FirebaseTokenClient<FirebaseTokenGetPayload<T>>

    /**
     * Update one FirebaseToken.
     * @param {FirebaseTokenUpdateArgs} args - Arguments to update one FirebaseToken.
     * @example
     * // Update one FirebaseToken
     * const firebaseToken = await prisma.firebaseToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FirebaseTokenUpdateArgs>(
      args: SelectSubset<T, FirebaseTokenUpdateArgs>
    ): Prisma__FirebaseTokenClient<FirebaseTokenGetPayload<T>>

    /**
     * Delete zero or more FirebaseTokens.
     * @param {FirebaseTokenDeleteManyArgs} args - Arguments to filter FirebaseTokens to delete.
     * @example
     * // Delete a few FirebaseTokens
     * const { count } = await prisma.firebaseToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FirebaseTokenDeleteManyArgs>(
      args?: SelectSubset<T, FirebaseTokenDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FirebaseTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FirebaseTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FirebaseTokens
     * const firebaseToken = await prisma.firebaseToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FirebaseTokenUpdateManyArgs>(
      args: SelectSubset<T, FirebaseTokenUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FirebaseToken.
     * @param {FirebaseTokenUpsertArgs} args - Arguments to update or create a FirebaseToken.
     * @example
     * // Update or create a FirebaseToken
     * const firebaseToken = await prisma.firebaseToken.upsert({
     *   create: {
     *     // ... data to create a FirebaseToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FirebaseToken we want to update
     *   }
     * })
    **/
    upsert<T extends FirebaseTokenUpsertArgs>(
      args: SelectSubset<T, FirebaseTokenUpsertArgs>
    ): Prisma__FirebaseTokenClient<FirebaseTokenGetPayload<T>>

    /**
     * Count the number of FirebaseTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FirebaseTokenCountArgs} args - Arguments to filter FirebaseTokens to count.
     * @example
     * // Count the number of FirebaseTokens
     * const count = await prisma.firebaseToken.count({
     *   where: {
     *     // ... the filter for the FirebaseTokens we want to count
     *   }
     * })
    **/
    count<T extends FirebaseTokenCountArgs>(
      args?: Subset<T, FirebaseTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FirebaseTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FirebaseToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FirebaseTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FirebaseTokenAggregateArgs>(args: Subset<T, FirebaseTokenAggregateArgs>): Prisma.PrismaPromise<GetFirebaseTokenAggregateType<T>>

    /**
     * Group by FirebaseToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FirebaseTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FirebaseTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FirebaseTokenGroupByArgs['orderBy'] }
        : { orderBy?: FirebaseTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FirebaseTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFirebaseTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FirebaseToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FirebaseTokenClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FirebaseToken base type for findUnique actions
   */
  export type FirebaseTokenFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the FirebaseToken
     */
    select?: FirebaseTokenSelect | null
    /**
     * Filter, which FirebaseToken to fetch.
     */
    where: FirebaseTokenWhereUniqueInput
  }

  /**
   * FirebaseToken findUnique
   */
  export interface FirebaseTokenFindUniqueArgs extends FirebaseTokenFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FirebaseToken findUniqueOrThrow
   */
  export type FirebaseTokenFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FirebaseToken
     */
    select?: FirebaseTokenSelect | null
    /**
     * Filter, which FirebaseToken to fetch.
     */
    where: FirebaseTokenWhereUniqueInput
  }


  /**
   * FirebaseToken base type for findFirst actions
   */
  export type FirebaseTokenFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the FirebaseToken
     */
    select?: FirebaseTokenSelect | null
    /**
     * Filter, which FirebaseToken to fetch.
     */
    where?: FirebaseTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FirebaseTokens to fetch.
     */
    orderBy?: Enumerable<FirebaseTokenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FirebaseTokens.
     */
    cursor?: FirebaseTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FirebaseTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FirebaseTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FirebaseTokens.
     */
    distinct?: Enumerable<FirebaseTokenScalarFieldEnum>
  }

  /**
   * FirebaseToken findFirst
   */
  export interface FirebaseTokenFindFirstArgs extends FirebaseTokenFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FirebaseToken findFirstOrThrow
   */
  export type FirebaseTokenFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FirebaseToken
     */
    select?: FirebaseTokenSelect | null
    /**
     * Filter, which FirebaseToken to fetch.
     */
    where?: FirebaseTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FirebaseTokens to fetch.
     */
    orderBy?: Enumerable<FirebaseTokenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FirebaseTokens.
     */
    cursor?: FirebaseTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FirebaseTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FirebaseTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FirebaseTokens.
     */
    distinct?: Enumerable<FirebaseTokenScalarFieldEnum>
  }


  /**
   * FirebaseToken findMany
   */
  export type FirebaseTokenFindManyArgs = {
    /**
     * Select specific fields to fetch from the FirebaseToken
     */
    select?: FirebaseTokenSelect | null
    /**
     * Filter, which FirebaseTokens to fetch.
     */
    where?: FirebaseTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FirebaseTokens to fetch.
     */
    orderBy?: Enumerable<FirebaseTokenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FirebaseTokens.
     */
    cursor?: FirebaseTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FirebaseTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FirebaseTokens.
     */
    skip?: number
    distinct?: Enumerable<FirebaseTokenScalarFieldEnum>
  }


  /**
   * FirebaseToken create
   */
  export type FirebaseTokenCreateArgs = {
    /**
     * Select specific fields to fetch from the FirebaseToken
     */
    select?: FirebaseTokenSelect | null
    /**
     * The data needed to create a FirebaseToken.
     */
    data: XOR<FirebaseTokenCreateInput, FirebaseTokenUncheckedCreateInput>
  }


  /**
   * FirebaseToken createMany
   */
  export type FirebaseTokenCreateManyArgs = {
    /**
     * The data used to create many FirebaseTokens.
     */
    data: Enumerable<FirebaseTokenCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FirebaseToken update
   */
  export type FirebaseTokenUpdateArgs = {
    /**
     * Select specific fields to fetch from the FirebaseToken
     */
    select?: FirebaseTokenSelect | null
    /**
     * The data needed to update a FirebaseToken.
     */
    data: XOR<FirebaseTokenUpdateInput, FirebaseTokenUncheckedUpdateInput>
    /**
     * Choose, which FirebaseToken to update.
     */
    where: FirebaseTokenWhereUniqueInput
  }


  /**
   * FirebaseToken updateMany
   */
  export type FirebaseTokenUpdateManyArgs = {
    /**
     * The data used to update FirebaseTokens.
     */
    data: XOR<FirebaseTokenUpdateManyMutationInput, FirebaseTokenUncheckedUpdateManyInput>
    /**
     * Filter which FirebaseTokens to update
     */
    where?: FirebaseTokenWhereInput
  }


  /**
   * FirebaseToken upsert
   */
  export type FirebaseTokenUpsertArgs = {
    /**
     * Select specific fields to fetch from the FirebaseToken
     */
    select?: FirebaseTokenSelect | null
    /**
     * The filter to search for the FirebaseToken to update in case it exists.
     */
    where: FirebaseTokenWhereUniqueInput
    /**
     * In case the FirebaseToken found by the `where` argument doesn't exist, create a new FirebaseToken with this data.
     */
    create: XOR<FirebaseTokenCreateInput, FirebaseTokenUncheckedCreateInput>
    /**
     * In case the FirebaseToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FirebaseTokenUpdateInput, FirebaseTokenUncheckedUpdateInput>
  }


  /**
   * FirebaseToken delete
   */
  export type FirebaseTokenDeleteArgs = {
    /**
     * Select specific fields to fetch from the FirebaseToken
     */
    select?: FirebaseTokenSelect | null
    /**
     * Filter which FirebaseToken to delete.
     */
    where: FirebaseTokenWhereUniqueInput
  }


  /**
   * FirebaseToken deleteMany
   */
  export type FirebaseTokenDeleteManyArgs = {
    /**
     * Filter which FirebaseTokens to delete
     */
    where?: FirebaseTokenWhereInput
  }


  /**
   * FirebaseToken without action
   */
  export type FirebaseTokenArgs = {
    /**
     * Select specific fields to fetch from the FirebaseToken
     */
    select?: FirebaseTokenSelect | null
  }



  /**
   * Model WaitListPhoneNumber
   */


  export type AggregateWaitListPhoneNumber = {
    _count: WaitListPhoneNumberCountAggregateOutputType | null
    _min: WaitListPhoneNumberMinAggregateOutputType | null
    _max: WaitListPhoneNumberMaxAggregateOutputType | null
  }

  export type WaitListPhoneNumberMinAggregateOutputType = {
    id: string | null
    phoneNumber: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WaitListPhoneNumberMaxAggregateOutputType = {
    id: string | null
    phoneNumber: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WaitListPhoneNumberCountAggregateOutputType = {
    id: number
    phoneNumber: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WaitListPhoneNumberMinAggregateInputType = {
    id?: true
    phoneNumber?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WaitListPhoneNumberMaxAggregateInputType = {
    id?: true
    phoneNumber?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WaitListPhoneNumberCountAggregateInputType = {
    id?: true
    phoneNumber?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WaitListPhoneNumberAggregateArgs = {
    /**
     * Filter which WaitListPhoneNumber to aggregate.
     */
    where?: WaitListPhoneNumberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WaitListPhoneNumbers to fetch.
     */
    orderBy?: Enumerable<WaitListPhoneNumberOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WaitListPhoneNumberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WaitListPhoneNumbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WaitListPhoneNumbers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WaitListPhoneNumbers
    **/
    _count?: true | WaitListPhoneNumberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WaitListPhoneNumberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WaitListPhoneNumberMaxAggregateInputType
  }

  export type GetWaitListPhoneNumberAggregateType<T extends WaitListPhoneNumberAggregateArgs> = {
        [P in keyof T & keyof AggregateWaitListPhoneNumber]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWaitListPhoneNumber[P]>
      : GetScalarType<T[P], AggregateWaitListPhoneNumber[P]>
  }




  export type WaitListPhoneNumberGroupByArgs = {
    where?: WaitListPhoneNumberWhereInput
    orderBy?: Enumerable<WaitListPhoneNumberOrderByWithAggregationInput>
    by: WaitListPhoneNumberScalarFieldEnum[]
    having?: WaitListPhoneNumberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WaitListPhoneNumberCountAggregateInputType | true
    _min?: WaitListPhoneNumberMinAggregateInputType
    _max?: WaitListPhoneNumberMaxAggregateInputType
  }


  export type WaitListPhoneNumberGroupByOutputType = {
    id: string
    phoneNumber: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: WaitListPhoneNumberCountAggregateOutputType | null
    _min: WaitListPhoneNumberMinAggregateOutputType | null
    _max: WaitListPhoneNumberMaxAggregateOutputType | null
  }

  type GetWaitListPhoneNumberGroupByPayload<T extends WaitListPhoneNumberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<WaitListPhoneNumberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WaitListPhoneNumberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WaitListPhoneNumberGroupByOutputType[P]>
            : GetScalarType<T[P], WaitListPhoneNumberGroupByOutputType[P]>
        }
      >
    >


  export type WaitListPhoneNumberSelect = {
    id?: boolean
    phoneNumber?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type WaitListPhoneNumberGetPayload<S extends boolean | null | undefined | WaitListPhoneNumberArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? WaitListPhoneNumber :
    S extends undefined ? never :
    S extends { include: any } & (WaitListPhoneNumberArgs | WaitListPhoneNumberFindManyArgs)
    ? WaitListPhoneNumber 
    : S extends { select: any } & (WaitListPhoneNumberArgs | WaitListPhoneNumberFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof WaitListPhoneNumber ? WaitListPhoneNumber[P] : never
  } 
      : WaitListPhoneNumber


  type WaitListPhoneNumberCountArgs = 
    Omit<WaitListPhoneNumberFindManyArgs, 'select' | 'include'> & {
      select?: WaitListPhoneNumberCountAggregateInputType | true
    }

  export interface WaitListPhoneNumberDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one WaitListPhoneNumber that matches the filter.
     * @param {WaitListPhoneNumberFindUniqueArgs} args - Arguments to find a WaitListPhoneNumber
     * @example
     * // Get one WaitListPhoneNumber
     * const waitListPhoneNumber = await prisma.waitListPhoneNumber.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WaitListPhoneNumberFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WaitListPhoneNumberFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'WaitListPhoneNumber'> extends True ? Prisma__WaitListPhoneNumberClient<WaitListPhoneNumberGetPayload<T>> : Prisma__WaitListPhoneNumberClient<WaitListPhoneNumberGetPayload<T> | null, null>

    /**
     * Find one WaitListPhoneNumber that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WaitListPhoneNumberFindUniqueOrThrowArgs} args - Arguments to find a WaitListPhoneNumber
     * @example
     * // Get one WaitListPhoneNumber
     * const waitListPhoneNumber = await prisma.waitListPhoneNumber.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WaitListPhoneNumberFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, WaitListPhoneNumberFindUniqueOrThrowArgs>
    ): Prisma__WaitListPhoneNumberClient<WaitListPhoneNumberGetPayload<T>>

    /**
     * Find the first WaitListPhoneNumber that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaitListPhoneNumberFindFirstArgs} args - Arguments to find a WaitListPhoneNumber
     * @example
     * // Get one WaitListPhoneNumber
     * const waitListPhoneNumber = await prisma.waitListPhoneNumber.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WaitListPhoneNumberFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WaitListPhoneNumberFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'WaitListPhoneNumber'> extends True ? Prisma__WaitListPhoneNumberClient<WaitListPhoneNumberGetPayload<T>> : Prisma__WaitListPhoneNumberClient<WaitListPhoneNumberGetPayload<T> | null, null>

    /**
     * Find the first WaitListPhoneNumber that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaitListPhoneNumberFindFirstOrThrowArgs} args - Arguments to find a WaitListPhoneNumber
     * @example
     * // Get one WaitListPhoneNumber
     * const waitListPhoneNumber = await prisma.waitListPhoneNumber.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WaitListPhoneNumberFindFirstOrThrowArgs>(
      args?: SelectSubset<T, WaitListPhoneNumberFindFirstOrThrowArgs>
    ): Prisma__WaitListPhoneNumberClient<WaitListPhoneNumberGetPayload<T>>

    /**
     * Find zero or more WaitListPhoneNumbers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaitListPhoneNumberFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WaitListPhoneNumbers
     * const waitListPhoneNumbers = await prisma.waitListPhoneNumber.findMany()
     * 
     * // Get first 10 WaitListPhoneNumbers
     * const waitListPhoneNumbers = await prisma.waitListPhoneNumber.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const waitListPhoneNumberWithIdOnly = await prisma.waitListPhoneNumber.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WaitListPhoneNumberFindManyArgs>(
      args?: SelectSubset<T, WaitListPhoneNumberFindManyArgs>
    ): Prisma.PrismaPromise<Array<WaitListPhoneNumberGetPayload<T>>>

    /**
     * Create a WaitListPhoneNumber.
     * @param {WaitListPhoneNumberCreateArgs} args - Arguments to create a WaitListPhoneNumber.
     * @example
     * // Create one WaitListPhoneNumber
     * const WaitListPhoneNumber = await prisma.waitListPhoneNumber.create({
     *   data: {
     *     // ... data to create a WaitListPhoneNumber
     *   }
     * })
     * 
    **/
    create<T extends WaitListPhoneNumberCreateArgs>(
      args: SelectSubset<T, WaitListPhoneNumberCreateArgs>
    ): Prisma__WaitListPhoneNumberClient<WaitListPhoneNumberGetPayload<T>>

    /**
     * Create many WaitListPhoneNumbers.
     *     @param {WaitListPhoneNumberCreateManyArgs} args - Arguments to create many WaitListPhoneNumbers.
     *     @example
     *     // Create many WaitListPhoneNumbers
     *     const waitListPhoneNumber = await prisma.waitListPhoneNumber.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WaitListPhoneNumberCreateManyArgs>(
      args?: SelectSubset<T, WaitListPhoneNumberCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WaitListPhoneNumber.
     * @param {WaitListPhoneNumberDeleteArgs} args - Arguments to delete one WaitListPhoneNumber.
     * @example
     * // Delete one WaitListPhoneNumber
     * const WaitListPhoneNumber = await prisma.waitListPhoneNumber.delete({
     *   where: {
     *     // ... filter to delete one WaitListPhoneNumber
     *   }
     * })
     * 
    **/
    delete<T extends WaitListPhoneNumberDeleteArgs>(
      args: SelectSubset<T, WaitListPhoneNumberDeleteArgs>
    ): Prisma__WaitListPhoneNumberClient<WaitListPhoneNumberGetPayload<T>>

    /**
     * Update one WaitListPhoneNumber.
     * @param {WaitListPhoneNumberUpdateArgs} args - Arguments to update one WaitListPhoneNumber.
     * @example
     * // Update one WaitListPhoneNumber
     * const waitListPhoneNumber = await prisma.waitListPhoneNumber.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WaitListPhoneNumberUpdateArgs>(
      args: SelectSubset<T, WaitListPhoneNumberUpdateArgs>
    ): Prisma__WaitListPhoneNumberClient<WaitListPhoneNumberGetPayload<T>>

    /**
     * Delete zero or more WaitListPhoneNumbers.
     * @param {WaitListPhoneNumberDeleteManyArgs} args - Arguments to filter WaitListPhoneNumbers to delete.
     * @example
     * // Delete a few WaitListPhoneNumbers
     * const { count } = await prisma.waitListPhoneNumber.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WaitListPhoneNumberDeleteManyArgs>(
      args?: SelectSubset<T, WaitListPhoneNumberDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WaitListPhoneNumbers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaitListPhoneNumberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WaitListPhoneNumbers
     * const waitListPhoneNumber = await prisma.waitListPhoneNumber.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WaitListPhoneNumberUpdateManyArgs>(
      args: SelectSubset<T, WaitListPhoneNumberUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WaitListPhoneNumber.
     * @param {WaitListPhoneNumberUpsertArgs} args - Arguments to update or create a WaitListPhoneNumber.
     * @example
     * // Update or create a WaitListPhoneNumber
     * const waitListPhoneNumber = await prisma.waitListPhoneNumber.upsert({
     *   create: {
     *     // ... data to create a WaitListPhoneNumber
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WaitListPhoneNumber we want to update
     *   }
     * })
    **/
    upsert<T extends WaitListPhoneNumberUpsertArgs>(
      args: SelectSubset<T, WaitListPhoneNumberUpsertArgs>
    ): Prisma__WaitListPhoneNumberClient<WaitListPhoneNumberGetPayload<T>>

    /**
     * Count the number of WaitListPhoneNumbers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaitListPhoneNumberCountArgs} args - Arguments to filter WaitListPhoneNumbers to count.
     * @example
     * // Count the number of WaitListPhoneNumbers
     * const count = await prisma.waitListPhoneNumber.count({
     *   where: {
     *     // ... the filter for the WaitListPhoneNumbers we want to count
     *   }
     * })
    **/
    count<T extends WaitListPhoneNumberCountArgs>(
      args?: Subset<T, WaitListPhoneNumberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WaitListPhoneNumberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WaitListPhoneNumber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaitListPhoneNumberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WaitListPhoneNumberAggregateArgs>(args: Subset<T, WaitListPhoneNumberAggregateArgs>): Prisma.PrismaPromise<GetWaitListPhoneNumberAggregateType<T>>

    /**
     * Group by WaitListPhoneNumber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaitListPhoneNumberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WaitListPhoneNumberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WaitListPhoneNumberGroupByArgs['orderBy'] }
        : { orderBy?: WaitListPhoneNumberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WaitListPhoneNumberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWaitListPhoneNumberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for WaitListPhoneNumber.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WaitListPhoneNumberClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * WaitListPhoneNumber base type for findUnique actions
   */
  export type WaitListPhoneNumberFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the WaitListPhoneNumber
     */
    select?: WaitListPhoneNumberSelect | null
    /**
     * Filter, which WaitListPhoneNumber to fetch.
     */
    where: WaitListPhoneNumberWhereUniqueInput
  }

  /**
   * WaitListPhoneNumber findUnique
   */
  export interface WaitListPhoneNumberFindUniqueArgs extends WaitListPhoneNumberFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WaitListPhoneNumber findUniqueOrThrow
   */
  export type WaitListPhoneNumberFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the WaitListPhoneNumber
     */
    select?: WaitListPhoneNumberSelect | null
    /**
     * Filter, which WaitListPhoneNumber to fetch.
     */
    where: WaitListPhoneNumberWhereUniqueInput
  }


  /**
   * WaitListPhoneNumber base type for findFirst actions
   */
  export type WaitListPhoneNumberFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the WaitListPhoneNumber
     */
    select?: WaitListPhoneNumberSelect | null
    /**
     * Filter, which WaitListPhoneNumber to fetch.
     */
    where?: WaitListPhoneNumberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WaitListPhoneNumbers to fetch.
     */
    orderBy?: Enumerable<WaitListPhoneNumberOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WaitListPhoneNumbers.
     */
    cursor?: WaitListPhoneNumberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WaitListPhoneNumbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WaitListPhoneNumbers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WaitListPhoneNumbers.
     */
    distinct?: Enumerable<WaitListPhoneNumberScalarFieldEnum>
  }

  /**
   * WaitListPhoneNumber findFirst
   */
  export interface WaitListPhoneNumberFindFirstArgs extends WaitListPhoneNumberFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WaitListPhoneNumber findFirstOrThrow
   */
  export type WaitListPhoneNumberFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the WaitListPhoneNumber
     */
    select?: WaitListPhoneNumberSelect | null
    /**
     * Filter, which WaitListPhoneNumber to fetch.
     */
    where?: WaitListPhoneNumberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WaitListPhoneNumbers to fetch.
     */
    orderBy?: Enumerable<WaitListPhoneNumberOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WaitListPhoneNumbers.
     */
    cursor?: WaitListPhoneNumberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WaitListPhoneNumbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WaitListPhoneNumbers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WaitListPhoneNumbers.
     */
    distinct?: Enumerable<WaitListPhoneNumberScalarFieldEnum>
  }


  /**
   * WaitListPhoneNumber findMany
   */
  export type WaitListPhoneNumberFindManyArgs = {
    /**
     * Select specific fields to fetch from the WaitListPhoneNumber
     */
    select?: WaitListPhoneNumberSelect | null
    /**
     * Filter, which WaitListPhoneNumbers to fetch.
     */
    where?: WaitListPhoneNumberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WaitListPhoneNumbers to fetch.
     */
    orderBy?: Enumerable<WaitListPhoneNumberOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WaitListPhoneNumbers.
     */
    cursor?: WaitListPhoneNumberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WaitListPhoneNumbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WaitListPhoneNumbers.
     */
    skip?: number
    distinct?: Enumerable<WaitListPhoneNumberScalarFieldEnum>
  }


  /**
   * WaitListPhoneNumber create
   */
  export type WaitListPhoneNumberCreateArgs = {
    /**
     * Select specific fields to fetch from the WaitListPhoneNumber
     */
    select?: WaitListPhoneNumberSelect | null
    /**
     * The data needed to create a WaitListPhoneNumber.
     */
    data: XOR<WaitListPhoneNumberCreateInput, WaitListPhoneNumberUncheckedCreateInput>
  }


  /**
   * WaitListPhoneNumber createMany
   */
  export type WaitListPhoneNumberCreateManyArgs = {
    /**
     * The data used to create many WaitListPhoneNumbers.
     */
    data: Enumerable<WaitListPhoneNumberCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * WaitListPhoneNumber update
   */
  export type WaitListPhoneNumberUpdateArgs = {
    /**
     * Select specific fields to fetch from the WaitListPhoneNumber
     */
    select?: WaitListPhoneNumberSelect | null
    /**
     * The data needed to update a WaitListPhoneNumber.
     */
    data: XOR<WaitListPhoneNumberUpdateInput, WaitListPhoneNumberUncheckedUpdateInput>
    /**
     * Choose, which WaitListPhoneNumber to update.
     */
    where: WaitListPhoneNumberWhereUniqueInput
  }


  /**
   * WaitListPhoneNumber updateMany
   */
  export type WaitListPhoneNumberUpdateManyArgs = {
    /**
     * The data used to update WaitListPhoneNumbers.
     */
    data: XOR<WaitListPhoneNumberUpdateManyMutationInput, WaitListPhoneNumberUncheckedUpdateManyInput>
    /**
     * Filter which WaitListPhoneNumbers to update
     */
    where?: WaitListPhoneNumberWhereInput
  }


  /**
   * WaitListPhoneNumber upsert
   */
  export type WaitListPhoneNumberUpsertArgs = {
    /**
     * Select specific fields to fetch from the WaitListPhoneNumber
     */
    select?: WaitListPhoneNumberSelect | null
    /**
     * The filter to search for the WaitListPhoneNumber to update in case it exists.
     */
    where: WaitListPhoneNumberWhereUniqueInput
    /**
     * In case the WaitListPhoneNumber found by the `where` argument doesn't exist, create a new WaitListPhoneNumber with this data.
     */
    create: XOR<WaitListPhoneNumberCreateInput, WaitListPhoneNumberUncheckedCreateInput>
    /**
     * In case the WaitListPhoneNumber was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WaitListPhoneNumberUpdateInput, WaitListPhoneNumberUncheckedUpdateInput>
  }


  /**
   * WaitListPhoneNumber delete
   */
  export type WaitListPhoneNumberDeleteArgs = {
    /**
     * Select specific fields to fetch from the WaitListPhoneNumber
     */
    select?: WaitListPhoneNumberSelect | null
    /**
     * Filter which WaitListPhoneNumber to delete.
     */
    where: WaitListPhoneNumberWhereUniqueInput
  }


  /**
   * WaitListPhoneNumber deleteMany
   */
  export type WaitListPhoneNumberDeleteManyArgs = {
    /**
     * Filter which WaitListPhoneNumbers to delete
     */
    where?: WaitListPhoneNumberWhereInput
  }


  /**
   * WaitListPhoneNumber without action
   */
  export type WaitListPhoneNumberArgs = {
    /**
     * Select specific fields to fetch from the WaitListPhoneNumber
     */
    select?: WaitListPhoneNumberSelect | null
  }



  /**
   * Model Hospital
   */


  export type AggregateHospital = {
    _count: HospitalCountAggregateOutputType | null
    _min: HospitalMinAggregateOutputType | null
    _max: HospitalMaxAggregateOutputType | null
  }

  export type HospitalMinAggregateOutputType = {
    id: string | null
    hospitalLogo: string | null
    subDomain: string | null
    phoneNumber: string | null
    name: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HospitalMaxAggregateOutputType = {
    id: string | null
    hospitalLogo: string | null
    subDomain: string | null
    phoneNumber: string | null
    name: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HospitalCountAggregateOutputType = {
    id: number
    hospitalLogo: number
    subDomain: number
    phoneNumber: number
    name: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HospitalMinAggregateInputType = {
    id?: true
    hospitalLogo?: true
    subDomain?: true
    phoneNumber?: true
    name?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HospitalMaxAggregateInputType = {
    id?: true
    hospitalLogo?: true
    subDomain?: true
    phoneNumber?: true
    name?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HospitalCountAggregateInputType = {
    id?: true
    hospitalLogo?: true
    subDomain?: true
    phoneNumber?: true
    name?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HospitalAggregateArgs = {
    /**
     * Filter which Hospital to aggregate.
     */
    where?: HospitalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hospitals to fetch.
     */
    orderBy?: Enumerable<HospitalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HospitalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hospitals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hospitals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Hospitals
    **/
    _count?: true | HospitalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HospitalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HospitalMaxAggregateInputType
  }

  export type GetHospitalAggregateType<T extends HospitalAggregateArgs> = {
        [P in keyof T & keyof AggregateHospital]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHospital[P]>
      : GetScalarType<T[P], AggregateHospital[P]>
  }




  export type HospitalGroupByArgs = {
    where?: HospitalWhereInput
    orderBy?: Enumerable<HospitalOrderByWithAggregationInput>
    by: HospitalScalarFieldEnum[]
    having?: HospitalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HospitalCountAggregateInputType | true
    _min?: HospitalMinAggregateInputType
    _max?: HospitalMaxAggregateInputType
  }


  export type HospitalGroupByOutputType = {
    id: string
    hospitalLogo: string | null
    subDomain: string | null
    phoneNumber: string
    name: string
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: HospitalCountAggregateOutputType | null
    _min: HospitalMinAggregateOutputType | null
    _max: HospitalMaxAggregateOutputType | null
  }

  type GetHospitalGroupByPayload<T extends HospitalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<HospitalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HospitalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HospitalGroupByOutputType[P]>
            : GetScalarType<T[P], HospitalGroupByOutputType[P]>
        }
      >
    >


  export type HospitalSelect = {
    id?: boolean
    hospitalLogo?: boolean
    subDomain?: boolean
    phoneNumber?: boolean
    name?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | UserArgs
    HospitalUsers?: boolean | Hospital$HospitalUsersArgs
    subscription?: boolean | Hospital$subscriptionArgs
    databaseConnection?: boolean | Hospital$databaseConnectionArgs
    Message?: boolean | Hospital$MessageArgs
    _count?: boolean | HospitalCountOutputTypeArgs
  }


  export type HospitalInclude = {
    User?: boolean | UserArgs
    HospitalUsers?: boolean | Hospital$HospitalUsersArgs
    subscription?: boolean | Hospital$subscriptionArgs
    databaseConnection?: boolean | Hospital$databaseConnectionArgs
    Message?: boolean | Hospital$MessageArgs
    _count?: boolean | HospitalCountOutputTypeArgs
  }

  export type HospitalGetPayload<S extends boolean | null | undefined | HospitalArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Hospital :
    S extends undefined ? never :
    S extends { include: any } & (HospitalArgs | HospitalFindManyArgs)
    ? Hospital  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'User' ? UserGetPayload<S['include'][P]> :
        P extends 'HospitalUsers' ? Array < HospitalUsersGetPayload<S['include'][P]>>  :
        P extends 'subscription' ? Array < SubscriptionGetPayload<S['include'][P]>>  :
        P extends 'databaseConnection' ? Array < DatabaseConnectionGetPayload<S['include'][P]>>  :
        P extends 'Message' ? Array < MessageGetPayload<S['include'][P]>>  :
        P extends '_count' ? HospitalCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (HospitalArgs | HospitalFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'User' ? UserGetPayload<S['select'][P]> :
        P extends 'HospitalUsers' ? Array < HospitalUsersGetPayload<S['select'][P]>>  :
        P extends 'subscription' ? Array < SubscriptionGetPayload<S['select'][P]>>  :
        P extends 'databaseConnection' ? Array < DatabaseConnectionGetPayload<S['select'][P]>>  :
        P extends 'Message' ? Array < MessageGetPayload<S['select'][P]>>  :
        P extends '_count' ? HospitalCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Hospital ? Hospital[P] : never
  } 
      : Hospital


  type HospitalCountArgs = 
    Omit<HospitalFindManyArgs, 'select' | 'include'> & {
      select?: HospitalCountAggregateInputType | true
    }

  export interface HospitalDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Hospital that matches the filter.
     * @param {HospitalFindUniqueArgs} args - Arguments to find a Hospital
     * @example
     * // Get one Hospital
     * const hospital = await prisma.hospital.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends HospitalFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, HospitalFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Hospital'> extends True ? Prisma__HospitalClient<HospitalGetPayload<T>> : Prisma__HospitalClient<HospitalGetPayload<T> | null, null>

    /**
     * Find one Hospital that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {HospitalFindUniqueOrThrowArgs} args - Arguments to find a Hospital
     * @example
     * // Get one Hospital
     * const hospital = await prisma.hospital.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends HospitalFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, HospitalFindUniqueOrThrowArgs>
    ): Prisma__HospitalClient<HospitalGetPayload<T>>

    /**
     * Find the first Hospital that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalFindFirstArgs} args - Arguments to find a Hospital
     * @example
     * // Get one Hospital
     * const hospital = await prisma.hospital.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends HospitalFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, HospitalFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Hospital'> extends True ? Prisma__HospitalClient<HospitalGetPayload<T>> : Prisma__HospitalClient<HospitalGetPayload<T> | null, null>

    /**
     * Find the first Hospital that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalFindFirstOrThrowArgs} args - Arguments to find a Hospital
     * @example
     * // Get one Hospital
     * const hospital = await prisma.hospital.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends HospitalFindFirstOrThrowArgs>(
      args?: SelectSubset<T, HospitalFindFirstOrThrowArgs>
    ): Prisma__HospitalClient<HospitalGetPayload<T>>

    /**
     * Find zero or more Hospitals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hospitals
     * const hospitals = await prisma.hospital.findMany()
     * 
     * // Get first 10 Hospitals
     * const hospitals = await prisma.hospital.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hospitalWithIdOnly = await prisma.hospital.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends HospitalFindManyArgs>(
      args?: SelectSubset<T, HospitalFindManyArgs>
    ): Prisma.PrismaPromise<Array<HospitalGetPayload<T>>>

    /**
     * Create a Hospital.
     * @param {HospitalCreateArgs} args - Arguments to create a Hospital.
     * @example
     * // Create one Hospital
     * const Hospital = await prisma.hospital.create({
     *   data: {
     *     // ... data to create a Hospital
     *   }
     * })
     * 
    **/
    create<T extends HospitalCreateArgs>(
      args: SelectSubset<T, HospitalCreateArgs>
    ): Prisma__HospitalClient<HospitalGetPayload<T>>

    /**
     * Create many Hospitals.
     *     @param {HospitalCreateManyArgs} args - Arguments to create many Hospitals.
     *     @example
     *     // Create many Hospitals
     *     const hospital = await prisma.hospital.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends HospitalCreateManyArgs>(
      args?: SelectSubset<T, HospitalCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Hospital.
     * @param {HospitalDeleteArgs} args - Arguments to delete one Hospital.
     * @example
     * // Delete one Hospital
     * const Hospital = await prisma.hospital.delete({
     *   where: {
     *     // ... filter to delete one Hospital
     *   }
     * })
     * 
    **/
    delete<T extends HospitalDeleteArgs>(
      args: SelectSubset<T, HospitalDeleteArgs>
    ): Prisma__HospitalClient<HospitalGetPayload<T>>

    /**
     * Update one Hospital.
     * @param {HospitalUpdateArgs} args - Arguments to update one Hospital.
     * @example
     * // Update one Hospital
     * const hospital = await prisma.hospital.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends HospitalUpdateArgs>(
      args: SelectSubset<T, HospitalUpdateArgs>
    ): Prisma__HospitalClient<HospitalGetPayload<T>>

    /**
     * Delete zero or more Hospitals.
     * @param {HospitalDeleteManyArgs} args - Arguments to filter Hospitals to delete.
     * @example
     * // Delete a few Hospitals
     * const { count } = await prisma.hospital.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends HospitalDeleteManyArgs>(
      args?: SelectSubset<T, HospitalDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hospitals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hospitals
     * const hospital = await prisma.hospital.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends HospitalUpdateManyArgs>(
      args: SelectSubset<T, HospitalUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Hospital.
     * @param {HospitalUpsertArgs} args - Arguments to update or create a Hospital.
     * @example
     * // Update or create a Hospital
     * const hospital = await prisma.hospital.upsert({
     *   create: {
     *     // ... data to create a Hospital
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hospital we want to update
     *   }
     * })
    **/
    upsert<T extends HospitalUpsertArgs>(
      args: SelectSubset<T, HospitalUpsertArgs>
    ): Prisma__HospitalClient<HospitalGetPayload<T>>

    /**
     * Count the number of Hospitals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalCountArgs} args - Arguments to filter Hospitals to count.
     * @example
     * // Count the number of Hospitals
     * const count = await prisma.hospital.count({
     *   where: {
     *     // ... the filter for the Hospitals we want to count
     *   }
     * })
    **/
    count<T extends HospitalCountArgs>(
      args?: Subset<T, HospitalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HospitalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hospital.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HospitalAggregateArgs>(args: Subset<T, HospitalAggregateArgs>): Prisma.PrismaPromise<GetHospitalAggregateType<T>>

    /**
     * Group by Hospital.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HospitalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HospitalGroupByArgs['orderBy'] }
        : { orderBy?: HospitalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HospitalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHospitalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Hospital.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__HospitalClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    User<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    HospitalUsers<T extends Hospital$HospitalUsersArgs= {}>(args?: Subset<T, Hospital$HospitalUsersArgs>): Prisma.PrismaPromise<Array<HospitalUsersGetPayload<T>>| Null>;

    subscription<T extends Hospital$subscriptionArgs= {}>(args?: Subset<T, Hospital$subscriptionArgs>): Prisma.PrismaPromise<Array<SubscriptionGetPayload<T>>| Null>;

    databaseConnection<T extends Hospital$databaseConnectionArgs= {}>(args?: Subset<T, Hospital$databaseConnectionArgs>): Prisma.PrismaPromise<Array<DatabaseConnectionGetPayload<T>>| Null>;

    Message<T extends Hospital$MessageArgs= {}>(args?: Subset<T, Hospital$MessageArgs>): Prisma.PrismaPromise<Array<MessageGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Hospital base type for findUnique actions
   */
  export type HospitalFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HospitalInclude | null
    /**
     * Filter, which Hospital to fetch.
     */
    where: HospitalWhereUniqueInput
  }

  /**
   * Hospital findUnique
   */
  export interface HospitalFindUniqueArgs extends HospitalFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Hospital findUniqueOrThrow
   */
  export type HospitalFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HospitalInclude | null
    /**
     * Filter, which Hospital to fetch.
     */
    where: HospitalWhereUniqueInput
  }


  /**
   * Hospital base type for findFirst actions
   */
  export type HospitalFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HospitalInclude | null
    /**
     * Filter, which Hospital to fetch.
     */
    where?: HospitalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hospitals to fetch.
     */
    orderBy?: Enumerable<HospitalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hospitals.
     */
    cursor?: HospitalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hospitals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hospitals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hospitals.
     */
    distinct?: Enumerable<HospitalScalarFieldEnum>
  }

  /**
   * Hospital findFirst
   */
  export interface HospitalFindFirstArgs extends HospitalFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Hospital findFirstOrThrow
   */
  export type HospitalFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HospitalInclude | null
    /**
     * Filter, which Hospital to fetch.
     */
    where?: HospitalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hospitals to fetch.
     */
    orderBy?: Enumerable<HospitalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hospitals.
     */
    cursor?: HospitalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hospitals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hospitals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hospitals.
     */
    distinct?: Enumerable<HospitalScalarFieldEnum>
  }


  /**
   * Hospital findMany
   */
  export type HospitalFindManyArgs = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HospitalInclude | null
    /**
     * Filter, which Hospitals to fetch.
     */
    where?: HospitalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hospitals to fetch.
     */
    orderBy?: Enumerable<HospitalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Hospitals.
     */
    cursor?: HospitalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hospitals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hospitals.
     */
    skip?: number
    distinct?: Enumerable<HospitalScalarFieldEnum>
  }


  /**
   * Hospital create
   */
  export type HospitalCreateArgs = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HospitalInclude | null
    /**
     * The data needed to create a Hospital.
     */
    data: XOR<HospitalCreateInput, HospitalUncheckedCreateInput>
  }


  /**
   * Hospital createMany
   */
  export type HospitalCreateManyArgs = {
    /**
     * The data used to create many Hospitals.
     */
    data: Enumerable<HospitalCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Hospital update
   */
  export type HospitalUpdateArgs = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HospitalInclude | null
    /**
     * The data needed to update a Hospital.
     */
    data: XOR<HospitalUpdateInput, HospitalUncheckedUpdateInput>
    /**
     * Choose, which Hospital to update.
     */
    where: HospitalWhereUniqueInput
  }


  /**
   * Hospital updateMany
   */
  export type HospitalUpdateManyArgs = {
    /**
     * The data used to update Hospitals.
     */
    data: XOR<HospitalUpdateManyMutationInput, HospitalUncheckedUpdateManyInput>
    /**
     * Filter which Hospitals to update
     */
    where?: HospitalWhereInput
  }


  /**
   * Hospital upsert
   */
  export type HospitalUpsertArgs = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HospitalInclude | null
    /**
     * The filter to search for the Hospital to update in case it exists.
     */
    where: HospitalWhereUniqueInput
    /**
     * In case the Hospital found by the `where` argument doesn't exist, create a new Hospital with this data.
     */
    create: XOR<HospitalCreateInput, HospitalUncheckedCreateInput>
    /**
     * In case the Hospital was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HospitalUpdateInput, HospitalUncheckedUpdateInput>
  }


  /**
   * Hospital delete
   */
  export type HospitalDeleteArgs = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HospitalInclude | null
    /**
     * Filter which Hospital to delete.
     */
    where: HospitalWhereUniqueInput
  }


  /**
   * Hospital deleteMany
   */
  export type HospitalDeleteManyArgs = {
    /**
     * Filter which Hospitals to delete
     */
    where?: HospitalWhereInput
  }


  /**
   * Hospital.HospitalUsers
   */
  export type Hospital$HospitalUsersArgs = {
    /**
     * Select specific fields to fetch from the HospitalUsers
     */
    select?: HospitalUsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HospitalUsersInclude | null
    where?: HospitalUsersWhereInput
    orderBy?: Enumerable<HospitalUsersOrderByWithRelationInput>
    cursor?: HospitalUsersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<HospitalUsersScalarFieldEnum>
  }


  /**
   * Hospital.subscription
   */
  export type Hospital$subscriptionArgs = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude | null
    where?: SubscriptionWhereInput
    orderBy?: Enumerable<SubscriptionOrderByWithRelationInput>
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SubscriptionScalarFieldEnum>
  }


  /**
   * Hospital.databaseConnection
   */
  export type Hospital$databaseConnectionArgs = {
    /**
     * Select specific fields to fetch from the DatabaseConnection
     */
    select?: DatabaseConnectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DatabaseConnectionInclude | null
    where?: DatabaseConnectionWhereInput
    orderBy?: Enumerable<DatabaseConnectionOrderByWithRelationInput>
    cursor?: DatabaseConnectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DatabaseConnectionScalarFieldEnum>
  }


  /**
   * Hospital.Message
   */
  export type Hospital$MessageArgs = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude | null
    where?: MessageWhereInput
    orderBy?: Enumerable<MessageOrderByWithRelationInput>
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MessageScalarFieldEnum>
  }


  /**
   * Hospital without action
   */
  export type HospitalArgs = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HospitalInclude | null
  }



  /**
   * Model Subscription
   */


  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionAvgAggregateOutputType = {
    id: number | null
    totalDays: number | null
  }

  export type SubscriptionSumAggregateOutputType = {
    id: number | null
    totalDays: number | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: number | null
    startDate: Date | null
    endDate: Date | null
    totalDays: number | null
    isStart: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    hospitalId: string | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: number | null
    startDate: Date | null
    endDate: Date | null
    totalDays: number | null
    isStart: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    hospitalId: string | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    startDate: number
    endDate: number
    totalDays: number
    isStart: number
    createdAt: number
    updatedAt: number
    hospitalId: number
    _all: number
  }


  export type SubscriptionAvgAggregateInputType = {
    id?: true
    totalDays?: true
  }

  export type SubscriptionSumAggregateInputType = {
    id?: true
    totalDays?: true
  }

  export type SubscriptionMinAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    totalDays?: true
    isStart?: true
    createdAt?: true
    updatedAt?: true
    hospitalId?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    totalDays?: true
    isStart?: true
    createdAt?: true
    updatedAt?: true
    hospitalId?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    totalDays?: true
    isStart?: true
    createdAt?: true
    updatedAt?: true
    hospitalId?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: Enumerable<SubscriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs = {
    where?: SubscriptionWhereInput
    orderBy?: Enumerable<SubscriptionOrderByWithAggregationInput>
    by: SubscriptionScalarFieldEnum[]
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _avg?: SubscriptionAvgAggregateInputType
    _sum?: SubscriptionSumAggregateInputType
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }


  export type SubscriptionGroupByOutputType = {
    id: number
    startDate: Date | null
    endDate: Date | null
    totalDays: number
    isStart: boolean
    createdAt: Date
    updatedAt: Date
    hospitalId: string | null
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect = {
    id?: boolean
    startDate?: boolean
    endDate?: boolean
    totalDays?: boolean
    isStart?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hospitalId?: boolean
    machines?: boolean | Subscription$machinesArgs
    Hospital?: boolean | HospitalArgs
    _count?: boolean | SubscriptionCountOutputTypeArgs
  }


  export type SubscriptionInclude = {
    machines?: boolean | Subscription$machinesArgs
    Hospital?: boolean | HospitalArgs
    _count?: boolean | SubscriptionCountOutputTypeArgs
  }

  export type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Subscription :
    S extends undefined ? never :
    S extends { include: any } & (SubscriptionArgs | SubscriptionFindManyArgs)
    ? Subscription  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'machines' ? Array < MachineGetPayload<S['include'][P]>>  :
        P extends 'Hospital' ? HospitalGetPayload<S['include'][P]> | null :
        P extends '_count' ? SubscriptionCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (SubscriptionArgs | SubscriptionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'machines' ? Array < MachineGetPayload<S['select'][P]>>  :
        P extends 'Hospital' ? HospitalGetPayload<S['select'][P]> | null :
        P extends '_count' ? SubscriptionCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Subscription ? Subscription[P] : never
  } 
      : Subscription


  type SubscriptionCountArgs = 
    Omit<SubscriptionFindManyArgs, 'select' | 'include'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SubscriptionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SubscriptionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Subscription'> extends True ? Prisma__SubscriptionClient<SubscriptionGetPayload<T>> : Prisma__SubscriptionClient<SubscriptionGetPayload<T> | null, null>

    /**
     * Find one Subscription that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs>
    ): Prisma__SubscriptionClient<SubscriptionGetPayload<T>>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SubscriptionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SubscriptionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Subscription'> extends True ? Prisma__SubscriptionClient<SubscriptionGetPayload<T>> : Prisma__SubscriptionClient<SubscriptionGetPayload<T> | null, null>

    /**
     * Find the first Subscription that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs>
    ): Prisma__SubscriptionClient<SubscriptionGetPayload<T>>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SubscriptionFindManyArgs>(
      args?: SelectSubset<T, SubscriptionFindManyArgs>
    ): Prisma.PrismaPromise<Array<SubscriptionGetPayload<T>>>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
    **/
    create<T extends SubscriptionCreateArgs>(
      args: SelectSubset<T, SubscriptionCreateArgs>
    ): Prisma__SubscriptionClient<SubscriptionGetPayload<T>>

    /**
     * Create many Subscriptions.
     *     @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     *     @example
     *     // Create many Subscriptions
     *     const subscription = await prisma.subscription.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SubscriptionCreateManyArgs>(
      args?: SelectSubset<T, SubscriptionCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
    **/
    delete<T extends SubscriptionDeleteArgs>(
      args: SelectSubset<T, SubscriptionDeleteArgs>
    ): Prisma__SubscriptionClient<SubscriptionGetPayload<T>>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SubscriptionUpdateArgs>(
      args: SelectSubset<T, SubscriptionUpdateArgs>
    ): Prisma__SubscriptionClient<SubscriptionGetPayload<T>>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SubscriptionDeleteManyArgs>(
      args?: SelectSubset<T, SubscriptionDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SubscriptionUpdateManyArgs>(
      args: SelectSubset<T, SubscriptionUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
    **/
    upsert<T extends SubscriptionUpsertArgs>(
      args: SelectSubset<T, SubscriptionUpsertArgs>
    ): Prisma__SubscriptionClient<SubscriptionGetPayload<T>>

    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SubscriptionClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    machines<T extends Subscription$machinesArgs= {}>(args?: Subset<T, Subscription$machinesArgs>): Prisma.PrismaPromise<Array<MachineGetPayload<T>>| Null>;

    Hospital<T extends HospitalArgs= {}>(args?: Subset<T, HospitalArgs>): Prisma__HospitalClient<HospitalGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Subscription base type for findUnique actions
   */
  export type SubscriptionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUnique
   */
  export interface SubscriptionFindUniqueArgs extends SubscriptionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }


  /**
   * Subscription base type for findFirst actions
   */
  export type SubscriptionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: Enumerable<SubscriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: Enumerable<SubscriptionScalarFieldEnum>
  }

  /**
   * Subscription findFirst
   */
  export interface SubscriptionFindFirstArgs extends SubscriptionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: Enumerable<SubscriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: Enumerable<SubscriptionScalarFieldEnum>
  }


  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: Enumerable<SubscriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: Enumerable<SubscriptionScalarFieldEnum>
  }


  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }


  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs = {
    /**
     * The data used to create many Subscriptions.
     */
    data: Enumerable<SubscriptionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }


  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
  }


  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }


  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }


  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
  }


  /**
   * Subscription.machines
   */
  export type Subscription$machinesArgs = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MachineInclude | null
    where?: MachineWhereInput
    orderBy?: Enumerable<MachineOrderByWithRelationInput>
    cursor?: MachineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MachineScalarFieldEnum>
  }


  /**
   * Subscription without action
   */
  export type SubscriptionArgs = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude | null
  }



  /**
   * Model Machine
   */


  export type AggregateMachine = {
    _count: MachineCountAggregateOutputType | null
    _avg: MachineAvgAggregateOutputType | null
    _sum: MachineSumAggregateOutputType | null
    _min: MachineMinAggregateOutputType | null
    _max: MachineMaxAggregateOutputType | null
  }

  export type MachineAvgAggregateOutputType = {
    id: number | null
    subscriptionId: number | null
  }

  export type MachineSumAggregateOutputType = {
    id: number | null
    subscriptionId: number | null
  }

  export type MachineMinAggregateOutputType = {
    id: number | null
    subscriptionId: number | null
    machineName: string | null
    machineUniqueId: string | null
    registeredAt: Date | null
  }

  export type MachineMaxAggregateOutputType = {
    id: number | null
    subscriptionId: number | null
    machineName: string | null
    machineUniqueId: string | null
    registeredAt: Date | null
  }

  export type MachineCountAggregateOutputType = {
    id: number
    subscriptionId: number
    machineName: number
    machineUniqueId: number
    registeredAt: number
    _all: number
  }


  export type MachineAvgAggregateInputType = {
    id?: true
    subscriptionId?: true
  }

  export type MachineSumAggregateInputType = {
    id?: true
    subscriptionId?: true
  }

  export type MachineMinAggregateInputType = {
    id?: true
    subscriptionId?: true
    machineName?: true
    machineUniqueId?: true
    registeredAt?: true
  }

  export type MachineMaxAggregateInputType = {
    id?: true
    subscriptionId?: true
    machineName?: true
    machineUniqueId?: true
    registeredAt?: true
  }

  export type MachineCountAggregateInputType = {
    id?: true
    subscriptionId?: true
    machineName?: true
    machineUniqueId?: true
    registeredAt?: true
    _all?: true
  }

  export type MachineAggregateArgs = {
    /**
     * Filter which Machine to aggregate.
     */
    where?: MachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Machines to fetch.
     */
    orderBy?: Enumerable<MachineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Machines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Machines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Machines
    **/
    _count?: true | MachineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MachineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MachineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MachineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MachineMaxAggregateInputType
  }

  export type GetMachineAggregateType<T extends MachineAggregateArgs> = {
        [P in keyof T & keyof AggregateMachine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMachine[P]>
      : GetScalarType<T[P], AggregateMachine[P]>
  }




  export type MachineGroupByArgs = {
    where?: MachineWhereInput
    orderBy?: Enumerable<MachineOrderByWithAggregationInput>
    by: MachineScalarFieldEnum[]
    having?: MachineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MachineCountAggregateInputType | true
    _avg?: MachineAvgAggregateInputType
    _sum?: MachineSumAggregateInputType
    _min?: MachineMinAggregateInputType
    _max?: MachineMaxAggregateInputType
  }


  export type MachineGroupByOutputType = {
    id: number
    subscriptionId: number
    machineName: string
    machineUniqueId: string
    registeredAt: Date
    _count: MachineCountAggregateOutputType | null
    _avg: MachineAvgAggregateOutputType | null
    _sum: MachineSumAggregateOutputType | null
    _min: MachineMinAggregateOutputType | null
    _max: MachineMaxAggregateOutputType | null
  }

  type GetMachineGroupByPayload<T extends MachineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MachineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MachineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MachineGroupByOutputType[P]>
            : GetScalarType<T[P], MachineGroupByOutputType[P]>
        }
      >
    >


  export type MachineSelect = {
    id?: boolean
    subscriptionId?: boolean
    machineName?: boolean
    machineUniqueId?: boolean
    registeredAt?: boolean
    subscription?: boolean | SubscriptionArgs
  }


  export type MachineInclude = {
    subscription?: boolean | SubscriptionArgs
  }

  export type MachineGetPayload<S extends boolean | null | undefined | MachineArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Machine :
    S extends undefined ? never :
    S extends { include: any } & (MachineArgs | MachineFindManyArgs)
    ? Machine  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'subscription' ? SubscriptionGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (MachineArgs | MachineFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'subscription' ? SubscriptionGetPayload<S['select'][P]> :  P extends keyof Machine ? Machine[P] : never
  } 
      : Machine


  type MachineCountArgs = 
    Omit<MachineFindManyArgs, 'select' | 'include'> & {
      select?: MachineCountAggregateInputType | true
    }

  export interface MachineDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Machine that matches the filter.
     * @param {MachineFindUniqueArgs} args - Arguments to find a Machine
     * @example
     * // Get one Machine
     * const machine = await prisma.machine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MachineFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MachineFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Machine'> extends True ? Prisma__MachineClient<MachineGetPayload<T>> : Prisma__MachineClient<MachineGetPayload<T> | null, null>

    /**
     * Find one Machine that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MachineFindUniqueOrThrowArgs} args - Arguments to find a Machine
     * @example
     * // Get one Machine
     * const machine = await prisma.machine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MachineFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MachineFindUniqueOrThrowArgs>
    ): Prisma__MachineClient<MachineGetPayload<T>>

    /**
     * Find the first Machine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineFindFirstArgs} args - Arguments to find a Machine
     * @example
     * // Get one Machine
     * const machine = await prisma.machine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MachineFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MachineFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Machine'> extends True ? Prisma__MachineClient<MachineGetPayload<T>> : Prisma__MachineClient<MachineGetPayload<T> | null, null>

    /**
     * Find the first Machine that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineFindFirstOrThrowArgs} args - Arguments to find a Machine
     * @example
     * // Get one Machine
     * const machine = await prisma.machine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MachineFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MachineFindFirstOrThrowArgs>
    ): Prisma__MachineClient<MachineGetPayload<T>>

    /**
     * Find zero or more Machines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Machines
     * const machines = await prisma.machine.findMany()
     * 
     * // Get first 10 Machines
     * const machines = await prisma.machine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const machineWithIdOnly = await prisma.machine.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MachineFindManyArgs>(
      args?: SelectSubset<T, MachineFindManyArgs>
    ): Prisma.PrismaPromise<Array<MachineGetPayload<T>>>

    /**
     * Create a Machine.
     * @param {MachineCreateArgs} args - Arguments to create a Machine.
     * @example
     * // Create one Machine
     * const Machine = await prisma.machine.create({
     *   data: {
     *     // ... data to create a Machine
     *   }
     * })
     * 
    **/
    create<T extends MachineCreateArgs>(
      args: SelectSubset<T, MachineCreateArgs>
    ): Prisma__MachineClient<MachineGetPayload<T>>

    /**
     * Create many Machines.
     *     @param {MachineCreateManyArgs} args - Arguments to create many Machines.
     *     @example
     *     // Create many Machines
     *     const machine = await prisma.machine.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MachineCreateManyArgs>(
      args?: SelectSubset<T, MachineCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Machine.
     * @param {MachineDeleteArgs} args - Arguments to delete one Machine.
     * @example
     * // Delete one Machine
     * const Machine = await prisma.machine.delete({
     *   where: {
     *     // ... filter to delete one Machine
     *   }
     * })
     * 
    **/
    delete<T extends MachineDeleteArgs>(
      args: SelectSubset<T, MachineDeleteArgs>
    ): Prisma__MachineClient<MachineGetPayload<T>>

    /**
     * Update one Machine.
     * @param {MachineUpdateArgs} args - Arguments to update one Machine.
     * @example
     * // Update one Machine
     * const machine = await prisma.machine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MachineUpdateArgs>(
      args: SelectSubset<T, MachineUpdateArgs>
    ): Prisma__MachineClient<MachineGetPayload<T>>

    /**
     * Delete zero or more Machines.
     * @param {MachineDeleteManyArgs} args - Arguments to filter Machines to delete.
     * @example
     * // Delete a few Machines
     * const { count } = await prisma.machine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MachineDeleteManyArgs>(
      args?: SelectSubset<T, MachineDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Machines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Machines
     * const machine = await prisma.machine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MachineUpdateManyArgs>(
      args: SelectSubset<T, MachineUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Machine.
     * @param {MachineUpsertArgs} args - Arguments to update or create a Machine.
     * @example
     * // Update or create a Machine
     * const machine = await prisma.machine.upsert({
     *   create: {
     *     // ... data to create a Machine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Machine we want to update
     *   }
     * })
    **/
    upsert<T extends MachineUpsertArgs>(
      args: SelectSubset<T, MachineUpsertArgs>
    ): Prisma__MachineClient<MachineGetPayload<T>>

    /**
     * Count the number of Machines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineCountArgs} args - Arguments to filter Machines to count.
     * @example
     * // Count the number of Machines
     * const count = await prisma.machine.count({
     *   where: {
     *     // ... the filter for the Machines we want to count
     *   }
     * })
    **/
    count<T extends MachineCountArgs>(
      args?: Subset<T, MachineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MachineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Machine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MachineAggregateArgs>(args: Subset<T, MachineAggregateArgs>): Prisma.PrismaPromise<GetMachineAggregateType<T>>

    /**
     * Group by Machine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MachineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MachineGroupByArgs['orderBy'] }
        : { orderBy?: MachineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MachineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMachineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Machine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MachineClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    subscription<T extends SubscriptionArgs= {}>(args?: Subset<T, SubscriptionArgs>): Prisma__SubscriptionClient<SubscriptionGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Machine base type for findUnique actions
   */
  export type MachineFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MachineInclude | null
    /**
     * Filter, which Machine to fetch.
     */
    where: MachineWhereUniqueInput
  }

  /**
   * Machine findUnique
   */
  export interface MachineFindUniqueArgs extends MachineFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Machine findUniqueOrThrow
   */
  export type MachineFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MachineInclude | null
    /**
     * Filter, which Machine to fetch.
     */
    where: MachineWhereUniqueInput
  }


  /**
   * Machine base type for findFirst actions
   */
  export type MachineFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MachineInclude | null
    /**
     * Filter, which Machine to fetch.
     */
    where?: MachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Machines to fetch.
     */
    orderBy?: Enumerable<MachineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Machines.
     */
    cursor?: MachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Machines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Machines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Machines.
     */
    distinct?: Enumerable<MachineScalarFieldEnum>
  }

  /**
   * Machine findFirst
   */
  export interface MachineFindFirstArgs extends MachineFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Machine findFirstOrThrow
   */
  export type MachineFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MachineInclude | null
    /**
     * Filter, which Machine to fetch.
     */
    where?: MachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Machines to fetch.
     */
    orderBy?: Enumerable<MachineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Machines.
     */
    cursor?: MachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Machines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Machines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Machines.
     */
    distinct?: Enumerable<MachineScalarFieldEnum>
  }


  /**
   * Machine findMany
   */
  export type MachineFindManyArgs = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MachineInclude | null
    /**
     * Filter, which Machines to fetch.
     */
    where?: MachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Machines to fetch.
     */
    orderBy?: Enumerable<MachineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Machines.
     */
    cursor?: MachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Machines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Machines.
     */
    skip?: number
    distinct?: Enumerable<MachineScalarFieldEnum>
  }


  /**
   * Machine create
   */
  export type MachineCreateArgs = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MachineInclude | null
    /**
     * The data needed to create a Machine.
     */
    data: XOR<MachineCreateInput, MachineUncheckedCreateInput>
  }


  /**
   * Machine createMany
   */
  export type MachineCreateManyArgs = {
    /**
     * The data used to create many Machines.
     */
    data: Enumerable<MachineCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Machine update
   */
  export type MachineUpdateArgs = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MachineInclude | null
    /**
     * The data needed to update a Machine.
     */
    data: XOR<MachineUpdateInput, MachineUncheckedUpdateInput>
    /**
     * Choose, which Machine to update.
     */
    where: MachineWhereUniqueInput
  }


  /**
   * Machine updateMany
   */
  export type MachineUpdateManyArgs = {
    /**
     * The data used to update Machines.
     */
    data: XOR<MachineUpdateManyMutationInput, MachineUncheckedUpdateManyInput>
    /**
     * Filter which Machines to update
     */
    where?: MachineWhereInput
  }


  /**
   * Machine upsert
   */
  export type MachineUpsertArgs = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MachineInclude | null
    /**
     * The filter to search for the Machine to update in case it exists.
     */
    where: MachineWhereUniqueInput
    /**
     * In case the Machine found by the `where` argument doesn't exist, create a new Machine with this data.
     */
    create: XOR<MachineCreateInput, MachineUncheckedCreateInput>
    /**
     * In case the Machine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MachineUpdateInput, MachineUncheckedUpdateInput>
  }


  /**
   * Machine delete
   */
  export type MachineDeleteArgs = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MachineInclude | null
    /**
     * Filter which Machine to delete.
     */
    where: MachineWhereUniqueInput
  }


  /**
   * Machine deleteMany
   */
  export type MachineDeleteManyArgs = {
    /**
     * Filter which Machines to delete
     */
    where?: MachineWhereInput
  }


  /**
   * Machine without action
   */
  export type MachineArgs = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MachineInclude | null
  }



  /**
   * Model HospitalUsers
   */


  export type AggregateHospitalUsers = {
    _count: HospitalUsersCountAggregateOutputType | null
    _avg: HospitalUsersAvgAggregateOutputType | null
    _sum: HospitalUsersSumAggregateOutputType | null
    _min: HospitalUsersMinAggregateOutputType | null
    _max: HospitalUsersMaxAggregateOutputType | null
  }

  export type HospitalUsersAvgAggregateOutputType = {
    id: number | null
  }

  export type HospitalUsersSumAggregateOutputType = {
    id: number | null
  }

  export type HospitalUsersMinAggregateOutputType = {
    id: number | null
    hospitalId: string | null
    phoneNumber: string | null
    userName: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HospitalUsersMaxAggregateOutputType = {
    id: number | null
    hospitalId: string | null
    phoneNumber: string | null
    userName: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HospitalUsersCountAggregateOutputType = {
    id: number
    hospitalId: number
    phoneNumber: number
    userName: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HospitalUsersAvgAggregateInputType = {
    id?: true
  }

  export type HospitalUsersSumAggregateInputType = {
    id?: true
  }

  export type HospitalUsersMinAggregateInputType = {
    id?: true
    hospitalId?: true
    phoneNumber?: true
    userName?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HospitalUsersMaxAggregateInputType = {
    id?: true
    hospitalId?: true
    phoneNumber?: true
    userName?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HospitalUsersCountAggregateInputType = {
    id?: true
    hospitalId?: true
    phoneNumber?: true
    userName?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HospitalUsersAggregateArgs = {
    /**
     * Filter which HospitalUsers to aggregate.
     */
    where?: HospitalUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HospitalUsers to fetch.
     */
    orderBy?: Enumerable<HospitalUsersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HospitalUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HospitalUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HospitalUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HospitalUsers
    **/
    _count?: true | HospitalUsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HospitalUsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HospitalUsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HospitalUsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HospitalUsersMaxAggregateInputType
  }

  export type GetHospitalUsersAggregateType<T extends HospitalUsersAggregateArgs> = {
        [P in keyof T & keyof AggregateHospitalUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHospitalUsers[P]>
      : GetScalarType<T[P], AggregateHospitalUsers[P]>
  }




  export type HospitalUsersGroupByArgs = {
    where?: HospitalUsersWhereInput
    orderBy?: Enumerable<HospitalUsersOrderByWithAggregationInput>
    by: HospitalUsersScalarFieldEnum[]
    having?: HospitalUsersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HospitalUsersCountAggregateInputType | true
    _avg?: HospitalUsersAvgAggregateInputType
    _sum?: HospitalUsersSumAggregateInputType
    _min?: HospitalUsersMinAggregateInputType
    _max?: HospitalUsersMaxAggregateInputType
  }


  export type HospitalUsersGroupByOutputType = {
    id: number
    hospitalId: string
    phoneNumber: string | null
    userName: string
    role: string | null
    createdAt: Date
    updatedAt: Date
    _count: HospitalUsersCountAggregateOutputType | null
    _avg: HospitalUsersAvgAggregateOutputType | null
    _sum: HospitalUsersSumAggregateOutputType | null
    _min: HospitalUsersMinAggregateOutputType | null
    _max: HospitalUsersMaxAggregateOutputType | null
  }

  type GetHospitalUsersGroupByPayload<T extends HospitalUsersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<HospitalUsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HospitalUsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HospitalUsersGroupByOutputType[P]>
            : GetScalarType<T[P], HospitalUsersGroupByOutputType[P]>
        }
      >
    >


  export type HospitalUsersSelect = {
    id?: boolean
    hospitalId?: boolean
    phoneNumber?: boolean
    userName?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hospital?: boolean | HospitalArgs
  }


  export type HospitalUsersInclude = {
    hospital?: boolean | HospitalArgs
  }

  export type HospitalUsersGetPayload<S extends boolean | null | undefined | HospitalUsersArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? HospitalUsers :
    S extends undefined ? never :
    S extends { include: any } & (HospitalUsersArgs | HospitalUsersFindManyArgs)
    ? HospitalUsers  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'hospital' ? HospitalGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (HospitalUsersArgs | HospitalUsersFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'hospital' ? HospitalGetPayload<S['select'][P]> :  P extends keyof HospitalUsers ? HospitalUsers[P] : never
  } 
      : HospitalUsers


  type HospitalUsersCountArgs = 
    Omit<HospitalUsersFindManyArgs, 'select' | 'include'> & {
      select?: HospitalUsersCountAggregateInputType | true
    }

  export interface HospitalUsersDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one HospitalUsers that matches the filter.
     * @param {HospitalUsersFindUniqueArgs} args - Arguments to find a HospitalUsers
     * @example
     * // Get one HospitalUsers
     * const hospitalUsers = await prisma.hospitalUsers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends HospitalUsersFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, HospitalUsersFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'HospitalUsers'> extends True ? Prisma__HospitalUsersClient<HospitalUsersGetPayload<T>> : Prisma__HospitalUsersClient<HospitalUsersGetPayload<T> | null, null>

    /**
     * Find one HospitalUsers that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {HospitalUsersFindUniqueOrThrowArgs} args - Arguments to find a HospitalUsers
     * @example
     * // Get one HospitalUsers
     * const hospitalUsers = await prisma.hospitalUsers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends HospitalUsersFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, HospitalUsersFindUniqueOrThrowArgs>
    ): Prisma__HospitalUsersClient<HospitalUsersGetPayload<T>>

    /**
     * Find the first HospitalUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalUsersFindFirstArgs} args - Arguments to find a HospitalUsers
     * @example
     * // Get one HospitalUsers
     * const hospitalUsers = await prisma.hospitalUsers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends HospitalUsersFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, HospitalUsersFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'HospitalUsers'> extends True ? Prisma__HospitalUsersClient<HospitalUsersGetPayload<T>> : Prisma__HospitalUsersClient<HospitalUsersGetPayload<T> | null, null>

    /**
     * Find the first HospitalUsers that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalUsersFindFirstOrThrowArgs} args - Arguments to find a HospitalUsers
     * @example
     * // Get one HospitalUsers
     * const hospitalUsers = await prisma.hospitalUsers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends HospitalUsersFindFirstOrThrowArgs>(
      args?: SelectSubset<T, HospitalUsersFindFirstOrThrowArgs>
    ): Prisma__HospitalUsersClient<HospitalUsersGetPayload<T>>

    /**
     * Find zero or more HospitalUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalUsersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HospitalUsers
     * const hospitalUsers = await prisma.hospitalUsers.findMany()
     * 
     * // Get first 10 HospitalUsers
     * const hospitalUsers = await prisma.hospitalUsers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hospitalUsersWithIdOnly = await prisma.hospitalUsers.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends HospitalUsersFindManyArgs>(
      args?: SelectSubset<T, HospitalUsersFindManyArgs>
    ): Prisma.PrismaPromise<Array<HospitalUsersGetPayload<T>>>

    /**
     * Create a HospitalUsers.
     * @param {HospitalUsersCreateArgs} args - Arguments to create a HospitalUsers.
     * @example
     * // Create one HospitalUsers
     * const HospitalUsers = await prisma.hospitalUsers.create({
     *   data: {
     *     // ... data to create a HospitalUsers
     *   }
     * })
     * 
    **/
    create<T extends HospitalUsersCreateArgs>(
      args: SelectSubset<T, HospitalUsersCreateArgs>
    ): Prisma__HospitalUsersClient<HospitalUsersGetPayload<T>>

    /**
     * Create many HospitalUsers.
     *     @param {HospitalUsersCreateManyArgs} args - Arguments to create many HospitalUsers.
     *     @example
     *     // Create many HospitalUsers
     *     const hospitalUsers = await prisma.hospitalUsers.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends HospitalUsersCreateManyArgs>(
      args?: SelectSubset<T, HospitalUsersCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a HospitalUsers.
     * @param {HospitalUsersDeleteArgs} args - Arguments to delete one HospitalUsers.
     * @example
     * // Delete one HospitalUsers
     * const HospitalUsers = await prisma.hospitalUsers.delete({
     *   where: {
     *     // ... filter to delete one HospitalUsers
     *   }
     * })
     * 
    **/
    delete<T extends HospitalUsersDeleteArgs>(
      args: SelectSubset<T, HospitalUsersDeleteArgs>
    ): Prisma__HospitalUsersClient<HospitalUsersGetPayload<T>>

    /**
     * Update one HospitalUsers.
     * @param {HospitalUsersUpdateArgs} args - Arguments to update one HospitalUsers.
     * @example
     * // Update one HospitalUsers
     * const hospitalUsers = await prisma.hospitalUsers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends HospitalUsersUpdateArgs>(
      args: SelectSubset<T, HospitalUsersUpdateArgs>
    ): Prisma__HospitalUsersClient<HospitalUsersGetPayload<T>>

    /**
     * Delete zero or more HospitalUsers.
     * @param {HospitalUsersDeleteManyArgs} args - Arguments to filter HospitalUsers to delete.
     * @example
     * // Delete a few HospitalUsers
     * const { count } = await prisma.hospitalUsers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends HospitalUsersDeleteManyArgs>(
      args?: SelectSubset<T, HospitalUsersDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HospitalUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalUsersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HospitalUsers
     * const hospitalUsers = await prisma.hospitalUsers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends HospitalUsersUpdateManyArgs>(
      args: SelectSubset<T, HospitalUsersUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HospitalUsers.
     * @param {HospitalUsersUpsertArgs} args - Arguments to update or create a HospitalUsers.
     * @example
     * // Update or create a HospitalUsers
     * const hospitalUsers = await prisma.hospitalUsers.upsert({
     *   create: {
     *     // ... data to create a HospitalUsers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HospitalUsers we want to update
     *   }
     * })
    **/
    upsert<T extends HospitalUsersUpsertArgs>(
      args: SelectSubset<T, HospitalUsersUpsertArgs>
    ): Prisma__HospitalUsersClient<HospitalUsersGetPayload<T>>

    /**
     * Count the number of HospitalUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalUsersCountArgs} args - Arguments to filter HospitalUsers to count.
     * @example
     * // Count the number of HospitalUsers
     * const count = await prisma.hospitalUsers.count({
     *   where: {
     *     // ... the filter for the HospitalUsers we want to count
     *   }
     * })
    **/
    count<T extends HospitalUsersCountArgs>(
      args?: Subset<T, HospitalUsersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HospitalUsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HospitalUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalUsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HospitalUsersAggregateArgs>(args: Subset<T, HospitalUsersAggregateArgs>): Prisma.PrismaPromise<GetHospitalUsersAggregateType<T>>

    /**
     * Group by HospitalUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalUsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HospitalUsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HospitalUsersGroupByArgs['orderBy'] }
        : { orderBy?: HospitalUsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HospitalUsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHospitalUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for HospitalUsers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__HospitalUsersClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    hospital<T extends HospitalArgs= {}>(args?: Subset<T, HospitalArgs>): Prisma__HospitalClient<HospitalGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * HospitalUsers base type for findUnique actions
   */
  export type HospitalUsersFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the HospitalUsers
     */
    select?: HospitalUsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HospitalUsersInclude | null
    /**
     * Filter, which HospitalUsers to fetch.
     */
    where: HospitalUsersWhereUniqueInput
  }

  /**
   * HospitalUsers findUnique
   */
  export interface HospitalUsersFindUniqueArgs extends HospitalUsersFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * HospitalUsers findUniqueOrThrow
   */
  export type HospitalUsersFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the HospitalUsers
     */
    select?: HospitalUsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HospitalUsersInclude | null
    /**
     * Filter, which HospitalUsers to fetch.
     */
    where: HospitalUsersWhereUniqueInput
  }


  /**
   * HospitalUsers base type for findFirst actions
   */
  export type HospitalUsersFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the HospitalUsers
     */
    select?: HospitalUsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HospitalUsersInclude | null
    /**
     * Filter, which HospitalUsers to fetch.
     */
    where?: HospitalUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HospitalUsers to fetch.
     */
    orderBy?: Enumerable<HospitalUsersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HospitalUsers.
     */
    cursor?: HospitalUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HospitalUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HospitalUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HospitalUsers.
     */
    distinct?: Enumerable<HospitalUsersScalarFieldEnum>
  }

  /**
   * HospitalUsers findFirst
   */
  export interface HospitalUsersFindFirstArgs extends HospitalUsersFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * HospitalUsers findFirstOrThrow
   */
  export type HospitalUsersFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the HospitalUsers
     */
    select?: HospitalUsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HospitalUsersInclude | null
    /**
     * Filter, which HospitalUsers to fetch.
     */
    where?: HospitalUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HospitalUsers to fetch.
     */
    orderBy?: Enumerable<HospitalUsersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HospitalUsers.
     */
    cursor?: HospitalUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HospitalUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HospitalUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HospitalUsers.
     */
    distinct?: Enumerable<HospitalUsersScalarFieldEnum>
  }


  /**
   * HospitalUsers findMany
   */
  export type HospitalUsersFindManyArgs = {
    /**
     * Select specific fields to fetch from the HospitalUsers
     */
    select?: HospitalUsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HospitalUsersInclude | null
    /**
     * Filter, which HospitalUsers to fetch.
     */
    where?: HospitalUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HospitalUsers to fetch.
     */
    orderBy?: Enumerable<HospitalUsersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HospitalUsers.
     */
    cursor?: HospitalUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HospitalUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HospitalUsers.
     */
    skip?: number
    distinct?: Enumerable<HospitalUsersScalarFieldEnum>
  }


  /**
   * HospitalUsers create
   */
  export type HospitalUsersCreateArgs = {
    /**
     * Select specific fields to fetch from the HospitalUsers
     */
    select?: HospitalUsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HospitalUsersInclude | null
    /**
     * The data needed to create a HospitalUsers.
     */
    data: XOR<HospitalUsersCreateInput, HospitalUsersUncheckedCreateInput>
  }


  /**
   * HospitalUsers createMany
   */
  export type HospitalUsersCreateManyArgs = {
    /**
     * The data used to create many HospitalUsers.
     */
    data: Enumerable<HospitalUsersCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * HospitalUsers update
   */
  export type HospitalUsersUpdateArgs = {
    /**
     * Select specific fields to fetch from the HospitalUsers
     */
    select?: HospitalUsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HospitalUsersInclude | null
    /**
     * The data needed to update a HospitalUsers.
     */
    data: XOR<HospitalUsersUpdateInput, HospitalUsersUncheckedUpdateInput>
    /**
     * Choose, which HospitalUsers to update.
     */
    where: HospitalUsersWhereUniqueInput
  }


  /**
   * HospitalUsers updateMany
   */
  export type HospitalUsersUpdateManyArgs = {
    /**
     * The data used to update HospitalUsers.
     */
    data: XOR<HospitalUsersUpdateManyMutationInput, HospitalUsersUncheckedUpdateManyInput>
    /**
     * Filter which HospitalUsers to update
     */
    where?: HospitalUsersWhereInput
  }


  /**
   * HospitalUsers upsert
   */
  export type HospitalUsersUpsertArgs = {
    /**
     * Select specific fields to fetch from the HospitalUsers
     */
    select?: HospitalUsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HospitalUsersInclude | null
    /**
     * The filter to search for the HospitalUsers to update in case it exists.
     */
    where: HospitalUsersWhereUniqueInput
    /**
     * In case the HospitalUsers found by the `where` argument doesn't exist, create a new HospitalUsers with this data.
     */
    create: XOR<HospitalUsersCreateInput, HospitalUsersUncheckedCreateInput>
    /**
     * In case the HospitalUsers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HospitalUsersUpdateInput, HospitalUsersUncheckedUpdateInput>
  }


  /**
   * HospitalUsers delete
   */
  export type HospitalUsersDeleteArgs = {
    /**
     * Select specific fields to fetch from the HospitalUsers
     */
    select?: HospitalUsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HospitalUsersInclude | null
    /**
     * Filter which HospitalUsers to delete.
     */
    where: HospitalUsersWhereUniqueInput
  }


  /**
   * HospitalUsers deleteMany
   */
  export type HospitalUsersDeleteManyArgs = {
    /**
     * Filter which HospitalUsers to delete
     */
    where?: HospitalUsersWhereInput
  }


  /**
   * HospitalUsers without action
   */
  export type HospitalUsersArgs = {
    /**
     * Select specific fields to fetch from the HospitalUsers
     */
    select?: HospitalUsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HospitalUsersInclude | null
  }



  /**
   * Model DatabaseConnection
   */


  export type AggregateDatabaseConnection = {
    _count: DatabaseConnectionCountAggregateOutputType | null
    _avg: DatabaseConnectionAvgAggregateOutputType | null
    _sum: DatabaseConnectionSumAggregateOutputType | null
    _min: DatabaseConnectionMinAggregateOutputType | null
    _max: DatabaseConnectionMaxAggregateOutputType | null
  }

  export type DatabaseConnectionAvgAggregateOutputType = {
    port: number | null
  }

  export type DatabaseConnectionSumAggregateOutputType = {
    port: number | null
  }

  export type DatabaseConnectionMinAggregateOutputType = {
    id: string | null
    connectionName: string | null
    connectionType: string | null
    host: string | null
    port: number | null
    databaseName: string | null
    username: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
    hospitalId: string | null
  }

  export type DatabaseConnectionMaxAggregateOutputType = {
    id: string | null
    connectionName: string | null
    connectionType: string | null
    host: string | null
    port: number | null
    databaseName: string | null
    username: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
    hospitalId: string | null
  }

  export type DatabaseConnectionCountAggregateOutputType = {
    id: number
    connectionName: number
    connectionType: number
    host: number
    port: number
    databaseName: number
    username: number
    password: number
    createdAt: number
    updatedAt: number
    hospitalId: number
    _all: number
  }


  export type DatabaseConnectionAvgAggregateInputType = {
    port?: true
  }

  export type DatabaseConnectionSumAggregateInputType = {
    port?: true
  }

  export type DatabaseConnectionMinAggregateInputType = {
    id?: true
    connectionName?: true
    connectionType?: true
    host?: true
    port?: true
    databaseName?: true
    username?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    hospitalId?: true
  }

  export type DatabaseConnectionMaxAggregateInputType = {
    id?: true
    connectionName?: true
    connectionType?: true
    host?: true
    port?: true
    databaseName?: true
    username?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    hospitalId?: true
  }

  export type DatabaseConnectionCountAggregateInputType = {
    id?: true
    connectionName?: true
    connectionType?: true
    host?: true
    port?: true
    databaseName?: true
    username?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    hospitalId?: true
    _all?: true
  }

  export type DatabaseConnectionAggregateArgs = {
    /**
     * Filter which DatabaseConnection to aggregate.
     */
    where?: DatabaseConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DatabaseConnections to fetch.
     */
    orderBy?: Enumerable<DatabaseConnectionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DatabaseConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DatabaseConnections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DatabaseConnections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DatabaseConnections
    **/
    _count?: true | DatabaseConnectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DatabaseConnectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DatabaseConnectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DatabaseConnectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DatabaseConnectionMaxAggregateInputType
  }

  export type GetDatabaseConnectionAggregateType<T extends DatabaseConnectionAggregateArgs> = {
        [P in keyof T & keyof AggregateDatabaseConnection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDatabaseConnection[P]>
      : GetScalarType<T[P], AggregateDatabaseConnection[P]>
  }




  export type DatabaseConnectionGroupByArgs = {
    where?: DatabaseConnectionWhereInput
    orderBy?: Enumerable<DatabaseConnectionOrderByWithAggregationInput>
    by: DatabaseConnectionScalarFieldEnum[]
    having?: DatabaseConnectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DatabaseConnectionCountAggregateInputType | true
    _avg?: DatabaseConnectionAvgAggregateInputType
    _sum?: DatabaseConnectionSumAggregateInputType
    _min?: DatabaseConnectionMinAggregateInputType
    _max?: DatabaseConnectionMaxAggregateInputType
  }


  export type DatabaseConnectionGroupByOutputType = {
    id: string
    connectionName: string
    connectionType: string
    host: string
    port: number
    databaseName: string
    username: string
    password: string
    createdAt: Date
    updatedAt: Date
    hospitalId: string | null
    _count: DatabaseConnectionCountAggregateOutputType | null
    _avg: DatabaseConnectionAvgAggregateOutputType | null
    _sum: DatabaseConnectionSumAggregateOutputType | null
    _min: DatabaseConnectionMinAggregateOutputType | null
    _max: DatabaseConnectionMaxAggregateOutputType | null
  }

  type GetDatabaseConnectionGroupByPayload<T extends DatabaseConnectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DatabaseConnectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DatabaseConnectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DatabaseConnectionGroupByOutputType[P]>
            : GetScalarType<T[P], DatabaseConnectionGroupByOutputType[P]>
        }
      >
    >


  export type DatabaseConnectionSelect = {
    id?: boolean
    connectionName?: boolean
    connectionType?: boolean
    host?: boolean
    port?: boolean
    databaseName?: boolean
    username?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hospitalId?: boolean
    Hospital?: boolean | HospitalArgs
  }


  export type DatabaseConnectionInclude = {
    Hospital?: boolean | HospitalArgs
  }

  export type DatabaseConnectionGetPayload<S extends boolean | null | undefined | DatabaseConnectionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? DatabaseConnection :
    S extends undefined ? never :
    S extends { include: any } & (DatabaseConnectionArgs | DatabaseConnectionFindManyArgs)
    ? DatabaseConnection  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Hospital' ? HospitalGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (DatabaseConnectionArgs | DatabaseConnectionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Hospital' ? HospitalGetPayload<S['select'][P]> | null :  P extends keyof DatabaseConnection ? DatabaseConnection[P] : never
  } 
      : DatabaseConnection


  type DatabaseConnectionCountArgs = 
    Omit<DatabaseConnectionFindManyArgs, 'select' | 'include'> & {
      select?: DatabaseConnectionCountAggregateInputType | true
    }

  export interface DatabaseConnectionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one DatabaseConnection that matches the filter.
     * @param {DatabaseConnectionFindUniqueArgs} args - Arguments to find a DatabaseConnection
     * @example
     * // Get one DatabaseConnection
     * const databaseConnection = await prisma.databaseConnection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DatabaseConnectionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DatabaseConnectionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DatabaseConnection'> extends True ? Prisma__DatabaseConnectionClient<DatabaseConnectionGetPayload<T>> : Prisma__DatabaseConnectionClient<DatabaseConnectionGetPayload<T> | null, null>

    /**
     * Find one DatabaseConnection that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DatabaseConnectionFindUniqueOrThrowArgs} args - Arguments to find a DatabaseConnection
     * @example
     * // Get one DatabaseConnection
     * const databaseConnection = await prisma.databaseConnection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DatabaseConnectionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DatabaseConnectionFindUniqueOrThrowArgs>
    ): Prisma__DatabaseConnectionClient<DatabaseConnectionGetPayload<T>>

    /**
     * Find the first DatabaseConnection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseConnectionFindFirstArgs} args - Arguments to find a DatabaseConnection
     * @example
     * // Get one DatabaseConnection
     * const databaseConnection = await prisma.databaseConnection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DatabaseConnectionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DatabaseConnectionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DatabaseConnection'> extends True ? Prisma__DatabaseConnectionClient<DatabaseConnectionGetPayload<T>> : Prisma__DatabaseConnectionClient<DatabaseConnectionGetPayload<T> | null, null>

    /**
     * Find the first DatabaseConnection that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseConnectionFindFirstOrThrowArgs} args - Arguments to find a DatabaseConnection
     * @example
     * // Get one DatabaseConnection
     * const databaseConnection = await prisma.databaseConnection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DatabaseConnectionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DatabaseConnectionFindFirstOrThrowArgs>
    ): Prisma__DatabaseConnectionClient<DatabaseConnectionGetPayload<T>>

    /**
     * Find zero or more DatabaseConnections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseConnectionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DatabaseConnections
     * const databaseConnections = await prisma.databaseConnection.findMany()
     * 
     * // Get first 10 DatabaseConnections
     * const databaseConnections = await prisma.databaseConnection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const databaseConnectionWithIdOnly = await prisma.databaseConnection.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DatabaseConnectionFindManyArgs>(
      args?: SelectSubset<T, DatabaseConnectionFindManyArgs>
    ): Prisma.PrismaPromise<Array<DatabaseConnectionGetPayload<T>>>

    /**
     * Create a DatabaseConnection.
     * @param {DatabaseConnectionCreateArgs} args - Arguments to create a DatabaseConnection.
     * @example
     * // Create one DatabaseConnection
     * const DatabaseConnection = await prisma.databaseConnection.create({
     *   data: {
     *     // ... data to create a DatabaseConnection
     *   }
     * })
     * 
    **/
    create<T extends DatabaseConnectionCreateArgs>(
      args: SelectSubset<T, DatabaseConnectionCreateArgs>
    ): Prisma__DatabaseConnectionClient<DatabaseConnectionGetPayload<T>>

    /**
     * Create many DatabaseConnections.
     *     @param {DatabaseConnectionCreateManyArgs} args - Arguments to create many DatabaseConnections.
     *     @example
     *     // Create many DatabaseConnections
     *     const databaseConnection = await prisma.databaseConnection.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DatabaseConnectionCreateManyArgs>(
      args?: SelectSubset<T, DatabaseConnectionCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DatabaseConnection.
     * @param {DatabaseConnectionDeleteArgs} args - Arguments to delete one DatabaseConnection.
     * @example
     * // Delete one DatabaseConnection
     * const DatabaseConnection = await prisma.databaseConnection.delete({
     *   where: {
     *     // ... filter to delete one DatabaseConnection
     *   }
     * })
     * 
    **/
    delete<T extends DatabaseConnectionDeleteArgs>(
      args: SelectSubset<T, DatabaseConnectionDeleteArgs>
    ): Prisma__DatabaseConnectionClient<DatabaseConnectionGetPayload<T>>

    /**
     * Update one DatabaseConnection.
     * @param {DatabaseConnectionUpdateArgs} args - Arguments to update one DatabaseConnection.
     * @example
     * // Update one DatabaseConnection
     * const databaseConnection = await prisma.databaseConnection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DatabaseConnectionUpdateArgs>(
      args: SelectSubset<T, DatabaseConnectionUpdateArgs>
    ): Prisma__DatabaseConnectionClient<DatabaseConnectionGetPayload<T>>

    /**
     * Delete zero or more DatabaseConnections.
     * @param {DatabaseConnectionDeleteManyArgs} args - Arguments to filter DatabaseConnections to delete.
     * @example
     * // Delete a few DatabaseConnections
     * const { count } = await prisma.databaseConnection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DatabaseConnectionDeleteManyArgs>(
      args?: SelectSubset<T, DatabaseConnectionDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DatabaseConnections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseConnectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DatabaseConnections
     * const databaseConnection = await prisma.databaseConnection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DatabaseConnectionUpdateManyArgs>(
      args: SelectSubset<T, DatabaseConnectionUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DatabaseConnection.
     * @param {DatabaseConnectionUpsertArgs} args - Arguments to update or create a DatabaseConnection.
     * @example
     * // Update or create a DatabaseConnection
     * const databaseConnection = await prisma.databaseConnection.upsert({
     *   create: {
     *     // ... data to create a DatabaseConnection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DatabaseConnection we want to update
     *   }
     * })
    **/
    upsert<T extends DatabaseConnectionUpsertArgs>(
      args: SelectSubset<T, DatabaseConnectionUpsertArgs>
    ): Prisma__DatabaseConnectionClient<DatabaseConnectionGetPayload<T>>

    /**
     * Count the number of DatabaseConnections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseConnectionCountArgs} args - Arguments to filter DatabaseConnections to count.
     * @example
     * // Count the number of DatabaseConnections
     * const count = await prisma.databaseConnection.count({
     *   where: {
     *     // ... the filter for the DatabaseConnections we want to count
     *   }
     * })
    **/
    count<T extends DatabaseConnectionCountArgs>(
      args?: Subset<T, DatabaseConnectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DatabaseConnectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DatabaseConnection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseConnectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DatabaseConnectionAggregateArgs>(args: Subset<T, DatabaseConnectionAggregateArgs>): Prisma.PrismaPromise<GetDatabaseConnectionAggregateType<T>>

    /**
     * Group by DatabaseConnection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseConnectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DatabaseConnectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DatabaseConnectionGroupByArgs['orderBy'] }
        : { orderBy?: DatabaseConnectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DatabaseConnectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDatabaseConnectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for DatabaseConnection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DatabaseConnectionClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Hospital<T extends HospitalArgs= {}>(args?: Subset<T, HospitalArgs>): Prisma__HospitalClient<HospitalGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * DatabaseConnection base type for findUnique actions
   */
  export type DatabaseConnectionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the DatabaseConnection
     */
    select?: DatabaseConnectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DatabaseConnectionInclude | null
    /**
     * Filter, which DatabaseConnection to fetch.
     */
    where: DatabaseConnectionWhereUniqueInput
  }

  /**
   * DatabaseConnection findUnique
   */
  export interface DatabaseConnectionFindUniqueArgs extends DatabaseConnectionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DatabaseConnection findUniqueOrThrow
   */
  export type DatabaseConnectionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the DatabaseConnection
     */
    select?: DatabaseConnectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DatabaseConnectionInclude | null
    /**
     * Filter, which DatabaseConnection to fetch.
     */
    where: DatabaseConnectionWhereUniqueInput
  }


  /**
   * DatabaseConnection base type for findFirst actions
   */
  export type DatabaseConnectionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the DatabaseConnection
     */
    select?: DatabaseConnectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DatabaseConnectionInclude | null
    /**
     * Filter, which DatabaseConnection to fetch.
     */
    where?: DatabaseConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DatabaseConnections to fetch.
     */
    orderBy?: Enumerable<DatabaseConnectionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DatabaseConnections.
     */
    cursor?: DatabaseConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DatabaseConnections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DatabaseConnections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DatabaseConnections.
     */
    distinct?: Enumerable<DatabaseConnectionScalarFieldEnum>
  }

  /**
   * DatabaseConnection findFirst
   */
  export interface DatabaseConnectionFindFirstArgs extends DatabaseConnectionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DatabaseConnection findFirstOrThrow
   */
  export type DatabaseConnectionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the DatabaseConnection
     */
    select?: DatabaseConnectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DatabaseConnectionInclude | null
    /**
     * Filter, which DatabaseConnection to fetch.
     */
    where?: DatabaseConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DatabaseConnections to fetch.
     */
    orderBy?: Enumerable<DatabaseConnectionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DatabaseConnections.
     */
    cursor?: DatabaseConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DatabaseConnections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DatabaseConnections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DatabaseConnections.
     */
    distinct?: Enumerable<DatabaseConnectionScalarFieldEnum>
  }


  /**
   * DatabaseConnection findMany
   */
  export type DatabaseConnectionFindManyArgs = {
    /**
     * Select specific fields to fetch from the DatabaseConnection
     */
    select?: DatabaseConnectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DatabaseConnectionInclude | null
    /**
     * Filter, which DatabaseConnections to fetch.
     */
    where?: DatabaseConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DatabaseConnections to fetch.
     */
    orderBy?: Enumerable<DatabaseConnectionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DatabaseConnections.
     */
    cursor?: DatabaseConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DatabaseConnections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DatabaseConnections.
     */
    skip?: number
    distinct?: Enumerable<DatabaseConnectionScalarFieldEnum>
  }


  /**
   * DatabaseConnection create
   */
  export type DatabaseConnectionCreateArgs = {
    /**
     * Select specific fields to fetch from the DatabaseConnection
     */
    select?: DatabaseConnectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DatabaseConnectionInclude | null
    /**
     * The data needed to create a DatabaseConnection.
     */
    data: XOR<DatabaseConnectionCreateInput, DatabaseConnectionUncheckedCreateInput>
  }


  /**
   * DatabaseConnection createMany
   */
  export type DatabaseConnectionCreateManyArgs = {
    /**
     * The data used to create many DatabaseConnections.
     */
    data: Enumerable<DatabaseConnectionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * DatabaseConnection update
   */
  export type DatabaseConnectionUpdateArgs = {
    /**
     * Select specific fields to fetch from the DatabaseConnection
     */
    select?: DatabaseConnectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DatabaseConnectionInclude | null
    /**
     * The data needed to update a DatabaseConnection.
     */
    data: XOR<DatabaseConnectionUpdateInput, DatabaseConnectionUncheckedUpdateInput>
    /**
     * Choose, which DatabaseConnection to update.
     */
    where: DatabaseConnectionWhereUniqueInput
  }


  /**
   * DatabaseConnection updateMany
   */
  export type DatabaseConnectionUpdateManyArgs = {
    /**
     * The data used to update DatabaseConnections.
     */
    data: XOR<DatabaseConnectionUpdateManyMutationInput, DatabaseConnectionUncheckedUpdateManyInput>
    /**
     * Filter which DatabaseConnections to update
     */
    where?: DatabaseConnectionWhereInput
  }


  /**
   * DatabaseConnection upsert
   */
  export type DatabaseConnectionUpsertArgs = {
    /**
     * Select specific fields to fetch from the DatabaseConnection
     */
    select?: DatabaseConnectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DatabaseConnectionInclude | null
    /**
     * The filter to search for the DatabaseConnection to update in case it exists.
     */
    where: DatabaseConnectionWhereUniqueInput
    /**
     * In case the DatabaseConnection found by the `where` argument doesn't exist, create a new DatabaseConnection with this data.
     */
    create: XOR<DatabaseConnectionCreateInput, DatabaseConnectionUncheckedCreateInput>
    /**
     * In case the DatabaseConnection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DatabaseConnectionUpdateInput, DatabaseConnectionUncheckedUpdateInput>
  }


  /**
   * DatabaseConnection delete
   */
  export type DatabaseConnectionDeleteArgs = {
    /**
     * Select specific fields to fetch from the DatabaseConnection
     */
    select?: DatabaseConnectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DatabaseConnectionInclude | null
    /**
     * Filter which DatabaseConnection to delete.
     */
    where: DatabaseConnectionWhereUniqueInput
  }


  /**
   * DatabaseConnection deleteMany
   */
  export type DatabaseConnectionDeleteManyArgs = {
    /**
     * Filter which DatabaseConnections to delete
     */
    where?: DatabaseConnectionWhereInput
  }


  /**
   * DatabaseConnection without action
   */
  export type DatabaseConnectionArgs = {
    /**
     * Select specific fields to fetch from the DatabaseConnection
     */
    select?: DatabaseConnectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DatabaseConnectionInclude | null
  }



  /**
   * Model Product
   */


  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    productDescription: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    productDescription?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs = {
    where?: ProductWhereInput
    orderBy?: Enumerable<ProductOrderByWithAggregationInput>
    by: ProductScalarFieldEnum[]
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }


  export type ProductGroupByOutputType = {
    id: string
    name: string
    productDescription: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect = {
    id?: boolean
    name?: boolean
    productDescription?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ProductVariant?: boolean | Product$ProductVariantArgs
    ProductPayment?: boolean | Product$ProductPaymentArgs
    QPayInvoice?: boolean | Product$QPayInvoiceArgs
    _count?: boolean | ProductCountOutputTypeArgs
  }


  export type ProductInclude = {
    ProductVariant?: boolean | Product$ProductVariantArgs
    ProductPayment?: boolean | Product$ProductPaymentArgs
    QPayInvoice?: boolean | Product$QPayInvoiceArgs
    _count?: boolean | ProductCountOutputTypeArgs
  }

  export type ProductGetPayload<S extends boolean | null | undefined | ProductArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Product :
    S extends undefined ? never :
    S extends { include: any } & (ProductArgs | ProductFindManyArgs)
    ? Product  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'ProductVariant' ? Array < ProductVariantGetPayload<S['include'][P]>>  :
        P extends 'ProductPayment' ? Array < ProductPaymentGetPayload<S['include'][P]>>  :
        P extends 'QPayInvoice' ? Array < QPayInvoiceGetPayload<S['include'][P]>>  :
        P extends '_count' ? ProductCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ProductArgs | ProductFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'ProductVariant' ? Array < ProductVariantGetPayload<S['select'][P]>>  :
        P extends 'ProductPayment' ? Array < ProductPaymentGetPayload<S['select'][P]>>  :
        P extends 'QPayInvoice' ? Array < QPayInvoiceGetPayload<S['select'][P]>>  :
        P extends '_count' ? ProductCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Product ? Product[P] : never
  } 
      : Product


  type ProductCountArgs = 
    Omit<ProductFindManyArgs, 'select' | 'include'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Product'> extends True ? Prisma__ProductClient<ProductGetPayload<T>> : Prisma__ProductClient<ProductGetPayload<T> | null, null>

    /**
     * Find one Product that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ProductFindUniqueOrThrowArgs>
    ): Prisma__ProductClient<ProductGetPayload<T>>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Product'> extends True ? Prisma__ProductClient<ProductGetPayload<T>> : Prisma__ProductClient<ProductGetPayload<T> | null, null>

    /**
     * Find the first Product that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProductFindFirstOrThrowArgs>
    ): Prisma__ProductClient<ProductGetPayload<T>>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductFindManyArgs>(
      args?: SelectSubset<T, ProductFindManyArgs>
    ): Prisma.PrismaPromise<Array<ProductGetPayload<T>>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
    **/
    create<T extends ProductCreateArgs>(
      args: SelectSubset<T, ProductCreateArgs>
    ): Prisma__ProductClient<ProductGetPayload<T>>

    /**
     * Create many Products.
     *     @param {ProductCreateManyArgs} args - Arguments to create many Products.
     *     @example
     *     // Create many Products
     *     const product = await prisma.product.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductCreateManyArgs>(
      args?: SelectSubset<T, ProductCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
    **/
    delete<T extends ProductDeleteArgs>(
      args: SelectSubset<T, ProductDeleteArgs>
    ): Prisma__ProductClient<ProductGetPayload<T>>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductUpdateArgs>(
      args: SelectSubset<T, ProductUpdateArgs>
    ): Prisma__ProductClient<ProductGetPayload<T>>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductDeleteManyArgs>(
      args?: SelectSubset<T, ProductDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductUpdateManyArgs>(
      args: SelectSubset<T, ProductUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
    **/
    upsert<T extends ProductUpsertArgs>(
      args: SelectSubset<T, ProductUpsertArgs>
    ): Prisma__ProductClient<ProductGetPayload<T>>

    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    ProductVariant<T extends Product$ProductVariantArgs= {}>(args?: Subset<T, Product$ProductVariantArgs>): Prisma.PrismaPromise<Array<ProductVariantGetPayload<T>>| Null>;

    ProductPayment<T extends Product$ProductPaymentArgs= {}>(args?: Subset<T, Product$ProductPaymentArgs>): Prisma.PrismaPromise<Array<ProductPaymentGetPayload<T>>| Null>;

    QPayInvoice<T extends Product$QPayInvoiceArgs= {}>(args?: Subset<T, Product$QPayInvoiceArgs>): Prisma.PrismaPromise<Array<QPayInvoiceGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Product base type for findUnique actions
   */
  export type ProductFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUnique
   */
  export interface ProductFindUniqueArgs extends ProductFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }


  /**
   * Product base type for findFirst actions
   */
  export type ProductFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: Enumerable<ProductScalarFieldEnum>
  }

  /**
   * Product findFirst
   */
  export interface ProductFindFirstArgs extends ProductFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * Product findMany
   */
  export type ProductFindManyArgs = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * Product create
   */
  export type ProductCreateArgs = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }


  /**
   * Product createMany
   */
  export type ProductCreateManyArgs = {
    /**
     * The data used to create many Products.
     */
    data: Enumerable<ProductCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Product update
   */
  export type ProductUpdateArgs = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }


  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
  }


  /**
   * Product upsert
   */
  export type ProductUpsertArgs = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }


  /**
   * Product delete
   */
  export type ProductDeleteArgs = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }


  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
  }


  /**
   * Product.ProductVariant
   */
  export type Product$ProductVariantArgs = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductVariantInclude | null
    where?: ProductVariantWhereInput
    orderBy?: Enumerable<ProductVariantOrderByWithRelationInput>
    cursor?: ProductVariantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProductVariantScalarFieldEnum>
  }


  /**
   * Product.ProductPayment
   */
  export type Product$ProductPaymentArgs = {
    /**
     * Select specific fields to fetch from the ProductPayment
     */
    select?: ProductPaymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductPaymentInclude | null
    where?: ProductPaymentWhereInput
    orderBy?: Enumerable<ProductPaymentOrderByWithRelationInput>
    cursor?: ProductPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProductPaymentScalarFieldEnum>
  }


  /**
   * Product.QPayInvoice
   */
  export type Product$QPayInvoiceArgs = {
    /**
     * Select specific fields to fetch from the QPayInvoice
     */
    select?: QPayInvoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QPayInvoiceInclude | null
    where?: QPayInvoiceWhereInput
    orderBy?: Enumerable<QPayInvoiceOrderByWithRelationInput>
    cursor?: QPayInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<QPayInvoiceScalarFieldEnum>
  }


  /**
   * Product without action
   */
  export type ProductArgs = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude | null
  }



  /**
   * Model ProductVariant
   */


  export type AggregateProductVariant = {
    _count: ProductVariantCountAggregateOutputType | null
    _avg: ProductVariantAvgAggregateOutputType | null
    _sum: ProductVariantSumAggregateOutputType | null
    _min: ProductVariantMinAggregateOutputType | null
    _max: ProductVariantMaxAggregateOutputType | null
  }

  export type ProductVariantAvgAggregateOutputType = {
    price: number | null
    unit: number | null
    duration: number | null
    discount: number | null
    sits: number | null
  }

  export type ProductVariantSumAggregateOutputType = {
    price: number | null
    unit: number | null
    duration: number | null
    discount: number | null
    sits: number[] | null
  }

  export type ProductVariantMinAggregateOutputType = {
    id: string | null
    productId: string | null
    name: string | null
    price: number | null
    unit: number | null
    duration: number | null
    discount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductVariantMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    name: string | null
    price: number | null
    unit: number | null
    duration: number | null
    discount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductVariantCountAggregateOutputType = {
    id: number
    productId: number
    name: number
    price: number
    unit: number
    duration: number
    discount: number
    createdAt: number
    updatedAt: number
    sits: number
    _all: number
  }


  export type ProductVariantAvgAggregateInputType = {
    price?: true
    unit?: true
    duration?: true
    discount?: true
    sits?: true
  }

  export type ProductVariantSumAggregateInputType = {
    price?: true
    unit?: true
    duration?: true
    discount?: true
    sits?: true
  }

  export type ProductVariantMinAggregateInputType = {
    id?: true
    productId?: true
    name?: true
    price?: true
    unit?: true
    duration?: true
    discount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductVariantMaxAggregateInputType = {
    id?: true
    productId?: true
    name?: true
    price?: true
    unit?: true
    duration?: true
    discount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductVariantCountAggregateInputType = {
    id?: true
    productId?: true
    name?: true
    price?: true
    unit?: true
    duration?: true
    discount?: true
    createdAt?: true
    updatedAt?: true
    sits?: true
    _all?: true
  }

  export type ProductVariantAggregateArgs = {
    /**
     * Filter which ProductVariant to aggregate.
     */
    where?: ProductVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariants to fetch.
     */
    orderBy?: Enumerable<ProductVariantOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductVariants
    **/
    _count?: true | ProductVariantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductVariantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductVariantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductVariantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductVariantMaxAggregateInputType
  }

  export type GetProductVariantAggregateType<T extends ProductVariantAggregateArgs> = {
        [P in keyof T & keyof AggregateProductVariant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductVariant[P]>
      : GetScalarType<T[P], AggregateProductVariant[P]>
  }




  export type ProductVariantGroupByArgs = {
    where?: ProductVariantWhereInput
    orderBy?: Enumerable<ProductVariantOrderByWithAggregationInput>
    by: ProductVariantScalarFieldEnum[]
    having?: ProductVariantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductVariantCountAggregateInputType | true
    _avg?: ProductVariantAvgAggregateInputType
    _sum?: ProductVariantSumAggregateInputType
    _min?: ProductVariantMinAggregateInputType
    _max?: ProductVariantMaxAggregateInputType
  }


  export type ProductVariantGroupByOutputType = {
    id: string
    productId: string
    name: string
    price: number
    unit: number
    duration: number
    discount: number
    createdAt: Date
    updatedAt: Date
    sits: number[]
    _count: ProductVariantCountAggregateOutputType | null
    _avg: ProductVariantAvgAggregateOutputType | null
    _sum: ProductVariantSumAggregateOutputType | null
    _min: ProductVariantMinAggregateOutputType | null
    _max: ProductVariantMaxAggregateOutputType | null
  }

  type GetProductVariantGroupByPayload<T extends ProductVariantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProductVariantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductVariantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductVariantGroupByOutputType[P]>
            : GetScalarType<T[P], ProductVariantGroupByOutputType[P]>
        }
      >
    >


  export type ProductVariantSelect = {
    id?: boolean
    productId?: boolean
    name?: boolean
    price?: boolean
    unit?: boolean
    duration?: boolean
    discount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sits?: boolean
    Product?: boolean | ProductArgs
    ProductPayment?: boolean | ProductVariant$ProductPaymentArgs
    QPayInvoice?: boolean | ProductVariant$QPayInvoiceArgs
    _count?: boolean | ProductVariantCountOutputTypeArgs
  }


  export type ProductVariantInclude = {
    Product?: boolean | ProductArgs
    ProductPayment?: boolean | ProductVariant$ProductPaymentArgs
    QPayInvoice?: boolean | ProductVariant$QPayInvoiceArgs
    _count?: boolean | ProductVariantCountOutputTypeArgs
  }

  export type ProductVariantGetPayload<S extends boolean | null | undefined | ProductVariantArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ProductVariant :
    S extends undefined ? never :
    S extends { include: any } & (ProductVariantArgs | ProductVariantFindManyArgs)
    ? ProductVariant  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Product' ? ProductGetPayload<S['include'][P]> :
        P extends 'ProductPayment' ? Array < ProductPaymentGetPayload<S['include'][P]>>  :
        P extends 'QPayInvoice' ? Array < QPayInvoiceGetPayload<S['include'][P]>>  :
        P extends '_count' ? ProductVariantCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ProductVariantArgs | ProductVariantFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Product' ? ProductGetPayload<S['select'][P]> :
        P extends 'ProductPayment' ? Array < ProductPaymentGetPayload<S['select'][P]>>  :
        P extends 'QPayInvoice' ? Array < QPayInvoiceGetPayload<S['select'][P]>>  :
        P extends '_count' ? ProductVariantCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof ProductVariant ? ProductVariant[P] : never
  } 
      : ProductVariant


  type ProductVariantCountArgs = 
    Omit<ProductVariantFindManyArgs, 'select' | 'include'> & {
      select?: ProductVariantCountAggregateInputType | true
    }

  export interface ProductVariantDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ProductVariant that matches the filter.
     * @param {ProductVariantFindUniqueArgs} args - Arguments to find a ProductVariant
     * @example
     * // Get one ProductVariant
     * const productVariant = await prisma.productVariant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductVariantFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductVariantFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProductVariant'> extends True ? Prisma__ProductVariantClient<ProductVariantGetPayload<T>> : Prisma__ProductVariantClient<ProductVariantGetPayload<T> | null, null>

    /**
     * Find one ProductVariant that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductVariantFindUniqueOrThrowArgs} args - Arguments to find a ProductVariant
     * @example
     * // Get one ProductVariant
     * const productVariant = await prisma.productVariant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductVariantFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ProductVariantFindUniqueOrThrowArgs>
    ): Prisma__ProductVariantClient<ProductVariantGetPayload<T>>

    /**
     * Find the first ProductVariant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantFindFirstArgs} args - Arguments to find a ProductVariant
     * @example
     * // Get one ProductVariant
     * const productVariant = await prisma.productVariant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductVariantFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductVariantFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProductVariant'> extends True ? Prisma__ProductVariantClient<ProductVariantGetPayload<T>> : Prisma__ProductVariantClient<ProductVariantGetPayload<T> | null, null>

    /**
     * Find the first ProductVariant that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantFindFirstOrThrowArgs} args - Arguments to find a ProductVariant
     * @example
     * // Get one ProductVariant
     * const productVariant = await prisma.productVariant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductVariantFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProductVariantFindFirstOrThrowArgs>
    ): Prisma__ProductVariantClient<ProductVariantGetPayload<T>>

    /**
     * Find zero or more ProductVariants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductVariants
     * const productVariants = await prisma.productVariant.findMany()
     * 
     * // Get first 10 ProductVariants
     * const productVariants = await prisma.productVariant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productVariantWithIdOnly = await prisma.productVariant.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductVariantFindManyArgs>(
      args?: SelectSubset<T, ProductVariantFindManyArgs>
    ): Prisma.PrismaPromise<Array<ProductVariantGetPayload<T>>>

    /**
     * Create a ProductVariant.
     * @param {ProductVariantCreateArgs} args - Arguments to create a ProductVariant.
     * @example
     * // Create one ProductVariant
     * const ProductVariant = await prisma.productVariant.create({
     *   data: {
     *     // ... data to create a ProductVariant
     *   }
     * })
     * 
    **/
    create<T extends ProductVariantCreateArgs>(
      args: SelectSubset<T, ProductVariantCreateArgs>
    ): Prisma__ProductVariantClient<ProductVariantGetPayload<T>>

    /**
     * Create many ProductVariants.
     *     @param {ProductVariantCreateManyArgs} args - Arguments to create many ProductVariants.
     *     @example
     *     // Create many ProductVariants
     *     const productVariant = await prisma.productVariant.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductVariantCreateManyArgs>(
      args?: SelectSubset<T, ProductVariantCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductVariant.
     * @param {ProductVariantDeleteArgs} args - Arguments to delete one ProductVariant.
     * @example
     * // Delete one ProductVariant
     * const ProductVariant = await prisma.productVariant.delete({
     *   where: {
     *     // ... filter to delete one ProductVariant
     *   }
     * })
     * 
    **/
    delete<T extends ProductVariantDeleteArgs>(
      args: SelectSubset<T, ProductVariantDeleteArgs>
    ): Prisma__ProductVariantClient<ProductVariantGetPayload<T>>

    /**
     * Update one ProductVariant.
     * @param {ProductVariantUpdateArgs} args - Arguments to update one ProductVariant.
     * @example
     * // Update one ProductVariant
     * const productVariant = await prisma.productVariant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductVariantUpdateArgs>(
      args: SelectSubset<T, ProductVariantUpdateArgs>
    ): Prisma__ProductVariantClient<ProductVariantGetPayload<T>>

    /**
     * Delete zero or more ProductVariants.
     * @param {ProductVariantDeleteManyArgs} args - Arguments to filter ProductVariants to delete.
     * @example
     * // Delete a few ProductVariants
     * const { count } = await prisma.productVariant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductVariantDeleteManyArgs>(
      args?: SelectSubset<T, ProductVariantDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductVariants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductVariants
     * const productVariant = await prisma.productVariant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductVariantUpdateManyArgs>(
      args: SelectSubset<T, ProductVariantUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductVariant.
     * @param {ProductVariantUpsertArgs} args - Arguments to update or create a ProductVariant.
     * @example
     * // Update or create a ProductVariant
     * const productVariant = await prisma.productVariant.upsert({
     *   create: {
     *     // ... data to create a ProductVariant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductVariant we want to update
     *   }
     * })
    **/
    upsert<T extends ProductVariantUpsertArgs>(
      args: SelectSubset<T, ProductVariantUpsertArgs>
    ): Prisma__ProductVariantClient<ProductVariantGetPayload<T>>

    /**
     * Count the number of ProductVariants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantCountArgs} args - Arguments to filter ProductVariants to count.
     * @example
     * // Count the number of ProductVariants
     * const count = await prisma.productVariant.count({
     *   where: {
     *     // ... the filter for the ProductVariants we want to count
     *   }
     * })
    **/
    count<T extends ProductVariantCountArgs>(
      args?: Subset<T, ProductVariantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductVariantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductVariant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductVariantAggregateArgs>(args: Subset<T, ProductVariantAggregateArgs>): Prisma.PrismaPromise<GetProductVariantAggregateType<T>>

    /**
     * Group by ProductVariant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductVariantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductVariantGroupByArgs['orderBy'] }
        : { orderBy?: ProductVariantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductVariantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductVariantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductVariant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductVariantClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Product<T extends ProductArgs= {}>(args?: Subset<T, ProductArgs>): Prisma__ProductClient<ProductGetPayload<T> | Null>;

    ProductPayment<T extends ProductVariant$ProductPaymentArgs= {}>(args?: Subset<T, ProductVariant$ProductPaymentArgs>): Prisma.PrismaPromise<Array<ProductPaymentGetPayload<T>>| Null>;

    QPayInvoice<T extends ProductVariant$QPayInvoiceArgs= {}>(args?: Subset<T, ProductVariant$QPayInvoiceArgs>): Prisma.PrismaPromise<Array<QPayInvoiceGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ProductVariant base type for findUnique actions
   */
  export type ProductVariantFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductVariantInclude | null
    /**
     * Filter, which ProductVariant to fetch.
     */
    where: ProductVariantWhereUniqueInput
  }

  /**
   * ProductVariant findUnique
   */
  export interface ProductVariantFindUniqueArgs extends ProductVariantFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductVariant findUniqueOrThrow
   */
  export type ProductVariantFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductVariantInclude | null
    /**
     * Filter, which ProductVariant to fetch.
     */
    where: ProductVariantWhereUniqueInput
  }


  /**
   * ProductVariant base type for findFirst actions
   */
  export type ProductVariantFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductVariantInclude | null
    /**
     * Filter, which ProductVariant to fetch.
     */
    where?: ProductVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariants to fetch.
     */
    orderBy?: Enumerable<ProductVariantOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductVariants.
     */
    cursor?: ProductVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductVariants.
     */
    distinct?: Enumerable<ProductVariantScalarFieldEnum>
  }

  /**
   * ProductVariant findFirst
   */
  export interface ProductVariantFindFirstArgs extends ProductVariantFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductVariant findFirstOrThrow
   */
  export type ProductVariantFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductVariantInclude | null
    /**
     * Filter, which ProductVariant to fetch.
     */
    where?: ProductVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariants to fetch.
     */
    orderBy?: Enumerable<ProductVariantOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductVariants.
     */
    cursor?: ProductVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductVariants.
     */
    distinct?: Enumerable<ProductVariantScalarFieldEnum>
  }


  /**
   * ProductVariant findMany
   */
  export type ProductVariantFindManyArgs = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductVariantInclude | null
    /**
     * Filter, which ProductVariants to fetch.
     */
    where?: ProductVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariants to fetch.
     */
    orderBy?: Enumerable<ProductVariantOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductVariants.
     */
    cursor?: ProductVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariants.
     */
    skip?: number
    distinct?: Enumerable<ProductVariantScalarFieldEnum>
  }


  /**
   * ProductVariant create
   */
  export type ProductVariantCreateArgs = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductVariantInclude | null
    /**
     * The data needed to create a ProductVariant.
     */
    data: XOR<ProductVariantCreateInput, ProductVariantUncheckedCreateInput>
  }


  /**
   * ProductVariant createMany
   */
  export type ProductVariantCreateManyArgs = {
    /**
     * The data used to create many ProductVariants.
     */
    data: Enumerable<ProductVariantCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProductVariant update
   */
  export type ProductVariantUpdateArgs = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductVariantInclude | null
    /**
     * The data needed to update a ProductVariant.
     */
    data: XOR<ProductVariantUpdateInput, ProductVariantUncheckedUpdateInput>
    /**
     * Choose, which ProductVariant to update.
     */
    where: ProductVariantWhereUniqueInput
  }


  /**
   * ProductVariant updateMany
   */
  export type ProductVariantUpdateManyArgs = {
    /**
     * The data used to update ProductVariants.
     */
    data: XOR<ProductVariantUpdateManyMutationInput, ProductVariantUncheckedUpdateManyInput>
    /**
     * Filter which ProductVariants to update
     */
    where?: ProductVariantWhereInput
  }


  /**
   * ProductVariant upsert
   */
  export type ProductVariantUpsertArgs = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductVariantInclude | null
    /**
     * The filter to search for the ProductVariant to update in case it exists.
     */
    where: ProductVariantWhereUniqueInput
    /**
     * In case the ProductVariant found by the `where` argument doesn't exist, create a new ProductVariant with this data.
     */
    create: XOR<ProductVariantCreateInput, ProductVariantUncheckedCreateInput>
    /**
     * In case the ProductVariant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductVariantUpdateInput, ProductVariantUncheckedUpdateInput>
  }


  /**
   * ProductVariant delete
   */
  export type ProductVariantDeleteArgs = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductVariantInclude | null
    /**
     * Filter which ProductVariant to delete.
     */
    where: ProductVariantWhereUniqueInput
  }


  /**
   * ProductVariant deleteMany
   */
  export type ProductVariantDeleteManyArgs = {
    /**
     * Filter which ProductVariants to delete
     */
    where?: ProductVariantWhereInput
  }


  /**
   * ProductVariant.ProductPayment
   */
  export type ProductVariant$ProductPaymentArgs = {
    /**
     * Select specific fields to fetch from the ProductPayment
     */
    select?: ProductPaymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductPaymentInclude | null
    where?: ProductPaymentWhereInput
    orderBy?: Enumerable<ProductPaymentOrderByWithRelationInput>
    cursor?: ProductPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProductPaymentScalarFieldEnum>
  }


  /**
   * ProductVariant.QPayInvoice
   */
  export type ProductVariant$QPayInvoiceArgs = {
    /**
     * Select specific fields to fetch from the QPayInvoice
     */
    select?: QPayInvoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QPayInvoiceInclude | null
    where?: QPayInvoiceWhereInput
    orderBy?: Enumerable<QPayInvoiceOrderByWithRelationInput>
    cursor?: QPayInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<QPayInvoiceScalarFieldEnum>
  }


  /**
   * ProductVariant without action
   */
  export type ProductVariantArgs = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductVariantInclude | null
  }



  /**
   * Model ProductPayment
   */


  export type AggregateProductPayment = {
    _count: ProductPaymentCountAggregateOutputType | null
    _avg: ProductPaymentAvgAggregateOutputType | null
    _sum: ProductPaymentSumAggregateOutputType | null
    _min: ProductPaymentMinAggregateOutputType | null
    _max: ProductPaymentMaxAggregateOutputType | null
  }

  export type ProductPaymentAvgAggregateOutputType = {
    paidAmount: Decimal | null
  }

  export type ProductPaymentSumAggregateOutputType = {
    paidAmount: Decimal | null
  }

  export type ProductPaymentMinAggregateOutputType = {
    id: string | null
    paidSource: string | null
    paidAmount: Decimal | null
    paidDate: Date | null
    additionalNote: string | null
    productId: string | null
    productVariantId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    paymentStatus: string | null
  }

  export type ProductPaymentMaxAggregateOutputType = {
    id: string | null
    paidSource: string | null
    paidAmount: Decimal | null
    paidDate: Date | null
    additionalNote: string | null
    productId: string | null
    productVariantId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    paymentStatus: string | null
  }

  export type ProductPaymentCountAggregateOutputType = {
    id: number
    paidSource: number
    paidAmount: number
    paidDate: number
    additionalNote: number
    productId: number
    productVariantId: number
    userId: number
    createdAt: number
    updatedAt: number
    paymentStatus: number
    _all: number
  }


  export type ProductPaymentAvgAggregateInputType = {
    paidAmount?: true
  }

  export type ProductPaymentSumAggregateInputType = {
    paidAmount?: true
  }

  export type ProductPaymentMinAggregateInputType = {
    id?: true
    paidSource?: true
    paidAmount?: true
    paidDate?: true
    additionalNote?: true
    productId?: true
    productVariantId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    paymentStatus?: true
  }

  export type ProductPaymentMaxAggregateInputType = {
    id?: true
    paidSource?: true
    paidAmount?: true
    paidDate?: true
    additionalNote?: true
    productId?: true
    productVariantId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    paymentStatus?: true
  }

  export type ProductPaymentCountAggregateInputType = {
    id?: true
    paidSource?: true
    paidAmount?: true
    paidDate?: true
    additionalNote?: true
    productId?: true
    productVariantId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    paymentStatus?: true
    _all?: true
  }

  export type ProductPaymentAggregateArgs = {
    /**
     * Filter which ProductPayment to aggregate.
     */
    where?: ProductPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductPayments to fetch.
     */
    orderBy?: Enumerable<ProductPaymentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductPayments
    **/
    _count?: true | ProductPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductPaymentMaxAggregateInputType
  }

  export type GetProductPaymentAggregateType<T extends ProductPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateProductPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductPayment[P]>
      : GetScalarType<T[P], AggregateProductPayment[P]>
  }




  export type ProductPaymentGroupByArgs = {
    where?: ProductPaymentWhereInput
    orderBy?: Enumerable<ProductPaymentOrderByWithAggregationInput>
    by: ProductPaymentScalarFieldEnum[]
    having?: ProductPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductPaymentCountAggregateInputType | true
    _avg?: ProductPaymentAvgAggregateInputType
    _sum?: ProductPaymentSumAggregateInputType
    _min?: ProductPaymentMinAggregateInputType
    _max?: ProductPaymentMaxAggregateInputType
  }


  export type ProductPaymentGroupByOutputType = {
    id: string
    paidSource: string | null
    paidAmount: Decimal | null
    paidDate: Date | null
    additionalNote: string
    productId: string
    productVariantId: string
    userId: string
    createdAt: Date
    updatedAt: Date
    paymentStatus: string
    _count: ProductPaymentCountAggregateOutputType | null
    _avg: ProductPaymentAvgAggregateOutputType | null
    _sum: ProductPaymentSumAggregateOutputType | null
    _min: ProductPaymentMinAggregateOutputType | null
    _max: ProductPaymentMaxAggregateOutputType | null
  }

  type GetProductPaymentGroupByPayload<T extends ProductPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProductPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], ProductPaymentGroupByOutputType[P]>
        }
      >
    >


  export type ProductPaymentSelect = {
    id?: boolean
    paidSource?: boolean
    paidAmount?: boolean
    paidDate?: boolean
    additionalNote?: boolean
    productId?: boolean
    productVariantId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paymentStatus?: boolean
    Product?: boolean | ProductArgs
    ProductVariant?: boolean | ProductVariantArgs
    User?: boolean | UserArgs
  }


  export type ProductPaymentInclude = {
    Product?: boolean | ProductArgs
    ProductVariant?: boolean | ProductVariantArgs
    User?: boolean | UserArgs
  }

  export type ProductPaymentGetPayload<S extends boolean | null | undefined | ProductPaymentArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ProductPayment :
    S extends undefined ? never :
    S extends { include: any } & (ProductPaymentArgs | ProductPaymentFindManyArgs)
    ? ProductPayment  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Product' ? ProductGetPayload<S['include'][P]> :
        P extends 'ProductVariant' ? ProductVariantGetPayload<S['include'][P]> :
        P extends 'User' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ProductPaymentArgs | ProductPaymentFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Product' ? ProductGetPayload<S['select'][P]> :
        P extends 'ProductVariant' ? ProductVariantGetPayload<S['select'][P]> :
        P extends 'User' ? UserGetPayload<S['select'][P]> :  P extends keyof ProductPayment ? ProductPayment[P] : never
  } 
      : ProductPayment


  type ProductPaymentCountArgs = 
    Omit<ProductPaymentFindManyArgs, 'select' | 'include'> & {
      select?: ProductPaymentCountAggregateInputType | true
    }

  export interface ProductPaymentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ProductPayment that matches the filter.
     * @param {ProductPaymentFindUniqueArgs} args - Arguments to find a ProductPayment
     * @example
     * // Get one ProductPayment
     * const productPayment = await prisma.productPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductPaymentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductPaymentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProductPayment'> extends True ? Prisma__ProductPaymentClient<ProductPaymentGetPayload<T>> : Prisma__ProductPaymentClient<ProductPaymentGetPayload<T> | null, null>

    /**
     * Find one ProductPayment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductPaymentFindUniqueOrThrowArgs} args - Arguments to find a ProductPayment
     * @example
     * // Get one ProductPayment
     * const productPayment = await prisma.productPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductPaymentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ProductPaymentFindUniqueOrThrowArgs>
    ): Prisma__ProductPaymentClient<ProductPaymentGetPayload<T>>

    /**
     * Find the first ProductPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPaymentFindFirstArgs} args - Arguments to find a ProductPayment
     * @example
     * // Get one ProductPayment
     * const productPayment = await prisma.productPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductPaymentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductPaymentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProductPayment'> extends True ? Prisma__ProductPaymentClient<ProductPaymentGetPayload<T>> : Prisma__ProductPaymentClient<ProductPaymentGetPayload<T> | null, null>

    /**
     * Find the first ProductPayment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPaymentFindFirstOrThrowArgs} args - Arguments to find a ProductPayment
     * @example
     * // Get one ProductPayment
     * const productPayment = await prisma.productPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductPaymentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProductPaymentFindFirstOrThrowArgs>
    ): Prisma__ProductPaymentClient<ProductPaymentGetPayload<T>>

    /**
     * Find zero or more ProductPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPaymentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductPayments
     * const productPayments = await prisma.productPayment.findMany()
     * 
     * // Get first 10 ProductPayments
     * const productPayments = await prisma.productPayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productPaymentWithIdOnly = await prisma.productPayment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductPaymentFindManyArgs>(
      args?: SelectSubset<T, ProductPaymentFindManyArgs>
    ): Prisma.PrismaPromise<Array<ProductPaymentGetPayload<T>>>

    /**
     * Create a ProductPayment.
     * @param {ProductPaymentCreateArgs} args - Arguments to create a ProductPayment.
     * @example
     * // Create one ProductPayment
     * const ProductPayment = await prisma.productPayment.create({
     *   data: {
     *     // ... data to create a ProductPayment
     *   }
     * })
     * 
    **/
    create<T extends ProductPaymentCreateArgs>(
      args: SelectSubset<T, ProductPaymentCreateArgs>
    ): Prisma__ProductPaymentClient<ProductPaymentGetPayload<T>>

    /**
     * Create many ProductPayments.
     *     @param {ProductPaymentCreateManyArgs} args - Arguments to create many ProductPayments.
     *     @example
     *     // Create many ProductPayments
     *     const productPayment = await prisma.productPayment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductPaymentCreateManyArgs>(
      args?: SelectSubset<T, ProductPaymentCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductPayment.
     * @param {ProductPaymentDeleteArgs} args - Arguments to delete one ProductPayment.
     * @example
     * // Delete one ProductPayment
     * const ProductPayment = await prisma.productPayment.delete({
     *   where: {
     *     // ... filter to delete one ProductPayment
     *   }
     * })
     * 
    **/
    delete<T extends ProductPaymentDeleteArgs>(
      args: SelectSubset<T, ProductPaymentDeleteArgs>
    ): Prisma__ProductPaymentClient<ProductPaymentGetPayload<T>>

    /**
     * Update one ProductPayment.
     * @param {ProductPaymentUpdateArgs} args - Arguments to update one ProductPayment.
     * @example
     * // Update one ProductPayment
     * const productPayment = await prisma.productPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductPaymentUpdateArgs>(
      args: SelectSubset<T, ProductPaymentUpdateArgs>
    ): Prisma__ProductPaymentClient<ProductPaymentGetPayload<T>>

    /**
     * Delete zero or more ProductPayments.
     * @param {ProductPaymentDeleteManyArgs} args - Arguments to filter ProductPayments to delete.
     * @example
     * // Delete a few ProductPayments
     * const { count } = await prisma.productPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductPaymentDeleteManyArgs>(
      args?: SelectSubset<T, ProductPaymentDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductPayments
     * const productPayment = await prisma.productPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductPaymentUpdateManyArgs>(
      args: SelectSubset<T, ProductPaymentUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductPayment.
     * @param {ProductPaymentUpsertArgs} args - Arguments to update or create a ProductPayment.
     * @example
     * // Update or create a ProductPayment
     * const productPayment = await prisma.productPayment.upsert({
     *   create: {
     *     // ... data to create a ProductPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductPayment we want to update
     *   }
     * })
    **/
    upsert<T extends ProductPaymentUpsertArgs>(
      args: SelectSubset<T, ProductPaymentUpsertArgs>
    ): Prisma__ProductPaymentClient<ProductPaymentGetPayload<T>>

    /**
     * Count the number of ProductPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPaymentCountArgs} args - Arguments to filter ProductPayments to count.
     * @example
     * // Count the number of ProductPayments
     * const count = await prisma.productPayment.count({
     *   where: {
     *     // ... the filter for the ProductPayments we want to count
     *   }
     * })
    **/
    count<T extends ProductPaymentCountArgs>(
      args?: Subset<T, ProductPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductPaymentAggregateArgs>(args: Subset<T, ProductPaymentAggregateArgs>): Prisma.PrismaPromise<GetProductPaymentAggregateType<T>>

    /**
     * Group by ProductPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductPaymentGroupByArgs['orderBy'] }
        : { orderBy?: ProductPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductPaymentClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Product<T extends ProductArgs= {}>(args?: Subset<T, ProductArgs>): Prisma__ProductClient<ProductGetPayload<T> | Null>;

    ProductVariant<T extends ProductVariantArgs= {}>(args?: Subset<T, ProductVariantArgs>): Prisma__ProductVariantClient<ProductVariantGetPayload<T> | Null>;

    User<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ProductPayment base type for findUnique actions
   */
  export type ProductPaymentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ProductPayment
     */
    select?: ProductPaymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductPaymentInclude | null
    /**
     * Filter, which ProductPayment to fetch.
     */
    where: ProductPaymentWhereUniqueInput
  }

  /**
   * ProductPayment findUnique
   */
  export interface ProductPaymentFindUniqueArgs extends ProductPaymentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductPayment findUniqueOrThrow
   */
  export type ProductPaymentFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ProductPayment
     */
    select?: ProductPaymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductPaymentInclude | null
    /**
     * Filter, which ProductPayment to fetch.
     */
    where: ProductPaymentWhereUniqueInput
  }


  /**
   * ProductPayment base type for findFirst actions
   */
  export type ProductPaymentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ProductPayment
     */
    select?: ProductPaymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductPaymentInclude | null
    /**
     * Filter, which ProductPayment to fetch.
     */
    where?: ProductPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductPayments to fetch.
     */
    orderBy?: Enumerable<ProductPaymentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductPayments.
     */
    cursor?: ProductPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductPayments.
     */
    distinct?: Enumerable<ProductPaymentScalarFieldEnum>
  }

  /**
   * ProductPayment findFirst
   */
  export interface ProductPaymentFindFirstArgs extends ProductPaymentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductPayment findFirstOrThrow
   */
  export type ProductPaymentFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ProductPayment
     */
    select?: ProductPaymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductPaymentInclude | null
    /**
     * Filter, which ProductPayment to fetch.
     */
    where?: ProductPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductPayments to fetch.
     */
    orderBy?: Enumerable<ProductPaymentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductPayments.
     */
    cursor?: ProductPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductPayments.
     */
    distinct?: Enumerable<ProductPaymentScalarFieldEnum>
  }


  /**
   * ProductPayment findMany
   */
  export type ProductPaymentFindManyArgs = {
    /**
     * Select specific fields to fetch from the ProductPayment
     */
    select?: ProductPaymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductPaymentInclude | null
    /**
     * Filter, which ProductPayments to fetch.
     */
    where?: ProductPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductPayments to fetch.
     */
    orderBy?: Enumerable<ProductPaymentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductPayments.
     */
    cursor?: ProductPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductPayments.
     */
    skip?: number
    distinct?: Enumerable<ProductPaymentScalarFieldEnum>
  }


  /**
   * ProductPayment create
   */
  export type ProductPaymentCreateArgs = {
    /**
     * Select specific fields to fetch from the ProductPayment
     */
    select?: ProductPaymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductPaymentInclude | null
    /**
     * The data needed to create a ProductPayment.
     */
    data: XOR<ProductPaymentCreateInput, ProductPaymentUncheckedCreateInput>
  }


  /**
   * ProductPayment createMany
   */
  export type ProductPaymentCreateManyArgs = {
    /**
     * The data used to create many ProductPayments.
     */
    data: Enumerable<ProductPaymentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProductPayment update
   */
  export type ProductPaymentUpdateArgs = {
    /**
     * Select specific fields to fetch from the ProductPayment
     */
    select?: ProductPaymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductPaymentInclude | null
    /**
     * The data needed to update a ProductPayment.
     */
    data: XOR<ProductPaymentUpdateInput, ProductPaymentUncheckedUpdateInput>
    /**
     * Choose, which ProductPayment to update.
     */
    where: ProductPaymentWhereUniqueInput
  }


  /**
   * ProductPayment updateMany
   */
  export type ProductPaymentUpdateManyArgs = {
    /**
     * The data used to update ProductPayments.
     */
    data: XOR<ProductPaymentUpdateManyMutationInput, ProductPaymentUncheckedUpdateManyInput>
    /**
     * Filter which ProductPayments to update
     */
    where?: ProductPaymentWhereInput
  }


  /**
   * ProductPayment upsert
   */
  export type ProductPaymentUpsertArgs = {
    /**
     * Select specific fields to fetch from the ProductPayment
     */
    select?: ProductPaymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductPaymentInclude | null
    /**
     * The filter to search for the ProductPayment to update in case it exists.
     */
    where: ProductPaymentWhereUniqueInput
    /**
     * In case the ProductPayment found by the `where` argument doesn't exist, create a new ProductPayment with this data.
     */
    create: XOR<ProductPaymentCreateInput, ProductPaymentUncheckedCreateInput>
    /**
     * In case the ProductPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductPaymentUpdateInput, ProductPaymentUncheckedUpdateInput>
  }


  /**
   * ProductPayment delete
   */
  export type ProductPaymentDeleteArgs = {
    /**
     * Select specific fields to fetch from the ProductPayment
     */
    select?: ProductPaymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductPaymentInclude | null
    /**
     * Filter which ProductPayment to delete.
     */
    where: ProductPaymentWhereUniqueInput
  }


  /**
   * ProductPayment deleteMany
   */
  export type ProductPaymentDeleteManyArgs = {
    /**
     * Filter which ProductPayments to delete
     */
    where?: ProductPaymentWhereInput
  }


  /**
   * ProductPayment without action
   */
  export type ProductPaymentArgs = {
    /**
     * Select specific fields to fetch from the ProductPayment
     */
    select?: ProductPaymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductPaymentInclude | null
  }



  /**
   * Model QPayInvoice
   */


  export type AggregateQPayInvoice = {
    _count: QPayInvoiceCountAggregateOutputType | null
    _min: QPayInvoiceMinAggregateOutputType | null
    _max: QPayInvoiceMaxAggregateOutputType | null
  }

  export type QPayInvoiceMinAggregateOutputType = {
    id: string | null
    productId: string | null
    productVariantId: string | null
    userId: string | null
    payedDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QPayInvoiceMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    productVariantId: string | null
    userId: string | null
    payedDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QPayInvoiceCountAggregateOutputType = {
    id: number
    productId: number
    productVariantId: number
    invoiceData: number
    userId: number
    payedDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QPayInvoiceMinAggregateInputType = {
    id?: true
    productId?: true
    productVariantId?: true
    userId?: true
    payedDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QPayInvoiceMaxAggregateInputType = {
    id?: true
    productId?: true
    productVariantId?: true
    userId?: true
    payedDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QPayInvoiceCountAggregateInputType = {
    id?: true
    productId?: true
    productVariantId?: true
    invoiceData?: true
    userId?: true
    payedDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QPayInvoiceAggregateArgs = {
    /**
     * Filter which QPayInvoice to aggregate.
     */
    where?: QPayInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QPayInvoices to fetch.
     */
    orderBy?: Enumerable<QPayInvoiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QPayInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QPayInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QPayInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QPayInvoices
    **/
    _count?: true | QPayInvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QPayInvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QPayInvoiceMaxAggregateInputType
  }

  export type GetQPayInvoiceAggregateType<T extends QPayInvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateQPayInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQPayInvoice[P]>
      : GetScalarType<T[P], AggregateQPayInvoice[P]>
  }




  export type QPayInvoiceGroupByArgs = {
    where?: QPayInvoiceWhereInput
    orderBy?: Enumerable<QPayInvoiceOrderByWithAggregationInput>
    by: QPayInvoiceScalarFieldEnum[]
    having?: QPayInvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QPayInvoiceCountAggregateInputType | true
    _min?: QPayInvoiceMinAggregateInputType
    _max?: QPayInvoiceMaxAggregateInputType
  }


  export type QPayInvoiceGroupByOutputType = {
    id: string
    productId: string
    productVariantId: string
    invoiceData: JsonValue | null
    userId: string | null
    payedDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: QPayInvoiceCountAggregateOutputType | null
    _min: QPayInvoiceMinAggregateOutputType | null
    _max: QPayInvoiceMaxAggregateOutputType | null
  }

  type GetQPayInvoiceGroupByPayload<T extends QPayInvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<QPayInvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QPayInvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QPayInvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], QPayInvoiceGroupByOutputType[P]>
        }
      >
    >


  export type QPayInvoiceSelect = {
    id?: boolean
    productId?: boolean
    productVariantId?: boolean
    invoiceData?: boolean
    userId?: boolean
    payedDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Product?: boolean | ProductArgs
    ProductVariant?: boolean | ProductVariantArgs
    user?: boolean | UserArgs
  }


  export type QPayInvoiceInclude = {
    Product?: boolean | ProductArgs
    ProductVariant?: boolean | ProductVariantArgs
    user?: boolean | UserArgs
  }

  export type QPayInvoiceGetPayload<S extends boolean | null | undefined | QPayInvoiceArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? QPayInvoice :
    S extends undefined ? never :
    S extends { include: any } & (QPayInvoiceArgs | QPayInvoiceFindManyArgs)
    ? QPayInvoice  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Product' ? ProductGetPayload<S['include'][P]> :
        P extends 'ProductVariant' ? ProductVariantGetPayload<S['include'][P]> :
        P extends 'user' ? UserGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (QPayInvoiceArgs | QPayInvoiceFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Product' ? ProductGetPayload<S['select'][P]> :
        P extends 'ProductVariant' ? ProductVariantGetPayload<S['select'][P]> :
        P extends 'user' ? UserGetPayload<S['select'][P]> | null :  P extends keyof QPayInvoice ? QPayInvoice[P] : never
  } 
      : QPayInvoice


  type QPayInvoiceCountArgs = 
    Omit<QPayInvoiceFindManyArgs, 'select' | 'include'> & {
      select?: QPayInvoiceCountAggregateInputType | true
    }

  export interface QPayInvoiceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one QPayInvoice that matches the filter.
     * @param {QPayInvoiceFindUniqueArgs} args - Arguments to find a QPayInvoice
     * @example
     * // Get one QPayInvoice
     * const qPayInvoice = await prisma.qPayInvoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QPayInvoiceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, QPayInvoiceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'QPayInvoice'> extends True ? Prisma__QPayInvoiceClient<QPayInvoiceGetPayload<T>> : Prisma__QPayInvoiceClient<QPayInvoiceGetPayload<T> | null, null>

    /**
     * Find one QPayInvoice that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {QPayInvoiceFindUniqueOrThrowArgs} args - Arguments to find a QPayInvoice
     * @example
     * // Get one QPayInvoice
     * const qPayInvoice = await prisma.qPayInvoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends QPayInvoiceFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, QPayInvoiceFindUniqueOrThrowArgs>
    ): Prisma__QPayInvoiceClient<QPayInvoiceGetPayload<T>>

    /**
     * Find the first QPayInvoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QPayInvoiceFindFirstArgs} args - Arguments to find a QPayInvoice
     * @example
     * // Get one QPayInvoice
     * const qPayInvoice = await prisma.qPayInvoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QPayInvoiceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, QPayInvoiceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'QPayInvoice'> extends True ? Prisma__QPayInvoiceClient<QPayInvoiceGetPayload<T>> : Prisma__QPayInvoiceClient<QPayInvoiceGetPayload<T> | null, null>

    /**
     * Find the first QPayInvoice that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QPayInvoiceFindFirstOrThrowArgs} args - Arguments to find a QPayInvoice
     * @example
     * // Get one QPayInvoice
     * const qPayInvoice = await prisma.qPayInvoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends QPayInvoiceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, QPayInvoiceFindFirstOrThrowArgs>
    ): Prisma__QPayInvoiceClient<QPayInvoiceGetPayload<T>>

    /**
     * Find zero or more QPayInvoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QPayInvoiceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QPayInvoices
     * const qPayInvoices = await prisma.qPayInvoice.findMany()
     * 
     * // Get first 10 QPayInvoices
     * const qPayInvoices = await prisma.qPayInvoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const qPayInvoiceWithIdOnly = await prisma.qPayInvoice.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends QPayInvoiceFindManyArgs>(
      args?: SelectSubset<T, QPayInvoiceFindManyArgs>
    ): Prisma.PrismaPromise<Array<QPayInvoiceGetPayload<T>>>

    /**
     * Create a QPayInvoice.
     * @param {QPayInvoiceCreateArgs} args - Arguments to create a QPayInvoice.
     * @example
     * // Create one QPayInvoice
     * const QPayInvoice = await prisma.qPayInvoice.create({
     *   data: {
     *     // ... data to create a QPayInvoice
     *   }
     * })
     * 
    **/
    create<T extends QPayInvoiceCreateArgs>(
      args: SelectSubset<T, QPayInvoiceCreateArgs>
    ): Prisma__QPayInvoiceClient<QPayInvoiceGetPayload<T>>

    /**
     * Create many QPayInvoices.
     *     @param {QPayInvoiceCreateManyArgs} args - Arguments to create many QPayInvoices.
     *     @example
     *     // Create many QPayInvoices
     *     const qPayInvoice = await prisma.qPayInvoice.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends QPayInvoiceCreateManyArgs>(
      args?: SelectSubset<T, QPayInvoiceCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QPayInvoice.
     * @param {QPayInvoiceDeleteArgs} args - Arguments to delete one QPayInvoice.
     * @example
     * // Delete one QPayInvoice
     * const QPayInvoice = await prisma.qPayInvoice.delete({
     *   where: {
     *     // ... filter to delete one QPayInvoice
     *   }
     * })
     * 
    **/
    delete<T extends QPayInvoiceDeleteArgs>(
      args: SelectSubset<T, QPayInvoiceDeleteArgs>
    ): Prisma__QPayInvoiceClient<QPayInvoiceGetPayload<T>>

    /**
     * Update one QPayInvoice.
     * @param {QPayInvoiceUpdateArgs} args - Arguments to update one QPayInvoice.
     * @example
     * // Update one QPayInvoice
     * const qPayInvoice = await prisma.qPayInvoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QPayInvoiceUpdateArgs>(
      args: SelectSubset<T, QPayInvoiceUpdateArgs>
    ): Prisma__QPayInvoiceClient<QPayInvoiceGetPayload<T>>

    /**
     * Delete zero or more QPayInvoices.
     * @param {QPayInvoiceDeleteManyArgs} args - Arguments to filter QPayInvoices to delete.
     * @example
     * // Delete a few QPayInvoices
     * const { count } = await prisma.qPayInvoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QPayInvoiceDeleteManyArgs>(
      args?: SelectSubset<T, QPayInvoiceDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QPayInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QPayInvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QPayInvoices
     * const qPayInvoice = await prisma.qPayInvoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QPayInvoiceUpdateManyArgs>(
      args: SelectSubset<T, QPayInvoiceUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QPayInvoice.
     * @param {QPayInvoiceUpsertArgs} args - Arguments to update or create a QPayInvoice.
     * @example
     * // Update or create a QPayInvoice
     * const qPayInvoice = await prisma.qPayInvoice.upsert({
     *   create: {
     *     // ... data to create a QPayInvoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QPayInvoice we want to update
     *   }
     * })
    **/
    upsert<T extends QPayInvoiceUpsertArgs>(
      args: SelectSubset<T, QPayInvoiceUpsertArgs>
    ): Prisma__QPayInvoiceClient<QPayInvoiceGetPayload<T>>

    /**
     * Count the number of QPayInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QPayInvoiceCountArgs} args - Arguments to filter QPayInvoices to count.
     * @example
     * // Count the number of QPayInvoices
     * const count = await prisma.qPayInvoice.count({
     *   where: {
     *     // ... the filter for the QPayInvoices we want to count
     *   }
     * })
    **/
    count<T extends QPayInvoiceCountArgs>(
      args?: Subset<T, QPayInvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QPayInvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QPayInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QPayInvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QPayInvoiceAggregateArgs>(args: Subset<T, QPayInvoiceAggregateArgs>): Prisma.PrismaPromise<GetQPayInvoiceAggregateType<T>>

    /**
     * Group by QPayInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QPayInvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QPayInvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QPayInvoiceGroupByArgs['orderBy'] }
        : { orderBy?: QPayInvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QPayInvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQPayInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for QPayInvoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__QPayInvoiceClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Product<T extends ProductArgs= {}>(args?: Subset<T, ProductArgs>): Prisma__ProductClient<ProductGetPayload<T> | Null>;

    ProductVariant<T extends ProductVariantArgs= {}>(args?: Subset<T, ProductVariantArgs>): Prisma__ProductVariantClient<ProductVariantGetPayload<T> | Null>;

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * QPayInvoice base type for findUnique actions
   */
  export type QPayInvoiceFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the QPayInvoice
     */
    select?: QPayInvoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QPayInvoiceInclude | null
    /**
     * Filter, which QPayInvoice to fetch.
     */
    where: QPayInvoiceWhereUniqueInput
  }

  /**
   * QPayInvoice findUnique
   */
  export interface QPayInvoiceFindUniqueArgs extends QPayInvoiceFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QPayInvoice findUniqueOrThrow
   */
  export type QPayInvoiceFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the QPayInvoice
     */
    select?: QPayInvoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QPayInvoiceInclude | null
    /**
     * Filter, which QPayInvoice to fetch.
     */
    where: QPayInvoiceWhereUniqueInput
  }


  /**
   * QPayInvoice base type for findFirst actions
   */
  export type QPayInvoiceFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the QPayInvoice
     */
    select?: QPayInvoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QPayInvoiceInclude | null
    /**
     * Filter, which QPayInvoice to fetch.
     */
    where?: QPayInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QPayInvoices to fetch.
     */
    orderBy?: Enumerable<QPayInvoiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QPayInvoices.
     */
    cursor?: QPayInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QPayInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QPayInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QPayInvoices.
     */
    distinct?: Enumerable<QPayInvoiceScalarFieldEnum>
  }

  /**
   * QPayInvoice findFirst
   */
  export interface QPayInvoiceFindFirstArgs extends QPayInvoiceFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QPayInvoice findFirstOrThrow
   */
  export type QPayInvoiceFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the QPayInvoice
     */
    select?: QPayInvoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QPayInvoiceInclude | null
    /**
     * Filter, which QPayInvoice to fetch.
     */
    where?: QPayInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QPayInvoices to fetch.
     */
    orderBy?: Enumerable<QPayInvoiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QPayInvoices.
     */
    cursor?: QPayInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QPayInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QPayInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QPayInvoices.
     */
    distinct?: Enumerable<QPayInvoiceScalarFieldEnum>
  }


  /**
   * QPayInvoice findMany
   */
  export type QPayInvoiceFindManyArgs = {
    /**
     * Select specific fields to fetch from the QPayInvoice
     */
    select?: QPayInvoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QPayInvoiceInclude | null
    /**
     * Filter, which QPayInvoices to fetch.
     */
    where?: QPayInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QPayInvoices to fetch.
     */
    orderBy?: Enumerable<QPayInvoiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QPayInvoices.
     */
    cursor?: QPayInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QPayInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QPayInvoices.
     */
    skip?: number
    distinct?: Enumerable<QPayInvoiceScalarFieldEnum>
  }


  /**
   * QPayInvoice create
   */
  export type QPayInvoiceCreateArgs = {
    /**
     * Select specific fields to fetch from the QPayInvoice
     */
    select?: QPayInvoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QPayInvoiceInclude | null
    /**
     * The data needed to create a QPayInvoice.
     */
    data: XOR<QPayInvoiceCreateInput, QPayInvoiceUncheckedCreateInput>
  }


  /**
   * QPayInvoice createMany
   */
  export type QPayInvoiceCreateManyArgs = {
    /**
     * The data used to create many QPayInvoices.
     */
    data: Enumerable<QPayInvoiceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * QPayInvoice update
   */
  export type QPayInvoiceUpdateArgs = {
    /**
     * Select specific fields to fetch from the QPayInvoice
     */
    select?: QPayInvoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QPayInvoiceInclude | null
    /**
     * The data needed to update a QPayInvoice.
     */
    data: XOR<QPayInvoiceUpdateInput, QPayInvoiceUncheckedUpdateInput>
    /**
     * Choose, which QPayInvoice to update.
     */
    where: QPayInvoiceWhereUniqueInput
  }


  /**
   * QPayInvoice updateMany
   */
  export type QPayInvoiceUpdateManyArgs = {
    /**
     * The data used to update QPayInvoices.
     */
    data: XOR<QPayInvoiceUpdateManyMutationInput, QPayInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which QPayInvoices to update
     */
    where?: QPayInvoiceWhereInput
  }


  /**
   * QPayInvoice upsert
   */
  export type QPayInvoiceUpsertArgs = {
    /**
     * Select specific fields to fetch from the QPayInvoice
     */
    select?: QPayInvoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QPayInvoiceInclude | null
    /**
     * The filter to search for the QPayInvoice to update in case it exists.
     */
    where: QPayInvoiceWhereUniqueInput
    /**
     * In case the QPayInvoice found by the `where` argument doesn't exist, create a new QPayInvoice with this data.
     */
    create: XOR<QPayInvoiceCreateInput, QPayInvoiceUncheckedCreateInput>
    /**
     * In case the QPayInvoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QPayInvoiceUpdateInput, QPayInvoiceUncheckedUpdateInput>
  }


  /**
   * QPayInvoice delete
   */
  export type QPayInvoiceDeleteArgs = {
    /**
     * Select specific fields to fetch from the QPayInvoice
     */
    select?: QPayInvoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QPayInvoiceInclude | null
    /**
     * Filter which QPayInvoice to delete.
     */
    where: QPayInvoiceWhereUniqueInput
  }


  /**
   * QPayInvoice deleteMany
   */
  export type QPayInvoiceDeleteManyArgs = {
    /**
     * Filter which QPayInvoices to delete
     */
    where?: QPayInvoiceWhereInput
  }


  /**
   * QPayInvoice without action
   */
  export type QPayInvoiceArgs = {
    /**
     * Select specific fields to fetch from the QPayInvoice
     */
    select?: QPayInvoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QPayInvoiceInclude | null
  }



  /**
   * Model Message
   */


  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    phoneNumber: string | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
    hospitalId: string | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    phoneNumber: string | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
    hospitalId: string | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    phoneNumber: number
    message: number
    createdAt: number
    updatedAt: number
    hospitalId: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    phoneNumber?: true
    message?: true
    createdAt?: true
    updatedAt?: true
    hospitalId?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    phoneNumber?: true
    message?: true
    createdAt?: true
    updatedAt?: true
    hospitalId?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    phoneNumber?: true
    message?: true
    createdAt?: true
    updatedAt?: true
    hospitalId?: true
    _all?: true
  }

  export type MessageAggregateArgs = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: Enumerable<MessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs = {
    where?: MessageWhereInput
    orderBy?: Enumerable<MessageOrderByWithAggregationInput>
    by: MessageScalarFieldEnum[]
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }


  export type MessageGroupByOutputType = {
    id: string
    phoneNumber: string
    message: string
    createdAt: Date
    updatedAt: Date
    hospitalId: string
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect = {
    id?: boolean
    phoneNumber?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hospitalId?: boolean
    hospital?: boolean | HospitalArgs
  }


  export type MessageInclude = {
    hospital?: boolean | HospitalArgs
  }

  export type MessageGetPayload<S extends boolean | null | undefined | MessageArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Message :
    S extends undefined ? never :
    S extends { include: any } & (MessageArgs | MessageFindManyArgs)
    ? Message  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'hospital' ? HospitalGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (MessageArgs | MessageFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'hospital' ? HospitalGetPayload<S['select'][P]> :  P extends keyof Message ? Message[P] : never
  } 
      : Message


  type MessageCountArgs = 
    Omit<MessageFindManyArgs, 'select' | 'include'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MessageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MessageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Message'> extends True ? Prisma__MessageClient<MessageGetPayload<T>> : Prisma__MessageClient<MessageGetPayload<T> | null, null>

    /**
     * Find one Message that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MessageFindUniqueOrThrowArgs>
    ): Prisma__MessageClient<MessageGetPayload<T>>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MessageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MessageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Message'> extends True ? Prisma__MessageClient<MessageGetPayload<T>> : Prisma__MessageClient<MessageGetPayload<T> | null, null>

    /**
     * Find the first Message that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MessageFindFirstOrThrowArgs>
    ): Prisma__MessageClient<MessageGetPayload<T>>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MessageFindManyArgs>(
      args?: SelectSubset<T, MessageFindManyArgs>
    ): Prisma.PrismaPromise<Array<MessageGetPayload<T>>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
    **/
    create<T extends MessageCreateArgs>(
      args: SelectSubset<T, MessageCreateArgs>
    ): Prisma__MessageClient<MessageGetPayload<T>>

    /**
     * Create many Messages.
     *     @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     *     @example
     *     // Create many Messages
     *     const message = await prisma.message.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MessageCreateManyArgs>(
      args?: SelectSubset<T, MessageCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
    **/
    delete<T extends MessageDeleteArgs>(
      args: SelectSubset<T, MessageDeleteArgs>
    ): Prisma__MessageClient<MessageGetPayload<T>>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MessageUpdateArgs>(
      args: SelectSubset<T, MessageUpdateArgs>
    ): Prisma__MessageClient<MessageGetPayload<T>>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MessageDeleteManyArgs>(
      args?: SelectSubset<T, MessageDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MessageUpdateManyArgs>(
      args: SelectSubset<T, MessageUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
    **/
    upsert<T extends MessageUpsertArgs>(
      args: SelectSubset<T, MessageUpsertArgs>
    ): Prisma__MessageClient<MessageGetPayload<T>>

    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MessageClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    hospital<T extends HospitalArgs= {}>(args?: Subset<T, HospitalArgs>): Prisma__HospitalClient<HospitalGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Message base type for findUnique actions
   */
  export type MessageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUnique
   */
  export interface MessageFindUniqueArgs extends MessageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }


  /**
   * Message base type for findFirst actions
   */
  export type MessageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: Enumerable<MessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: Enumerable<MessageScalarFieldEnum>
  }

  /**
   * Message findFirst
   */
  export interface MessageFindFirstArgs extends MessageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: Enumerable<MessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: Enumerable<MessageScalarFieldEnum>
  }


  /**
   * Message findMany
   */
  export type MessageFindManyArgs = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: Enumerable<MessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: Enumerable<MessageScalarFieldEnum>
  }


  /**
   * Message create
   */
  export type MessageCreateArgs = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }


  /**
   * Message createMany
   */
  export type MessageCreateManyArgs = {
    /**
     * The data used to create many Messages.
     */
    data: Enumerable<MessageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Message update
   */
  export type MessageUpdateArgs = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }


  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
  }


  /**
   * Message upsert
   */
  export type MessageUpsertArgs = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }


  /**
   * Message delete
   */
  export type MessageDeleteArgs = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }


  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
  }


  /**
   * Message without action
   */
  export type MessageArgs = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude | null
  }



  /**
   * Model PromoCode
   */


  export type AggregatePromoCode = {
    _count: PromoCodeCountAggregateOutputType | null
    _avg: PromoCodeAvgAggregateOutputType | null
    _sum: PromoCodeSumAggregateOutputType | null
    _min: PromoCodeMinAggregateOutputType | null
    _max: PromoCodeMaxAggregateOutputType | null
  }

  export type PromoCodeAvgAggregateOutputType = {
    fixedAmount: Decimal | null
    percentageAmount: Decimal | null
    maxUses: number | null
  }

  export type PromoCodeSumAggregateOutputType = {
    fixedAmount: Decimal | null
    percentageAmount: Decimal | null
    maxUses: number | null
  }

  export type PromoCodeMinAggregateOutputType = {
    id: string | null
    code: string | null
    promoImageUrl: string | null
    description: string | null
    expiryDate: Date | null
    isActive: boolean | null
    fixedAmount: Decimal | null
    percentageAmount: Decimal | null
    maxUses: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PromoCodeMaxAggregateOutputType = {
    id: string | null
    code: string | null
    promoImageUrl: string | null
    description: string | null
    expiryDate: Date | null
    isActive: boolean | null
    fixedAmount: Decimal | null
    percentageAmount: Decimal | null
    maxUses: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PromoCodeCountAggregateOutputType = {
    id: number
    code: number
    promoImageUrl: number
    description: number
    expiryDate: number
    isActive: number
    fixedAmount: number
    percentageAmount: number
    maxUses: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PromoCodeAvgAggregateInputType = {
    fixedAmount?: true
    percentageAmount?: true
    maxUses?: true
  }

  export type PromoCodeSumAggregateInputType = {
    fixedAmount?: true
    percentageAmount?: true
    maxUses?: true
  }

  export type PromoCodeMinAggregateInputType = {
    id?: true
    code?: true
    promoImageUrl?: true
    description?: true
    expiryDate?: true
    isActive?: true
    fixedAmount?: true
    percentageAmount?: true
    maxUses?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PromoCodeMaxAggregateInputType = {
    id?: true
    code?: true
    promoImageUrl?: true
    description?: true
    expiryDate?: true
    isActive?: true
    fixedAmount?: true
    percentageAmount?: true
    maxUses?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PromoCodeCountAggregateInputType = {
    id?: true
    code?: true
    promoImageUrl?: true
    description?: true
    expiryDate?: true
    isActive?: true
    fixedAmount?: true
    percentageAmount?: true
    maxUses?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PromoCodeAggregateArgs = {
    /**
     * Filter which PromoCode to aggregate.
     */
    where?: PromoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodes to fetch.
     */
    orderBy?: Enumerable<PromoCodeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PromoCodes
    **/
    _count?: true | PromoCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PromoCodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PromoCodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromoCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromoCodeMaxAggregateInputType
  }

  export type GetPromoCodeAggregateType<T extends PromoCodeAggregateArgs> = {
        [P in keyof T & keyof AggregatePromoCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromoCode[P]>
      : GetScalarType<T[P], AggregatePromoCode[P]>
  }




  export type PromoCodeGroupByArgs = {
    where?: PromoCodeWhereInput
    orderBy?: Enumerable<PromoCodeOrderByWithAggregationInput>
    by: PromoCodeScalarFieldEnum[]
    having?: PromoCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromoCodeCountAggregateInputType | true
    _avg?: PromoCodeAvgAggregateInputType
    _sum?: PromoCodeSumAggregateInputType
    _min?: PromoCodeMinAggregateInputType
    _max?: PromoCodeMaxAggregateInputType
  }


  export type PromoCodeGroupByOutputType = {
    id: string
    code: string
    promoImageUrl: string
    description: string
    expiryDate: Date | null
    isActive: boolean
    fixedAmount: Decimal
    percentageAmount: Decimal
    maxUses: number
    createdAt: Date
    updatedAt: Date
    _count: PromoCodeCountAggregateOutputType | null
    _avg: PromoCodeAvgAggregateOutputType | null
    _sum: PromoCodeSumAggregateOutputType | null
    _min: PromoCodeMinAggregateOutputType | null
    _max: PromoCodeMaxAggregateOutputType | null
  }

  type GetPromoCodeGroupByPayload<T extends PromoCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PromoCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromoCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromoCodeGroupByOutputType[P]>
            : GetScalarType<T[P], PromoCodeGroupByOutputType[P]>
        }
      >
    >


  export type PromoCodeSelect = {
    id?: boolean
    code?: boolean
    promoImageUrl?: boolean
    description?: boolean
    expiryDate?: boolean
    isActive?: boolean
    fixedAmount?: boolean
    percentageAmount?: boolean
    maxUses?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userPromoCode?: boolean | PromoCode$userPromoCodeArgs
    _count?: boolean | PromoCodeCountOutputTypeArgs
  }


  export type PromoCodeInclude = {
    userPromoCode?: boolean | PromoCode$userPromoCodeArgs
    _count?: boolean | PromoCodeCountOutputTypeArgs
  }

  export type PromoCodeGetPayload<S extends boolean | null | undefined | PromoCodeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PromoCode :
    S extends undefined ? never :
    S extends { include: any } & (PromoCodeArgs | PromoCodeFindManyArgs)
    ? PromoCode  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'userPromoCode' ? Array < UserPromoCodeGetPayload<S['include'][P]>>  :
        P extends '_count' ? PromoCodeCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (PromoCodeArgs | PromoCodeFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'userPromoCode' ? Array < UserPromoCodeGetPayload<S['select'][P]>>  :
        P extends '_count' ? PromoCodeCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof PromoCode ? PromoCode[P] : never
  } 
      : PromoCode


  type PromoCodeCountArgs = 
    Omit<PromoCodeFindManyArgs, 'select' | 'include'> & {
      select?: PromoCodeCountAggregateInputType | true
    }

  export interface PromoCodeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one PromoCode that matches the filter.
     * @param {PromoCodeFindUniqueArgs} args - Arguments to find a PromoCode
     * @example
     * // Get one PromoCode
     * const promoCode = await prisma.promoCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PromoCodeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PromoCodeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PromoCode'> extends True ? Prisma__PromoCodeClient<PromoCodeGetPayload<T>> : Prisma__PromoCodeClient<PromoCodeGetPayload<T> | null, null>

    /**
     * Find one PromoCode that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PromoCodeFindUniqueOrThrowArgs} args - Arguments to find a PromoCode
     * @example
     * // Get one PromoCode
     * const promoCode = await prisma.promoCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PromoCodeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PromoCodeFindUniqueOrThrowArgs>
    ): Prisma__PromoCodeClient<PromoCodeGetPayload<T>>

    /**
     * Find the first PromoCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeFindFirstArgs} args - Arguments to find a PromoCode
     * @example
     * // Get one PromoCode
     * const promoCode = await prisma.promoCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PromoCodeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PromoCodeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PromoCode'> extends True ? Prisma__PromoCodeClient<PromoCodeGetPayload<T>> : Prisma__PromoCodeClient<PromoCodeGetPayload<T> | null, null>

    /**
     * Find the first PromoCode that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeFindFirstOrThrowArgs} args - Arguments to find a PromoCode
     * @example
     * // Get one PromoCode
     * const promoCode = await prisma.promoCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PromoCodeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PromoCodeFindFirstOrThrowArgs>
    ): Prisma__PromoCodeClient<PromoCodeGetPayload<T>>

    /**
     * Find zero or more PromoCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PromoCodes
     * const promoCodes = await prisma.promoCode.findMany()
     * 
     * // Get first 10 PromoCodes
     * const promoCodes = await prisma.promoCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promoCodeWithIdOnly = await prisma.promoCode.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PromoCodeFindManyArgs>(
      args?: SelectSubset<T, PromoCodeFindManyArgs>
    ): Prisma.PrismaPromise<Array<PromoCodeGetPayload<T>>>

    /**
     * Create a PromoCode.
     * @param {PromoCodeCreateArgs} args - Arguments to create a PromoCode.
     * @example
     * // Create one PromoCode
     * const PromoCode = await prisma.promoCode.create({
     *   data: {
     *     // ... data to create a PromoCode
     *   }
     * })
     * 
    **/
    create<T extends PromoCodeCreateArgs>(
      args: SelectSubset<T, PromoCodeCreateArgs>
    ): Prisma__PromoCodeClient<PromoCodeGetPayload<T>>

    /**
     * Create many PromoCodes.
     *     @param {PromoCodeCreateManyArgs} args - Arguments to create many PromoCodes.
     *     @example
     *     // Create many PromoCodes
     *     const promoCode = await prisma.promoCode.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PromoCodeCreateManyArgs>(
      args?: SelectSubset<T, PromoCodeCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PromoCode.
     * @param {PromoCodeDeleteArgs} args - Arguments to delete one PromoCode.
     * @example
     * // Delete one PromoCode
     * const PromoCode = await prisma.promoCode.delete({
     *   where: {
     *     // ... filter to delete one PromoCode
     *   }
     * })
     * 
    **/
    delete<T extends PromoCodeDeleteArgs>(
      args: SelectSubset<T, PromoCodeDeleteArgs>
    ): Prisma__PromoCodeClient<PromoCodeGetPayload<T>>

    /**
     * Update one PromoCode.
     * @param {PromoCodeUpdateArgs} args - Arguments to update one PromoCode.
     * @example
     * // Update one PromoCode
     * const promoCode = await prisma.promoCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PromoCodeUpdateArgs>(
      args: SelectSubset<T, PromoCodeUpdateArgs>
    ): Prisma__PromoCodeClient<PromoCodeGetPayload<T>>

    /**
     * Delete zero or more PromoCodes.
     * @param {PromoCodeDeleteManyArgs} args - Arguments to filter PromoCodes to delete.
     * @example
     * // Delete a few PromoCodes
     * const { count } = await prisma.promoCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PromoCodeDeleteManyArgs>(
      args?: SelectSubset<T, PromoCodeDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromoCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PromoCodes
     * const promoCode = await prisma.promoCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PromoCodeUpdateManyArgs>(
      args: SelectSubset<T, PromoCodeUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PromoCode.
     * @param {PromoCodeUpsertArgs} args - Arguments to update or create a PromoCode.
     * @example
     * // Update or create a PromoCode
     * const promoCode = await prisma.promoCode.upsert({
     *   create: {
     *     // ... data to create a PromoCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PromoCode we want to update
     *   }
     * })
    **/
    upsert<T extends PromoCodeUpsertArgs>(
      args: SelectSubset<T, PromoCodeUpsertArgs>
    ): Prisma__PromoCodeClient<PromoCodeGetPayload<T>>

    /**
     * Count the number of PromoCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeCountArgs} args - Arguments to filter PromoCodes to count.
     * @example
     * // Count the number of PromoCodes
     * const count = await prisma.promoCode.count({
     *   where: {
     *     // ... the filter for the PromoCodes we want to count
     *   }
     * })
    **/
    count<T extends PromoCodeCountArgs>(
      args?: Subset<T, PromoCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromoCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PromoCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromoCodeAggregateArgs>(args: Subset<T, PromoCodeAggregateArgs>): Prisma.PrismaPromise<GetPromoCodeAggregateType<T>>

    /**
     * Group by PromoCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromoCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromoCodeGroupByArgs['orderBy'] }
        : { orderBy?: PromoCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromoCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromoCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for PromoCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PromoCodeClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    userPromoCode<T extends PromoCode$userPromoCodeArgs= {}>(args?: Subset<T, PromoCode$userPromoCodeArgs>): Prisma.PrismaPromise<Array<UserPromoCodeGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * PromoCode base type for findUnique actions
   */
  export type PromoCodeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromoCodeInclude | null
    /**
     * Filter, which PromoCode to fetch.
     */
    where: PromoCodeWhereUniqueInput
  }

  /**
   * PromoCode findUnique
   */
  export interface PromoCodeFindUniqueArgs extends PromoCodeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PromoCode findUniqueOrThrow
   */
  export type PromoCodeFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromoCodeInclude | null
    /**
     * Filter, which PromoCode to fetch.
     */
    where: PromoCodeWhereUniqueInput
  }


  /**
   * PromoCode base type for findFirst actions
   */
  export type PromoCodeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromoCodeInclude | null
    /**
     * Filter, which PromoCode to fetch.
     */
    where?: PromoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodes to fetch.
     */
    orderBy?: Enumerable<PromoCodeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromoCodes.
     */
    cursor?: PromoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromoCodes.
     */
    distinct?: Enumerable<PromoCodeScalarFieldEnum>
  }

  /**
   * PromoCode findFirst
   */
  export interface PromoCodeFindFirstArgs extends PromoCodeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PromoCode findFirstOrThrow
   */
  export type PromoCodeFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromoCodeInclude | null
    /**
     * Filter, which PromoCode to fetch.
     */
    where?: PromoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodes to fetch.
     */
    orderBy?: Enumerable<PromoCodeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromoCodes.
     */
    cursor?: PromoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromoCodes.
     */
    distinct?: Enumerable<PromoCodeScalarFieldEnum>
  }


  /**
   * PromoCode findMany
   */
  export type PromoCodeFindManyArgs = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromoCodeInclude | null
    /**
     * Filter, which PromoCodes to fetch.
     */
    where?: PromoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodes to fetch.
     */
    orderBy?: Enumerable<PromoCodeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PromoCodes.
     */
    cursor?: PromoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodes.
     */
    skip?: number
    distinct?: Enumerable<PromoCodeScalarFieldEnum>
  }


  /**
   * PromoCode create
   */
  export type PromoCodeCreateArgs = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromoCodeInclude | null
    /**
     * The data needed to create a PromoCode.
     */
    data: XOR<PromoCodeCreateInput, PromoCodeUncheckedCreateInput>
  }


  /**
   * PromoCode createMany
   */
  export type PromoCodeCreateManyArgs = {
    /**
     * The data used to create many PromoCodes.
     */
    data: Enumerable<PromoCodeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PromoCode update
   */
  export type PromoCodeUpdateArgs = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromoCodeInclude | null
    /**
     * The data needed to update a PromoCode.
     */
    data: XOR<PromoCodeUpdateInput, PromoCodeUncheckedUpdateInput>
    /**
     * Choose, which PromoCode to update.
     */
    where: PromoCodeWhereUniqueInput
  }


  /**
   * PromoCode updateMany
   */
  export type PromoCodeUpdateManyArgs = {
    /**
     * The data used to update PromoCodes.
     */
    data: XOR<PromoCodeUpdateManyMutationInput, PromoCodeUncheckedUpdateManyInput>
    /**
     * Filter which PromoCodes to update
     */
    where?: PromoCodeWhereInput
  }


  /**
   * PromoCode upsert
   */
  export type PromoCodeUpsertArgs = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromoCodeInclude | null
    /**
     * The filter to search for the PromoCode to update in case it exists.
     */
    where: PromoCodeWhereUniqueInput
    /**
     * In case the PromoCode found by the `where` argument doesn't exist, create a new PromoCode with this data.
     */
    create: XOR<PromoCodeCreateInput, PromoCodeUncheckedCreateInput>
    /**
     * In case the PromoCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromoCodeUpdateInput, PromoCodeUncheckedUpdateInput>
  }


  /**
   * PromoCode delete
   */
  export type PromoCodeDeleteArgs = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromoCodeInclude | null
    /**
     * Filter which PromoCode to delete.
     */
    where: PromoCodeWhereUniqueInput
  }


  /**
   * PromoCode deleteMany
   */
  export type PromoCodeDeleteManyArgs = {
    /**
     * Filter which PromoCodes to delete
     */
    where?: PromoCodeWhereInput
  }


  /**
   * PromoCode.userPromoCode
   */
  export type PromoCode$userPromoCodeArgs = {
    /**
     * Select specific fields to fetch from the UserPromoCode
     */
    select?: UserPromoCodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPromoCodeInclude | null
    where?: UserPromoCodeWhereInput
    orderBy?: Enumerable<UserPromoCodeOrderByWithRelationInput>
    cursor?: UserPromoCodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserPromoCodeScalarFieldEnum>
  }


  /**
   * PromoCode without action
   */
  export type PromoCodeArgs = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromoCodeInclude | null
  }



  /**
   * Model UserPromoCode
   */


  export type AggregateUserPromoCode = {
    _count: UserPromoCodeCountAggregateOutputType | null
    _min: UserPromoCodeMinAggregateOutputType | null
    _max: UserPromoCodeMaxAggregateOutputType | null
  }

  export type UserPromoCodeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    promoCodeId: string | null
    promoCodeUsedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPromoCodeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    promoCodeId: string | null
    promoCodeUsedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPromoCodeCountAggregateOutputType = {
    id: number
    userId: number
    promoCodeId: number
    promoCodeUsedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserPromoCodeMinAggregateInputType = {
    id?: true
    userId?: true
    promoCodeId?: true
    promoCodeUsedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPromoCodeMaxAggregateInputType = {
    id?: true
    userId?: true
    promoCodeId?: true
    promoCodeUsedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPromoCodeCountAggregateInputType = {
    id?: true
    userId?: true
    promoCodeId?: true
    promoCodeUsedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserPromoCodeAggregateArgs = {
    /**
     * Filter which UserPromoCode to aggregate.
     */
    where?: UserPromoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPromoCodes to fetch.
     */
    orderBy?: Enumerable<UserPromoCodeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPromoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPromoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPromoCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPromoCodes
    **/
    _count?: true | UserPromoCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPromoCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPromoCodeMaxAggregateInputType
  }

  export type GetUserPromoCodeAggregateType<T extends UserPromoCodeAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPromoCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPromoCode[P]>
      : GetScalarType<T[P], AggregateUserPromoCode[P]>
  }




  export type UserPromoCodeGroupByArgs = {
    where?: UserPromoCodeWhereInput
    orderBy?: Enumerable<UserPromoCodeOrderByWithAggregationInput>
    by: UserPromoCodeScalarFieldEnum[]
    having?: UserPromoCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPromoCodeCountAggregateInputType | true
    _min?: UserPromoCodeMinAggregateInputType
    _max?: UserPromoCodeMaxAggregateInputType
  }


  export type UserPromoCodeGroupByOutputType = {
    id: string
    userId: string
    promoCodeId: string
    promoCodeUsedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserPromoCodeCountAggregateOutputType | null
    _min: UserPromoCodeMinAggregateOutputType | null
    _max: UserPromoCodeMaxAggregateOutputType | null
  }

  type GetUserPromoCodeGroupByPayload<T extends UserPromoCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserPromoCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPromoCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPromoCodeGroupByOutputType[P]>
            : GetScalarType<T[P], UserPromoCodeGroupByOutputType[P]>
        }
      >
    >


  export type UserPromoCodeSelect = {
    id?: boolean
    userId?: boolean
    promoCodeId?: boolean
    promoCodeUsedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs
    promoCode?: boolean | PromoCodeArgs
  }


  export type UserPromoCodeInclude = {
    user?: boolean | UserArgs
    promoCode?: boolean | PromoCodeArgs
  }

  export type UserPromoCodeGetPayload<S extends boolean | null | undefined | UserPromoCodeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserPromoCode :
    S extends undefined ? never :
    S extends { include: any } & (UserPromoCodeArgs | UserPromoCodeFindManyArgs)
    ? UserPromoCode  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'promoCode' ? PromoCodeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserPromoCodeArgs | UserPromoCodeFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'promoCode' ? PromoCodeGetPayload<S['select'][P]> :  P extends keyof UserPromoCode ? UserPromoCode[P] : never
  } 
      : UserPromoCode


  type UserPromoCodeCountArgs = 
    Omit<UserPromoCodeFindManyArgs, 'select' | 'include'> & {
      select?: UserPromoCodeCountAggregateInputType | true
    }

  export interface UserPromoCodeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one UserPromoCode that matches the filter.
     * @param {UserPromoCodeFindUniqueArgs} args - Arguments to find a UserPromoCode
     * @example
     * // Get one UserPromoCode
     * const userPromoCode = await prisma.userPromoCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserPromoCodeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserPromoCodeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserPromoCode'> extends True ? Prisma__UserPromoCodeClient<UserPromoCodeGetPayload<T>> : Prisma__UserPromoCodeClient<UserPromoCodeGetPayload<T> | null, null>

    /**
     * Find one UserPromoCode that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserPromoCodeFindUniqueOrThrowArgs} args - Arguments to find a UserPromoCode
     * @example
     * // Get one UserPromoCode
     * const userPromoCode = await prisma.userPromoCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserPromoCodeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserPromoCodeFindUniqueOrThrowArgs>
    ): Prisma__UserPromoCodeClient<UserPromoCodeGetPayload<T>>

    /**
     * Find the first UserPromoCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPromoCodeFindFirstArgs} args - Arguments to find a UserPromoCode
     * @example
     * // Get one UserPromoCode
     * const userPromoCode = await prisma.userPromoCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserPromoCodeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserPromoCodeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserPromoCode'> extends True ? Prisma__UserPromoCodeClient<UserPromoCodeGetPayload<T>> : Prisma__UserPromoCodeClient<UserPromoCodeGetPayload<T> | null, null>

    /**
     * Find the first UserPromoCode that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPromoCodeFindFirstOrThrowArgs} args - Arguments to find a UserPromoCode
     * @example
     * // Get one UserPromoCode
     * const userPromoCode = await prisma.userPromoCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserPromoCodeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserPromoCodeFindFirstOrThrowArgs>
    ): Prisma__UserPromoCodeClient<UserPromoCodeGetPayload<T>>

    /**
     * Find zero or more UserPromoCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPromoCodeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPromoCodes
     * const userPromoCodes = await prisma.userPromoCode.findMany()
     * 
     * // Get first 10 UserPromoCodes
     * const userPromoCodes = await prisma.userPromoCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPromoCodeWithIdOnly = await prisma.userPromoCode.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserPromoCodeFindManyArgs>(
      args?: SelectSubset<T, UserPromoCodeFindManyArgs>
    ): Prisma.PrismaPromise<Array<UserPromoCodeGetPayload<T>>>

    /**
     * Create a UserPromoCode.
     * @param {UserPromoCodeCreateArgs} args - Arguments to create a UserPromoCode.
     * @example
     * // Create one UserPromoCode
     * const UserPromoCode = await prisma.userPromoCode.create({
     *   data: {
     *     // ... data to create a UserPromoCode
     *   }
     * })
     * 
    **/
    create<T extends UserPromoCodeCreateArgs>(
      args: SelectSubset<T, UserPromoCodeCreateArgs>
    ): Prisma__UserPromoCodeClient<UserPromoCodeGetPayload<T>>

    /**
     * Create many UserPromoCodes.
     *     @param {UserPromoCodeCreateManyArgs} args - Arguments to create many UserPromoCodes.
     *     @example
     *     // Create many UserPromoCodes
     *     const userPromoCode = await prisma.userPromoCode.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserPromoCodeCreateManyArgs>(
      args?: SelectSubset<T, UserPromoCodeCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserPromoCode.
     * @param {UserPromoCodeDeleteArgs} args - Arguments to delete one UserPromoCode.
     * @example
     * // Delete one UserPromoCode
     * const UserPromoCode = await prisma.userPromoCode.delete({
     *   where: {
     *     // ... filter to delete one UserPromoCode
     *   }
     * })
     * 
    **/
    delete<T extends UserPromoCodeDeleteArgs>(
      args: SelectSubset<T, UserPromoCodeDeleteArgs>
    ): Prisma__UserPromoCodeClient<UserPromoCodeGetPayload<T>>

    /**
     * Update one UserPromoCode.
     * @param {UserPromoCodeUpdateArgs} args - Arguments to update one UserPromoCode.
     * @example
     * // Update one UserPromoCode
     * const userPromoCode = await prisma.userPromoCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserPromoCodeUpdateArgs>(
      args: SelectSubset<T, UserPromoCodeUpdateArgs>
    ): Prisma__UserPromoCodeClient<UserPromoCodeGetPayload<T>>

    /**
     * Delete zero or more UserPromoCodes.
     * @param {UserPromoCodeDeleteManyArgs} args - Arguments to filter UserPromoCodes to delete.
     * @example
     * // Delete a few UserPromoCodes
     * const { count } = await prisma.userPromoCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserPromoCodeDeleteManyArgs>(
      args?: SelectSubset<T, UserPromoCodeDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPromoCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPromoCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPromoCodes
     * const userPromoCode = await prisma.userPromoCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserPromoCodeUpdateManyArgs>(
      args: SelectSubset<T, UserPromoCodeUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserPromoCode.
     * @param {UserPromoCodeUpsertArgs} args - Arguments to update or create a UserPromoCode.
     * @example
     * // Update or create a UserPromoCode
     * const userPromoCode = await prisma.userPromoCode.upsert({
     *   create: {
     *     // ... data to create a UserPromoCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPromoCode we want to update
     *   }
     * })
    **/
    upsert<T extends UserPromoCodeUpsertArgs>(
      args: SelectSubset<T, UserPromoCodeUpsertArgs>
    ): Prisma__UserPromoCodeClient<UserPromoCodeGetPayload<T>>

    /**
     * Count the number of UserPromoCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPromoCodeCountArgs} args - Arguments to filter UserPromoCodes to count.
     * @example
     * // Count the number of UserPromoCodes
     * const count = await prisma.userPromoCode.count({
     *   where: {
     *     // ... the filter for the UserPromoCodes we want to count
     *   }
     * })
    **/
    count<T extends UserPromoCodeCountArgs>(
      args?: Subset<T, UserPromoCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPromoCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPromoCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPromoCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPromoCodeAggregateArgs>(args: Subset<T, UserPromoCodeAggregateArgs>): Prisma.PrismaPromise<GetUserPromoCodeAggregateType<T>>

    /**
     * Group by UserPromoCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPromoCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPromoCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPromoCodeGroupByArgs['orderBy'] }
        : { orderBy?: UserPromoCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPromoCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPromoCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPromoCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserPromoCodeClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    promoCode<T extends PromoCodeArgs= {}>(args?: Subset<T, PromoCodeArgs>): Prisma__PromoCodeClient<PromoCodeGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserPromoCode base type for findUnique actions
   */
  export type UserPromoCodeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the UserPromoCode
     */
    select?: UserPromoCodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPromoCodeInclude | null
    /**
     * Filter, which UserPromoCode to fetch.
     */
    where: UserPromoCodeWhereUniqueInput
  }

  /**
   * UserPromoCode findUnique
   */
  export interface UserPromoCodeFindUniqueArgs extends UserPromoCodeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserPromoCode findUniqueOrThrow
   */
  export type UserPromoCodeFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserPromoCode
     */
    select?: UserPromoCodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPromoCodeInclude | null
    /**
     * Filter, which UserPromoCode to fetch.
     */
    where: UserPromoCodeWhereUniqueInput
  }


  /**
   * UserPromoCode base type for findFirst actions
   */
  export type UserPromoCodeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the UserPromoCode
     */
    select?: UserPromoCodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPromoCodeInclude | null
    /**
     * Filter, which UserPromoCode to fetch.
     */
    where?: UserPromoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPromoCodes to fetch.
     */
    orderBy?: Enumerable<UserPromoCodeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPromoCodes.
     */
    cursor?: UserPromoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPromoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPromoCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPromoCodes.
     */
    distinct?: Enumerable<UserPromoCodeScalarFieldEnum>
  }

  /**
   * UserPromoCode findFirst
   */
  export interface UserPromoCodeFindFirstArgs extends UserPromoCodeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserPromoCode findFirstOrThrow
   */
  export type UserPromoCodeFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserPromoCode
     */
    select?: UserPromoCodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPromoCodeInclude | null
    /**
     * Filter, which UserPromoCode to fetch.
     */
    where?: UserPromoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPromoCodes to fetch.
     */
    orderBy?: Enumerable<UserPromoCodeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPromoCodes.
     */
    cursor?: UserPromoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPromoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPromoCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPromoCodes.
     */
    distinct?: Enumerable<UserPromoCodeScalarFieldEnum>
  }


  /**
   * UserPromoCode findMany
   */
  export type UserPromoCodeFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserPromoCode
     */
    select?: UserPromoCodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPromoCodeInclude | null
    /**
     * Filter, which UserPromoCodes to fetch.
     */
    where?: UserPromoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPromoCodes to fetch.
     */
    orderBy?: Enumerable<UserPromoCodeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPromoCodes.
     */
    cursor?: UserPromoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPromoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPromoCodes.
     */
    skip?: number
    distinct?: Enumerable<UserPromoCodeScalarFieldEnum>
  }


  /**
   * UserPromoCode create
   */
  export type UserPromoCodeCreateArgs = {
    /**
     * Select specific fields to fetch from the UserPromoCode
     */
    select?: UserPromoCodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPromoCodeInclude | null
    /**
     * The data needed to create a UserPromoCode.
     */
    data: XOR<UserPromoCodeCreateInput, UserPromoCodeUncheckedCreateInput>
  }


  /**
   * UserPromoCode createMany
   */
  export type UserPromoCodeCreateManyArgs = {
    /**
     * The data used to create many UserPromoCodes.
     */
    data: Enumerable<UserPromoCodeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserPromoCode update
   */
  export type UserPromoCodeUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserPromoCode
     */
    select?: UserPromoCodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPromoCodeInclude | null
    /**
     * The data needed to update a UserPromoCode.
     */
    data: XOR<UserPromoCodeUpdateInput, UserPromoCodeUncheckedUpdateInput>
    /**
     * Choose, which UserPromoCode to update.
     */
    where: UserPromoCodeWhereUniqueInput
  }


  /**
   * UserPromoCode updateMany
   */
  export type UserPromoCodeUpdateManyArgs = {
    /**
     * The data used to update UserPromoCodes.
     */
    data: XOR<UserPromoCodeUpdateManyMutationInput, UserPromoCodeUncheckedUpdateManyInput>
    /**
     * Filter which UserPromoCodes to update
     */
    where?: UserPromoCodeWhereInput
  }


  /**
   * UserPromoCode upsert
   */
  export type UserPromoCodeUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserPromoCode
     */
    select?: UserPromoCodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPromoCodeInclude | null
    /**
     * The filter to search for the UserPromoCode to update in case it exists.
     */
    where: UserPromoCodeWhereUniqueInput
    /**
     * In case the UserPromoCode found by the `where` argument doesn't exist, create a new UserPromoCode with this data.
     */
    create: XOR<UserPromoCodeCreateInput, UserPromoCodeUncheckedCreateInput>
    /**
     * In case the UserPromoCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPromoCodeUpdateInput, UserPromoCodeUncheckedUpdateInput>
  }


  /**
   * UserPromoCode delete
   */
  export type UserPromoCodeDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserPromoCode
     */
    select?: UserPromoCodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPromoCodeInclude | null
    /**
     * Filter which UserPromoCode to delete.
     */
    where: UserPromoCodeWhereUniqueInput
  }


  /**
   * UserPromoCode deleteMany
   */
  export type UserPromoCodeDeleteManyArgs = {
    /**
     * Filter which UserPromoCodes to delete
     */
    where?: UserPromoCodeWhereInput
  }


  /**
   * UserPromoCode without action
   */
  export type UserPromoCodeArgs = {
    /**
     * Select specific fields to fetch from the UserPromoCode
     */
    select?: UserPromoCodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPromoCodeInclude | null
  }



  /**
   * Model FreeTrial
   */


  export type AggregateFreeTrial = {
    _count: FreeTrialCountAggregateOutputType | null
    _min: FreeTrialMinAggregateOutputType | null
    _max: FreeTrialMaxAggregateOutputType | null
  }

  export type FreeTrialMinAggregateOutputType = {
    id: string | null
    hospitalName: string | null
    phoneNumber: string | null
    hospitalChair: string | null
    registrationNumber: string | null
    directorInfo: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FreeTrialMaxAggregateOutputType = {
    id: string | null
    hospitalName: string | null
    phoneNumber: string | null
    hospitalChair: string | null
    registrationNumber: string | null
    directorInfo: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FreeTrialCountAggregateOutputType = {
    id: number
    hospitalName: number
    phoneNumber: number
    hospitalChair: number
    registrationNumber: number
    directorInfo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FreeTrialMinAggregateInputType = {
    id?: true
    hospitalName?: true
    phoneNumber?: true
    hospitalChair?: true
    registrationNumber?: true
    directorInfo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FreeTrialMaxAggregateInputType = {
    id?: true
    hospitalName?: true
    phoneNumber?: true
    hospitalChair?: true
    registrationNumber?: true
    directorInfo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FreeTrialCountAggregateInputType = {
    id?: true
    hospitalName?: true
    phoneNumber?: true
    hospitalChair?: true
    registrationNumber?: true
    directorInfo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FreeTrialAggregateArgs = {
    /**
     * Filter which FreeTrial to aggregate.
     */
    where?: FreeTrialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FreeTrials to fetch.
     */
    orderBy?: Enumerable<FreeTrialOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FreeTrialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FreeTrials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FreeTrials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FreeTrials
    **/
    _count?: true | FreeTrialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FreeTrialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FreeTrialMaxAggregateInputType
  }

  export type GetFreeTrialAggregateType<T extends FreeTrialAggregateArgs> = {
        [P in keyof T & keyof AggregateFreeTrial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFreeTrial[P]>
      : GetScalarType<T[P], AggregateFreeTrial[P]>
  }




  export type FreeTrialGroupByArgs = {
    where?: FreeTrialWhereInput
    orderBy?: Enumerable<FreeTrialOrderByWithAggregationInput>
    by: FreeTrialScalarFieldEnum[]
    having?: FreeTrialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FreeTrialCountAggregateInputType | true
    _min?: FreeTrialMinAggregateInputType
    _max?: FreeTrialMaxAggregateInputType
  }


  export type FreeTrialGroupByOutputType = {
    id: string
    hospitalName: string
    phoneNumber: string
    hospitalChair: string
    registrationNumber: string
    directorInfo: string
    createdAt: Date
    updatedAt: Date
    _count: FreeTrialCountAggregateOutputType | null
    _min: FreeTrialMinAggregateOutputType | null
    _max: FreeTrialMaxAggregateOutputType | null
  }

  type GetFreeTrialGroupByPayload<T extends FreeTrialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FreeTrialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FreeTrialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FreeTrialGroupByOutputType[P]>
            : GetScalarType<T[P], FreeTrialGroupByOutputType[P]>
        }
      >
    >


  export type FreeTrialSelect = {
    id?: boolean
    hospitalName?: boolean
    phoneNumber?: boolean
    hospitalChair?: boolean
    registrationNumber?: boolean
    directorInfo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type FreeTrialGetPayload<S extends boolean | null | undefined | FreeTrialArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FreeTrial :
    S extends undefined ? never :
    S extends { include: any } & (FreeTrialArgs | FreeTrialFindManyArgs)
    ? FreeTrial 
    : S extends { select: any } & (FreeTrialArgs | FreeTrialFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof FreeTrial ? FreeTrial[P] : never
  } 
      : FreeTrial


  type FreeTrialCountArgs = 
    Omit<FreeTrialFindManyArgs, 'select' | 'include'> & {
      select?: FreeTrialCountAggregateInputType | true
    }

  export interface FreeTrialDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one FreeTrial that matches the filter.
     * @param {FreeTrialFindUniqueArgs} args - Arguments to find a FreeTrial
     * @example
     * // Get one FreeTrial
     * const freeTrial = await prisma.freeTrial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FreeTrialFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FreeTrialFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FreeTrial'> extends True ? Prisma__FreeTrialClient<FreeTrialGetPayload<T>> : Prisma__FreeTrialClient<FreeTrialGetPayload<T> | null, null>

    /**
     * Find one FreeTrial that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FreeTrialFindUniqueOrThrowArgs} args - Arguments to find a FreeTrial
     * @example
     * // Get one FreeTrial
     * const freeTrial = await prisma.freeTrial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FreeTrialFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FreeTrialFindUniqueOrThrowArgs>
    ): Prisma__FreeTrialClient<FreeTrialGetPayload<T>>

    /**
     * Find the first FreeTrial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreeTrialFindFirstArgs} args - Arguments to find a FreeTrial
     * @example
     * // Get one FreeTrial
     * const freeTrial = await prisma.freeTrial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FreeTrialFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FreeTrialFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FreeTrial'> extends True ? Prisma__FreeTrialClient<FreeTrialGetPayload<T>> : Prisma__FreeTrialClient<FreeTrialGetPayload<T> | null, null>

    /**
     * Find the first FreeTrial that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreeTrialFindFirstOrThrowArgs} args - Arguments to find a FreeTrial
     * @example
     * // Get one FreeTrial
     * const freeTrial = await prisma.freeTrial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FreeTrialFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FreeTrialFindFirstOrThrowArgs>
    ): Prisma__FreeTrialClient<FreeTrialGetPayload<T>>

    /**
     * Find zero or more FreeTrials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreeTrialFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FreeTrials
     * const freeTrials = await prisma.freeTrial.findMany()
     * 
     * // Get first 10 FreeTrials
     * const freeTrials = await prisma.freeTrial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const freeTrialWithIdOnly = await prisma.freeTrial.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FreeTrialFindManyArgs>(
      args?: SelectSubset<T, FreeTrialFindManyArgs>
    ): Prisma.PrismaPromise<Array<FreeTrialGetPayload<T>>>

    /**
     * Create a FreeTrial.
     * @param {FreeTrialCreateArgs} args - Arguments to create a FreeTrial.
     * @example
     * // Create one FreeTrial
     * const FreeTrial = await prisma.freeTrial.create({
     *   data: {
     *     // ... data to create a FreeTrial
     *   }
     * })
     * 
    **/
    create<T extends FreeTrialCreateArgs>(
      args: SelectSubset<T, FreeTrialCreateArgs>
    ): Prisma__FreeTrialClient<FreeTrialGetPayload<T>>

    /**
     * Create many FreeTrials.
     *     @param {FreeTrialCreateManyArgs} args - Arguments to create many FreeTrials.
     *     @example
     *     // Create many FreeTrials
     *     const freeTrial = await prisma.freeTrial.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FreeTrialCreateManyArgs>(
      args?: SelectSubset<T, FreeTrialCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FreeTrial.
     * @param {FreeTrialDeleteArgs} args - Arguments to delete one FreeTrial.
     * @example
     * // Delete one FreeTrial
     * const FreeTrial = await prisma.freeTrial.delete({
     *   where: {
     *     // ... filter to delete one FreeTrial
     *   }
     * })
     * 
    **/
    delete<T extends FreeTrialDeleteArgs>(
      args: SelectSubset<T, FreeTrialDeleteArgs>
    ): Prisma__FreeTrialClient<FreeTrialGetPayload<T>>

    /**
     * Update one FreeTrial.
     * @param {FreeTrialUpdateArgs} args - Arguments to update one FreeTrial.
     * @example
     * // Update one FreeTrial
     * const freeTrial = await prisma.freeTrial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FreeTrialUpdateArgs>(
      args: SelectSubset<T, FreeTrialUpdateArgs>
    ): Prisma__FreeTrialClient<FreeTrialGetPayload<T>>

    /**
     * Delete zero or more FreeTrials.
     * @param {FreeTrialDeleteManyArgs} args - Arguments to filter FreeTrials to delete.
     * @example
     * // Delete a few FreeTrials
     * const { count } = await prisma.freeTrial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FreeTrialDeleteManyArgs>(
      args?: SelectSubset<T, FreeTrialDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FreeTrials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreeTrialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FreeTrials
     * const freeTrial = await prisma.freeTrial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FreeTrialUpdateManyArgs>(
      args: SelectSubset<T, FreeTrialUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FreeTrial.
     * @param {FreeTrialUpsertArgs} args - Arguments to update or create a FreeTrial.
     * @example
     * // Update or create a FreeTrial
     * const freeTrial = await prisma.freeTrial.upsert({
     *   create: {
     *     // ... data to create a FreeTrial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FreeTrial we want to update
     *   }
     * })
    **/
    upsert<T extends FreeTrialUpsertArgs>(
      args: SelectSubset<T, FreeTrialUpsertArgs>
    ): Prisma__FreeTrialClient<FreeTrialGetPayload<T>>

    /**
     * Count the number of FreeTrials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreeTrialCountArgs} args - Arguments to filter FreeTrials to count.
     * @example
     * // Count the number of FreeTrials
     * const count = await prisma.freeTrial.count({
     *   where: {
     *     // ... the filter for the FreeTrials we want to count
     *   }
     * })
    **/
    count<T extends FreeTrialCountArgs>(
      args?: Subset<T, FreeTrialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FreeTrialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FreeTrial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreeTrialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FreeTrialAggregateArgs>(args: Subset<T, FreeTrialAggregateArgs>): Prisma.PrismaPromise<GetFreeTrialAggregateType<T>>

    /**
     * Group by FreeTrial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreeTrialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FreeTrialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FreeTrialGroupByArgs['orderBy'] }
        : { orderBy?: FreeTrialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FreeTrialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFreeTrialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FreeTrial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FreeTrialClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FreeTrial base type for findUnique actions
   */
  export type FreeTrialFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the FreeTrial
     */
    select?: FreeTrialSelect | null
    /**
     * Filter, which FreeTrial to fetch.
     */
    where: FreeTrialWhereUniqueInput
  }

  /**
   * FreeTrial findUnique
   */
  export interface FreeTrialFindUniqueArgs extends FreeTrialFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FreeTrial findUniqueOrThrow
   */
  export type FreeTrialFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FreeTrial
     */
    select?: FreeTrialSelect | null
    /**
     * Filter, which FreeTrial to fetch.
     */
    where: FreeTrialWhereUniqueInput
  }


  /**
   * FreeTrial base type for findFirst actions
   */
  export type FreeTrialFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the FreeTrial
     */
    select?: FreeTrialSelect | null
    /**
     * Filter, which FreeTrial to fetch.
     */
    where?: FreeTrialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FreeTrials to fetch.
     */
    orderBy?: Enumerable<FreeTrialOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FreeTrials.
     */
    cursor?: FreeTrialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FreeTrials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FreeTrials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FreeTrials.
     */
    distinct?: Enumerable<FreeTrialScalarFieldEnum>
  }

  /**
   * FreeTrial findFirst
   */
  export interface FreeTrialFindFirstArgs extends FreeTrialFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FreeTrial findFirstOrThrow
   */
  export type FreeTrialFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FreeTrial
     */
    select?: FreeTrialSelect | null
    /**
     * Filter, which FreeTrial to fetch.
     */
    where?: FreeTrialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FreeTrials to fetch.
     */
    orderBy?: Enumerable<FreeTrialOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FreeTrials.
     */
    cursor?: FreeTrialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FreeTrials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FreeTrials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FreeTrials.
     */
    distinct?: Enumerable<FreeTrialScalarFieldEnum>
  }


  /**
   * FreeTrial findMany
   */
  export type FreeTrialFindManyArgs = {
    /**
     * Select specific fields to fetch from the FreeTrial
     */
    select?: FreeTrialSelect | null
    /**
     * Filter, which FreeTrials to fetch.
     */
    where?: FreeTrialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FreeTrials to fetch.
     */
    orderBy?: Enumerable<FreeTrialOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FreeTrials.
     */
    cursor?: FreeTrialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FreeTrials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FreeTrials.
     */
    skip?: number
    distinct?: Enumerable<FreeTrialScalarFieldEnum>
  }


  /**
   * FreeTrial create
   */
  export type FreeTrialCreateArgs = {
    /**
     * Select specific fields to fetch from the FreeTrial
     */
    select?: FreeTrialSelect | null
    /**
     * The data needed to create a FreeTrial.
     */
    data: XOR<FreeTrialCreateInput, FreeTrialUncheckedCreateInput>
  }


  /**
   * FreeTrial createMany
   */
  export type FreeTrialCreateManyArgs = {
    /**
     * The data used to create many FreeTrials.
     */
    data: Enumerable<FreeTrialCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FreeTrial update
   */
  export type FreeTrialUpdateArgs = {
    /**
     * Select specific fields to fetch from the FreeTrial
     */
    select?: FreeTrialSelect | null
    /**
     * The data needed to update a FreeTrial.
     */
    data: XOR<FreeTrialUpdateInput, FreeTrialUncheckedUpdateInput>
    /**
     * Choose, which FreeTrial to update.
     */
    where: FreeTrialWhereUniqueInput
  }


  /**
   * FreeTrial updateMany
   */
  export type FreeTrialUpdateManyArgs = {
    /**
     * The data used to update FreeTrials.
     */
    data: XOR<FreeTrialUpdateManyMutationInput, FreeTrialUncheckedUpdateManyInput>
    /**
     * Filter which FreeTrials to update
     */
    where?: FreeTrialWhereInput
  }


  /**
   * FreeTrial upsert
   */
  export type FreeTrialUpsertArgs = {
    /**
     * Select specific fields to fetch from the FreeTrial
     */
    select?: FreeTrialSelect | null
    /**
     * The filter to search for the FreeTrial to update in case it exists.
     */
    where: FreeTrialWhereUniqueInput
    /**
     * In case the FreeTrial found by the `where` argument doesn't exist, create a new FreeTrial with this data.
     */
    create: XOR<FreeTrialCreateInput, FreeTrialUncheckedCreateInput>
    /**
     * In case the FreeTrial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FreeTrialUpdateInput, FreeTrialUncheckedUpdateInput>
  }


  /**
   * FreeTrial delete
   */
  export type FreeTrialDeleteArgs = {
    /**
     * Select specific fields to fetch from the FreeTrial
     */
    select?: FreeTrialSelect | null
    /**
     * Filter which FreeTrial to delete.
     */
    where: FreeTrialWhereUniqueInput
  }


  /**
   * FreeTrial deleteMany
   */
  export type FreeTrialDeleteManyArgs = {
    /**
     * Filter which FreeTrials to delete
     */
    where?: FreeTrialWhereInput
  }


  /**
   * FreeTrial without action
   */
  export type FreeTrialArgs = {
    /**
     * Select specific fields to fetch from the FreeTrial
     */
    select?: FreeTrialSelect | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refreshToken: 'refreshToken',
    accessToken: 'accessToken',
    tokenType: 'tokenType',
    expiresAt: 'expiresAt',
    scope: 'scope',
    idToken: 'idToken',
    sessionState: 'sessionState',
    oauthTokenSecret: 'oauthTokenSecret',
    oauthToken: 'oauthToken',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const DatabaseConnectionScalarFieldEnum: {
    id: 'id',
    connectionName: 'connectionName',
    connectionType: 'connectionType',
    host: 'host',
    port: 'port',
    databaseName: 'databaseName',
    username: 'username',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    hospitalId: 'hospitalId'
  };

  export type DatabaseConnectionScalarFieldEnum = (typeof DatabaseConnectionScalarFieldEnum)[keyof typeof DatabaseConnectionScalarFieldEnum]


  export const FileUploadScalarFieldEnum: {
    id: 'id',
    fileGroup: 'fileGroup',
    fileLink: 'fileLink',
    fileSource: 'fileSource',
    removedAt: 'removedAt',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    fileCategory: 'fileCategory',
    fileSourceDate: 'fileSourceDate',
    fileMIMEType: 'fileMIMEType'
  };

  export type FileUploadScalarFieldEnum = (typeof FileUploadScalarFieldEnum)[keyof typeof FileUploadScalarFieldEnum]


  export const FirebaseTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FirebaseTokenScalarFieldEnum = (typeof FirebaseTokenScalarFieldEnum)[keyof typeof FirebaseTokenScalarFieldEnum]


  export const FreeTrialScalarFieldEnum: {
    id: 'id',
    hospitalName: 'hospitalName',
    phoneNumber: 'phoneNumber',
    hospitalChair: 'hospitalChair',
    registrationNumber: 'registrationNumber',
    directorInfo: 'directorInfo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FreeTrialScalarFieldEnum = (typeof FreeTrialScalarFieldEnum)[keyof typeof FreeTrialScalarFieldEnum]


  export const HospitalScalarFieldEnum: {
    id: 'id',
    hospitalLogo: 'hospitalLogo',
    subDomain: 'subDomain',
    phoneNumber: 'phoneNumber',
    name: 'name',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HospitalScalarFieldEnum = (typeof HospitalScalarFieldEnum)[keyof typeof HospitalScalarFieldEnum]


  export const HospitalUsersScalarFieldEnum: {
    id: 'id',
    hospitalId: 'hospitalId',
    phoneNumber: 'phoneNumber',
    userName: 'userName',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HospitalUsersScalarFieldEnum = (typeof HospitalUsersScalarFieldEnum)[keyof typeof HospitalUsersScalarFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const MachineScalarFieldEnum: {
    id: 'id',
    subscriptionId: 'subscriptionId',
    machineName: 'machineName',
    machineUniqueId: 'machineUniqueId',
    registeredAt: 'registeredAt'
  };

  export type MachineScalarFieldEnum = (typeof MachineScalarFieldEnum)[keyof typeof MachineScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    phoneNumber: 'phoneNumber',
    message: 'message',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    hospitalId: 'hospitalId'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const ProductPaymentScalarFieldEnum: {
    id: 'id',
    paidSource: 'paidSource',
    paidAmount: 'paidAmount',
    paidDate: 'paidDate',
    additionalNote: 'additionalNote',
    productId: 'productId',
    productVariantId: 'productVariantId',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    paymentStatus: 'paymentStatus'
  };

  export type ProductPaymentScalarFieldEnum = (typeof ProductPaymentScalarFieldEnum)[keyof typeof ProductPaymentScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    productDescription: 'productDescription',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const ProductVariantScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    name: 'name',
    price: 'price',
    unit: 'unit',
    duration: 'duration',
    discount: 'discount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    sits: 'sits'
  };

  export type ProductVariantScalarFieldEnum = (typeof ProductVariantScalarFieldEnum)[keyof typeof ProductVariantScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    firstName: 'firstName',
    lastName: 'lastName',
    latinName: 'latinName',
    sex: 'sex',
    dob: 'dob',
    height: 'height',
    weight: 'weight',
    picture: 'picture',
    priceMin: 'priceMin',
    priceMax: 'priceMax',
    notifyEmail: 'notifyEmail',
    notifyPush: 'notifyPush',
    notifyBadge: 'notifyBadge',
    historyId: 'historyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    specialistDesc: 'specialistDesc',
    patientCode: 'patientCode',
    allowPatientAssign: 'allowPatientAssign'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const PromoCodeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    promoImageUrl: 'promoImageUrl',
    description: 'description',
    expiryDate: 'expiryDate',
    isActive: 'isActive',
    fixedAmount: 'fixedAmount',
    percentageAmount: 'percentageAmount',
    maxUses: 'maxUses',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PromoCodeScalarFieldEnum = (typeof PromoCodeScalarFieldEnum)[keyof typeof PromoCodeScalarFieldEnum]


  export const QPayInvoiceScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    productVariantId: 'productVariantId',
    invoiceData: 'invoiceData',
    userId: 'userId',
    payedDate: 'payedDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QPayInvoiceScalarFieldEnum = (typeof QPayInvoiceScalarFieldEnum)[keyof typeof QPayInvoiceScalarFieldEnum]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sid: 'sid',
    data: 'data',
    expiresAt: 'expiresAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const SmsRequestAttemptScalarFieldEnum: {
    id: 'id',
    phoneNumber: 'phoneNumber',
    ipAddress: 'ipAddress',
    createdAt: 'createdAt'
  };

  export type SmsRequestAttemptScalarFieldEnum = (typeof SmsRequestAttemptScalarFieldEnum)[keyof typeof SmsRequestAttemptScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    startDate: 'startDate',
    endDate: 'endDate',
    totalDays: 'totalDays',
    isStart: 'isStart',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    hospitalId: 'hospitalId'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserPromoCodeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    promoCodeId: 'promoCodeId',
    promoCodeUsedAt: 'promoCodeUsedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserPromoCodeScalarFieldEnum = (typeof UserPromoCodeScalarFieldEnum)[keyof typeof UserPromoCodeScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    emailVerified: 'emailVerified',
    passwordDigest: 'passwordDigest',
    phoneNumber: 'phoneNumber',
    phoneNumberVerified: 'phoneNumberVerified',
    role: 'role',
    inviteToken: 'inviteToken',
    isTokenUsed: 'isTokenUsed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    invitedBy: 'invitedBy',
    pin: 'pin',
    pinCreatedAt: 'pinCreatedAt',
    pinType: 'pinType',
    pinVerifiedAt: 'pinVerifiedAt',
    hospitalId: 'hospitalId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const WaitListPhoneNumberScalarFieldEnum: {
    id: 'id',
    phoneNumber: 'phoneNumber',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WaitListPhoneNumberScalarFieldEnum = (typeof WaitListPhoneNumberScalarFieldEnum)[keyof typeof WaitListPhoneNumberScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: StringFilter | string
    email?: StringNullableFilter | string | null
    emailVerified?: DateTimeNullableFilter | Date | string | null
    passwordDigest?: StringNullableFilter | string | null
    phoneNumber?: StringFilter | string
    phoneNumberVerified?: DateTimeNullableFilter | Date | string | null
    role?: EnumUserRoleFilter | UserRole
    inviteToken?: StringNullableFilter | string | null
    isTokenUsed?: DateTimeNullableFilter | Date | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    invitedBy?: StringNullableFilter | string | null
    pin?: StringNullableFilter | string | null
    pinCreatedAt?: DateTimeNullableFilter | Date | string | null
    pinType?: StringNullableFilter | string | null
    pinVerifiedAt?: DateTimeNullableFilter | Date | string | null
    hospitalId?: StringNullableFilter | string | null
    accounts?: AccountListRelationFilter
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput> | null
    hospital?: HospitalListRelationFilter
    ProductPayment?: ProductPaymentListRelationFilter
    QPayInvoice?: QPayInvoiceListRelationFilter
    UserPromoCode?: UserPromoCodeListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    passwordDigest?: SortOrder
    phoneNumber?: SortOrder
    phoneNumberVerified?: SortOrder
    role?: SortOrder
    inviteToken?: SortOrder
    isTokenUsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invitedBy?: SortOrder
    pin?: SortOrder
    pinCreatedAt?: SortOrder
    pinType?: SortOrder
    pinVerifiedAt?: SortOrder
    hospitalId?: SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    profile?: ProfileOrderByWithRelationInput
    hospital?: HospitalOrderByRelationAggregateInput
    ProductPayment?: ProductPaymentOrderByRelationAggregateInput
    QPayInvoice?: QPayInvoiceOrderByRelationAggregateInput
    UserPromoCode?: UserPromoCodeOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: string
    email?: string
    phoneNumber?: string
    inviteToken?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    passwordDigest?: SortOrder
    phoneNumber?: SortOrder
    phoneNumberVerified?: SortOrder
    role?: SortOrder
    inviteToken?: SortOrder
    isTokenUsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invitedBy?: SortOrder
    pin?: SortOrder
    pinCreatedAt?: SortOrder
    pinType?: SortOrder
    pinVerifiedAt?: SortOrder
    hospitalId?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    email?: StringNullableWithAggregatesFilter | string | null
    emailVerified?: DateTimeNullableWithAggregatesFilter | Date | string | null
    passwordDigest?: StringNullableWithAggregatesFilter | string | null
    phoneNumber?: StringWithAggregatesFilter | string
    phoneNumberVerified?: DateTimeNullableWithAggregatesFilter | Date | string | null
    role?: EnumUserRoleWithAggregatesFilter | UserRole
    inviteToken?: StringNullableWithAggregatesFilter | string | null
    isTokenUsed?: DateTimeNullableWithAggregatesFilter | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    invitedBy?: StringNullableWithAggregatesFilter | string | null
    pin?: StringNullableWithAggregatesFilter | string | null
    pinCreatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    pinType?: StringNullableWithAggregatesFilter | string | null
    pinVerifiedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    hospitalId?: StringNullableWithAggregatesFilter | string | null
  }

  export type AccountWhereInput = {
    AND?: Enumerable<AccountWhereInput>
    OR?: Enumerable<AccountWhereInput>
    NOT?: Enumerable<AccountWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    type?: StringFilter | string
    provider?: StringFilter | string
    providerAccountId?: StringFilter | string
    refreshToken?: StringNullableFilter | string | null
    accessToken?: StringNullableFilter | string | null
    tokenType?: StringNullableFilter | string | null
    expiresAt?: IntNullableFilter | number | null
    scope?: StringNullableFilter | string | null
    idToken?: StringNullableFilter | string | null
    sessionState?: StringNullableFilter | string | null
    oauthTokenSecret?: StringNullableFilter | string | null
    oauthToken?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refreshToken?: SortOrder
    accessToken?: SortOrder
    tokenType?: SortOrder
    expiresAt?: SortOrder
    scope?: SortOrder
    idToken?: SortOrder
    sessionState?: SortOrder
    oauthTokenSecret?: SortOrder
    oauthToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = {
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
  }

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refreshToken?: SortOrder
    accessToken?: SortOrder
    tokenType?: SortOrder
    expiresAt?: SortOrder
    scope?: SortOrder
    idToken?: SortOrder
    sessionState?: SortOrder
    oauthTokenSecret?: SortOrder
    oauthToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AccountScalarWhereWithAggregatesInput>
    OR?: Enumerable<AccountScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AccountScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    provider?: StringWithAggregatesFilter | string
    providerAccountId?: StringWithAggregatesFilter | string
    refreshToken?: StringNullableWithAggregatesFilter | string | null
    accessToken?: StringNullableWithAggregatesFilter | string | null
    tokenType?: StringNullableWithAggregatesFilter | string | null
    expiresAt?: IntNullableWithAggregatesFilter | number | null
    scope?: StringNullableWithAggregatesFilter | string | null
    idToken?: StringNullableWithAggregatesFilter | string | null
    sessionState?: StringNullableWithAggregatesFilter | string | null
    oauthTokenSecret?: StringNullableWithAggregatesFilter | string | null
    oauthToken?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ProfileWhereInput = {
    AND?: Enumerable<ProfileWhereInput>
    OR?: Enumerable<ProfileWhereInput>
    NOT?: Enumerable<ProfileWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    firstName?: StringFilter | string
    lastName?: StringFilter | string
    latinName?: StringFilter | string
    sex?: StringNullableFilter | string | null
    dob?: StringNullableFilter | string | null
    height?: IntNullableFilter | number | null
    weight?: IntNullableFilter | number | null
    picture?: StringNullableFilter | string | null
    priceMin?: IntNullableFilter | number | null
    priceMax?: IntNullableFilter | number | null
    notifyEmail?: BoolFilter | boolean
    notifyPush?: BoolFilter | boolean
    notifyBadge?: BoolFilter | boolean
    historyId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    specialistDesc?: StringNullableFilter | string | null
    patientCode?: StringNullableFilter | string | null
    allowPatientAssign?: DateTimeNullableFilter | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    latinName?: SortOrder
    sex?: SortOrder
    dob?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    picture?: SortOrder
    priceMin?: SortOrder
    priceMax?: SortOrder
    notifyEmail?: SortOrder
    notifyPush?: SortOrder
    notifyBadge?: SortOrder
    historyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    specialistDesc?: SortOrder
    patientCode?: SortOrder
    allowPatientAssign?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ProfileWhereUniqueInput = {
    id?: string
    userId?: string
    historyId?: string
    patientCode?: string
  }

  export type ProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    latinName?: SortOrder
    sex?: SortOrder
    dob?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    picture?: SortOrder
    priceMin?: SortOrder
    priceMax?: SortOrder
    notifyEmail?: SortOrder
    notifyPush?: SortOrder
    notifyBadge?: SortOrder
    historyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    specialistDesc?: SortOrder
    patientCode?: SortOrder
    allowPatientAssign?: SortOrder
    _count?: ProfileCountOrderByAggregateInput
    _avg?: ProfileAvgOrderByAggregateInput
    _max?: ProfileMaxOrderByAggregateInput
    _min?: ProfileMinOrderByAggregateInput
    _sum?: ProfileSumOrderByAggregateInput
  }

  export type ProfileScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProfileScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProfileScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProfileScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    firstName?: StringWithAggregatesFilter | string
    lastName?: StringWithAggregatesFilter | string
    latinName?: StringWithAggregatesFilter | string
    sex?: StringNullableWithAggregatesFilter | string | null
    dob?: StringNullableWithAggregatesFilter | string | null
    height?: IntNullableWithAggregatesFilter | number | null
    weight?: IntNullableWithAggregatesFilter | number | null
    picture?: StringNullableWithAggregatesFilter | string | null
    priceMin?: IntNullableWithAggregatesFilter | number | null
    priceMax?: IntNullableWithAggregatesFilter | number | null
    notifyEmail?: BoolWithAggregatesFilter | boolean
    notifyPush?: BoolWithAggregatesFilter | boolean
    notifyBadge?: BoolWithAggregatesFilter | boolean
    historyId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    specialistDesc?: StringNullableWithAggregatesFilter | string | null
    patientCode?: StringNullableWithAggregatesFilter | string | null
    allowPatientAssign?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type SessionWhereInput = {
    AND?: Enumerable<SessionWhereInput>
    OR?: Enumerable<SessionWhereInput>
    NOT?: Enumerable<SessionWhereInput>
    id?: StringFilter | string
    sid?: StringFilter | string
    data?: StringFilter | string
    expiresAt?: DateTimeFilter | Date | string
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sid?: SortOrder
    data?: SortOrder
    expiresAt?: SortOrder
  }

  export type SessionWhereUniqueInput = {
    id?: string
    sid?: string
  }

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sid?: SortOrder
    data?: SortOrder
    expiresAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SessionScalarWhereWithAggregatesInput>
    OR?: Enumerable<SessionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SessionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    sid?: StringWithAggregatesFilter | string
    data?: StringWithAggregatesFilter | string
    expiresAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SmsRequestAttemptWhereInput = {
    AND?: Enumerable<SmsRequestAttemptWhereInput>
    OR?: Enumerable<SmsRequestAttemptWhereInput>
    NOT?: Enumerable<SmsRequestAttemptWhereInput>
    id?: StringFilter | string
    phoneNumber?: StringFilter | string
    ipAddress?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
  }

  export type SmsRequestAttemptOrderByWithRelationInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type SmsRequestAttemptWhereUniqueInput = {
    id?: string
  }

  export type SmsRequestAttemptOrderByWithAggregationInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
    _count?: SmsRequestAttemptCountOrderByAggregateInput
    _max?: SmsRequestAttemptMaxOrderByAggregateInput
    _min?: SmsRequestAttemptMinOrderByAggregateInput
  }

  export type SmsRequestAttemptScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SmsRequestAttemptScalarWhereWithAggregatesInput>
    OR?: Enumerable<SmsRequestAttemptScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SmsRequestAttemptScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    phoneNumber?: StringWithAggregatesFilter | string
    ipAddress?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type FileUploadWhereInput = {
    AND?: Enumerable<FileUploadWhereInput>
    OR?: Enumerable<FileUploadWhereInput>
    NOT?: Enumerable<FileUploadWhereInput>
    id?: StringFilter | string
    fileGroup?: StringNullableFilter | string | null
    fileLink?: StringFilter | string
    fileSource?: StringFilter | string
    removedAt?: DateTimeNullableFilter | Date | string | null
    createdBy?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    fileCategory?: StringNullableFilter | string | null
    fileSourceDate?: StringNullableFilter | string | null
    fileMIMEType?: StringFilter | string
  }

  export type FileUploadOrderByWithRelationInput = {
    id?: SortOrder
    fileGroup?: SortOrder
    fileLink?: SortOrder
    fileSource?: SortOrder
    removedAt?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fileCategory?: SortOrder
    fileSourceDate?: SortOrder
    fileMIMEType?: SortOrder
  }

  export type FileUploadWhereUniqueInput = {
    id?: string
  }

  export type FileUploadOrderByWithAggregationInput = {
    id?: SortOrder
    fileGroup?: SortOrder
    fileLink?: SortOrder
    fileSource?: SortOrder
    removedAt?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fileCategory?: SortOrder
    fileSourceDate?: SortOrder
    fileMIMEType?: SortOrder
    _count?: FileUploadCountOrderByAggregateInput
    _max?: FileUploadMaxOrderByAggregateInput
    _min?: FileUploadMinOrderByAggregateInput
  }

  export type FileUploadScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FileUploadScalarWhereWithAggregatesInput>
    OR?: Enumerable<FileUploadScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FileUploadScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    fileGroup?: StringNullableWithAggregatesFilter | string | null
    fileLink?: StringWithAggregatesFilter | string
    fileSource?: StringWithAggregatesFilter | string
    removedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    createdBy?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    fileCategory?: StringNullableWithAggregatesFilter | string | null
    fileSourceDate?: StringNullableWithAggregatesFilter | string | null
    fileMIMEType?: StringWithAggregatesFilter | string
  }

  export type FirebaseTokenWhereInput = {
    AND?: Enumerable<FirebaseTokenWhereInput>
    OR?: Enumerable<FirebaseTokenWhereInput>
    NOT?: Enumerable<FirebaseTokenWhereInput>
    id?: StringFilter | string
    token?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type FirebaseTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FirebaseTokenWhereUniqueInput = {
    id?: string
  }

  export type FirebaseTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FirebaseTokenCountOrderByAggregateInput
    _max?: FirebaseTokenMaxOrderByAggregateInput
    _min?: FirebaseTokenMinOrderByAggregateInput
  }

  export type FirebaseTokenScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FirebaseTokenScalarWhereWithAggregatesInput>
    OR?: Enumerable<FirebaseTokenScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FirebaseTokenScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    token?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type WaitListPhoneNumberWhereInput = {
    AND?: Enumerable<WaitListPhoneNumberWhereInput>
    OR?: Enumerable<WaitListPhoneNumberWhereInput>
    NOT?: Enumerable<WaitListPhoneNumberWhereInput>
    id?: StringFilter | string
    phoneNumber?: StringFilter | string
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type WaitListPhoneNumberOrderByWithRelationInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WaitListPhoneNumberWhereUniqueInput = {
    id?: string
  }

  export type WaitListPhoneNumberOrderByWithAggregationInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WaitListPhoneNumberCountOrderByAggregateInput
    _max?: WaitListPhoneNumberMaxOrderByAggregateInput
    _min?: WaitListPhoneNumberMinOrderByAggregateInput
  }

  export type WaitListPhoneNumberScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WaitListPhoneNumberScalarWhereWithAggregatesInput>
    OR?: Enumerable<WaitListPhoneNumberScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WaitListPhoneNumberScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    phoneNumber?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type HospitalWhereInput = {
    AND?: Enumerable<HospitalWhereInput>
    OR?: Enumerable<HospitalWhereInput>
    NOT?: Enumerable<HospitalWhereInput>
    id?: StringFilter | string
    hospitalLogo?: StringNullableFilter | string | null
    subDomain?: StringNullableFilter | string | null
    phoneNumber?: StringFilter | string
    name?: StringFilter | string
    userId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    User?: XOR<UserRelationFilter, UserWhereInput>
    HospitalUsers?: HospitalUsersListRelationFilter
    subscription?: SubscriptionListRelationFilter
    databaseConnection?: DatabaseConnectionListRelationFilter
    Message?: MessageListRelationFilter
  }

  export type HospitalOrderByWithRelationInput = {
    id?: SortOrder
    hospitalLogo?: SortOrder
    subDomain?: SortOrder
    phoneNumber?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    User?: UserOrderByWithRelationInput
    HospitalUsers?: HospitalUsersOrderByRelationAggregateInput
    subscription?: SubscriptionOrderByRelationAggregateInput
    databaseConnection?: DatabaseConnectionOrderByRelationAggregateInput
    Message?: MessageOrderByRelationAggregateInput
  }

  export type HospitalWhereUniqueInput = {
    id?: string
    subDomain?: string
  }

  export type HospitalOrderByWithAggregationInput = {
    id?: SortOrder
    hospitalLogo?: SortOrder
    subDomain?: SortOrder
    phoneNumber?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HospitalCountOrderByAggregateInput
    _max?: HospitalMaxOrderByAggregateInput
    _min?: HospitalMinOrderByAggregateInput
  }

  export type HospitalScalarWhereWithAggregatesInput = {
    AND?: Enumerable<HospitalScalarWhereWithAggregatesInput>
    OR?: Enumerable<HospitalScalarWhereWithAggregatesInput>
    NOT?: Enumerable<HospitalScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    hospitalLogo?: StringNullableWithAggregatesFilter | string | null
    subDomain?: StringNullableWithAggregatesFilter | string | null
    phoneNumber?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SubscriptionWhereInput = {
    AND?: Enumerable<SubscriptionWhereInput>
    OR?: Enumerable<SubscriptionWhereInput>
    NOT?: Enumerable<SubscriptionWhereInput>
    id?: IntFilter | number
    startDate?: DateTimeNullableFilter | Date | string | null
    endDate?: DateTimeNullableFilter | Date | string | null
    totalDays?: IntFilter | number
    isStart?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    hospitalId?: StringNullableFilter | string | null
    machines?: MachineListRelationFilter
    Hospital?: XOR<HospitalRelationFilter, HospitalWhereInput> | null
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    totalDays?: SortOrder
    isStart?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hospitalId?: SortOrder
    machines?: MachineOrderByRelationAggregateInput
    Hospital?: HospitalOrderByWithRelationInput
  }

  export type SubscriptionWhereUniqueInput = {
    id?: number
  }

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    totalDays?: SortOrder
    isStart?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hospitalId?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _avg?: SubscriptionAvgOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
    _sum?: SubscriptionSumOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SubscriptionScalarWhereWithAggregatesInput>
    OR?: Enumerable<SubscriptionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SubscriptionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    startDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    totalDays?: IntWithAggregatesFilter | number
    isStart?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    hospitalId?: StringNullableWithAggregatesFilter | string | null
  }

  export type MachineWhereInput = {
    AND?: Enumerable<MachineWhereInput>
    OR?: Enumerable<MachineWhereInput>
    NOT?: Enumerable<MachineWhereInput>
    id?: IntFilter | number
    subscriptionId?: IntFilter | number
    machineName?: StringFilter | string
    machineUniqueId?: StringFilter | string
    registeredAt?: DateTimeFilter | Date | string
    subscription?: XOR<SubscriptionRelationFilter, SubscriptionWhereInput>
  }

  export type MachineOrderByWithRelationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    machineName?: SortOrder
    machineUniqueId?: SortOrder
    registeredAt?: SortOrder
    subscription?: SubscriptionOrderByWithRelationInput
  }

  export type MachineWhereUniqueInput = {
    id?: number
    machineUniqueId?: string
  }

  export type MachineOrderByWithAggregationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    machineName?: SortOrder
    machineUniqueId?: SortOrder
    registeredAt?: SortOrder
    _count?: MachineCountOrderByAggregateInput
    _avg?: MachineAvgOrderByAggregateInput
    _max?: MachineMaxOrderByAggregateInput
    _min?: MachineMinOrderByAggregateInput
    _sum?: MachineSumOrderByAggregateInput
  }

  export type MachineScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MachineScalarWhereWithAggregatesInput>
    OR?: Enumerable<MachineScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MachineScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    subscriptionId?: IntWithAggregatesFilter | number
    machineName?: StringWithAggregatesFilter | string
    machineUniqueId?: StringWithAggregatesFilter | string
    registeredAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type HospitalUsersWhereInput = {
    AND?: Enumerable<HospitalUsersWhereInput>
    OR?: Enumerable<HospitalUsersWhereInput>
    NOT?: Enumerable<HospitalUsersWhereInput>
    id?: IntFilter | number
    hospitalId?: StringFilter | string
    phoneNumber?: StringNullableFilter | string | null
    userName?: StringFilter | string
    role?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    hospital?: XOR<HospitalRelationFilter, HospitalWhereInput>
  }

  export type HospitalUsersOrderByWithRelationInput = {
    id?: SortOrder
    hospitalId?: SortOrder
    phoneNumber?: SortOrder
    userName?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hospital?: HospitalOrderByWithRelationInput
  }

  export type HospitalUsersWhereUniqueInput = {
    id?: number
  }

  export type HospitalUsersOrderByWithAggregationInput = {
    id?: SortOrder
    hospitalId?: SortOrder
    phoneNumber?: SortOrder
    userName?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HospitalUsersCountOrderByAggregateInput
    _avg?: HospitalUsersAvgOrderByAggregateInput
    _max?: HospitalUsersMaxOrderByAggregateInput
    _min?: HospitalUsersMinOrderByAggregateInput
    _sum?: HospitalUsersSumOrderByAggregateInput
  }

  export type HospitalUsersScalarWhereWithAggregatesInput = {
    AND?: Enumerable<HospitalUsersScalarWhereWithAggregatesInput>
    OR?: Enumerable<HospitalUsersScalarWhereWithAggregatesInput>
    NOT?: Enumerable<HospitalUsersScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    hospitalId?: StringWithAggregatesFilter | string
    phoneNumber?: StringNullableWithAggregatesFilter | string | null
    userName?: StringWithAggregatesFilter | string
    role?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type DatabaseConnectionWhereInput = {
    AND?: Enumerable<DatabaseConnectionWhereInput>
    OR?: Enumerable<DatabaseConnectionWhereInput>
    NOT?: Enumerable<DatabaseConnectionWhereInput>
    id?: StringFilter | string
    connectionName?: StringFilter | string
    connectionType?: StringFilter | string
    host?: StringFilter | string
    port?: IntFilter | number
    databaseName?: StringFilter | string
    username?: StringFilter | string
    password?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    hospitalId?: StringNullableFilter | string | null
    Hospital?: XOR<HospitalRelationFilter, HospitalWhereInput> | null
  }

  export type DatabaseConnectionOrderByWithRelationInput = {
    id?: SortOrder
    connectionName?: SortOrder
    connectionType?: SortOrder
    host?: SortOrder
    port?: SortOrder
    databaseName?: SortOrder
    username?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hospitalId?: SortOrder
    Hospital?: HospitalOrderByWithRelationInput
  }

  export type DatabaseConnectionWhereUniqueInput = {
    id?: string
  }

  export type DatabaseConnectionOrderByWithAggregationInput = {
    id?: SortOrder
    connectionName?: SortOrder
    connectionType?: SortOrder
    host?: SortOrder
    port?: SortOrder
    databaseName?: SortOrder
    username?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hospitalId?: SortOrder
    _count?: DatabaseConnectionCountOrderByAggregateInput
    _avg?: DatabaseConnectionAvgOrderByAggregateInput
    _max?: DatabaseConnectionMaxOrderByAggregateInput
    _min?: DatabaseConnectionMinOrderByAggregateInput
    _sum?: DatabaseConnectionSumOrderByAggregateInput
  }

  export type DatabaseConnectionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DatabaseConnectionScalarWhereWithAggregatesInput>
    OR?: Enumerable<DatabaseConnectionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DatabaseConnectionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    connectionName?: StringWithAggregatesFilter | string
    connectionType?: StringWithAggregatesFilter | string
    host?: StringWithAggregatesFilter | string
    port?: IntWithAggregatesFilter | number
    databaseName?: StringWithAggregatesFilter | string
    username?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    hospitalId?: StringNullableWithAggregatesFilter | string | null
  }

  export type ProductWhereInput = {
    AND?: Enumerable<ProductWhereInput>
    OR?: Enumerable<ProductWhereInput>
    NOT?: Enumerable<ProductWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    productDescription?: JsonNullableFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    ProductVariant?: ProductVariantListRelationFilter
    ProductPayment?: ProductPaymentListRelationFilter
    QPayInvoice?: QPayInvoiceListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    productDescription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ProductVariant?: ProductVariantOrderByRelationAggregateInput
    ProductPayment?: ProductPaymentOrderByRelationAggregateInput
    QPayInvoice?: QPayInvoiceOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = {
    id?: string
  }

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    productDescription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    productDescription?: JsonNullableWithAggregatesFilter
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ProductVariantWhereInput = {
    AND?: Enumerable<ProductVariantWhereInput>
    OR?: Enumerable<ProductVariantWhereInput>
    NOT?: Enumerable<ProductVariantWhereInput>
    id?: StringFilter | string
    productId?: StringFilter | string
    name?: StringFilter | string
    price?: IntFilter | number
    unit?: IntFilter | number
    duration?: IntFilter | number
    discount?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    sits?: IntNullableListFilter
    Product?: XOR<ProductRelationFilter, ProductWhereInput>
    ProductPayment?: ProductPaymentListRelationFilter
    QPayInvoice?: QPayInvoiceListRelationFilter
  }

  export type ProductVariantOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    unit?: SortOrder
    duration?: SortOrder
    discount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sits?: SortOrder
    Product?: ProductOrderByWithRelationInput
    ProductPayment?: ProductPaymentOrderByRelationAggregateInput
    QPayInvoice?: QPayInvoiceOrderByRelationAggregateInput
  }

  export type ProductVariantWhereUniqueInput = {
    id?: string
  }

  export type ProductVariantOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    unit?: SortOrder
    duration?: SortOrder
    discount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sits?: SortOrder
    _count?: ProductVariantCountOrderByAggregateInput
    _avg?: ProductVariantAvgOrderByAggregateInput
    _max?: ProductVariantMaxOrderByAggregateInput
    _min?: ProductVariantMinOrderByAggregateInput
    _sum?: ProductVariantSumOrderByAggregateInput
  }

  export type ProductVariantScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductVariantScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductVariantScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductVariantScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    productId?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    price?: IntWithAggregatesFilter | number
    unit?: IntWithAggregatesFilter | number
    duration?: IntWithAggregatesFilter | number
    discount?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    sits?: IntNullableListFilter
  }

  export type ProductPaymentWhereInput = {
    AND?: Enumerable<ProductPaymentWhereInput>
    OR?: Enumerable<ProductPaymentWhereInput>
    NOT?: Enumerable<ProductPaymentWhereInput>
    id?: StringFilter | string
    paidSource?: StringNullableFilter | string | null
    paidAmount?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    paidDate?: DateTimeNullableFilter | Date | string | null
    additionalNote?: StringFilter | string
    productId?: StringFilter | string
    productVariantId?: StringFilter | string
    userId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    paymentStatus?: StringFilter | string
    Product?: XOR<ProductRelationFilter, ProductWhereInput>
    ProductVariant?: XOR<ProductVariantRelationFilter, ProductVariantWhereInput>
    User?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ProductPaymentOrderByWithRelationInput = {
    id?: SortOrder
    paidSource?: SortOrder
    paidAmount?: SortOrder
    paidDate?: SortOrder
    additionalNote?: SortOrder
    productId?: SortOrder
    productVariantId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paymentStatus?: SortOrder
    Product?: ProductOrderByWithRelationInput
    ProductVariant?: ProductVariantOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type ProductPaymentWhereUniqueInput = {
    id?: string
  }

  export type ProductPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    paidSource?: SortOrder
    paidAmount?: SortOrder
    paidDate?: SortOrder
    additionalNote?: SortOrder
    productId?: SortOrder
    productVariantId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paymentStatus?: SortOrder
    _count?: ProductPaymentCountOrderByAggregateInput
    _avg?: ProductPaymentAvgOrderByAggregateInput
    _max?: ProductPaymentMaxOrderByAggregateInput
    _min?: ProductPaymentMinOrderByAggregateInput
    _sum?: ProductPaymentSumOrderByAggregateInput
  }

  export type ProductPaymentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductPaymentScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductPaymentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductPaymentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    paidSource?: StringNullableWithAggregatesFilter | string | null
    paidAmount?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    paidDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    additionalNote?: StringWithAggregatesFilter | string
    productId?: StringWithAggregatesFilter | string
    productVariantId?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    paymentStatus?: StringWithAggregatesFilter | string
  }

  export type QPayInvoiceWhereInput = {
    AND?: Enumerable<QPayInvoiceWhereInput>
    OR?: Enumerable<QPayInvoiceWhereInput>
    NOT?: Enumerable<QPayInvoiceWhereInput>
    id?: StringFilter | string
    productId?: StringFilter | string
    productVariantId?: StringFilter | string
    invoiceData?: JsonNullableFilter
    userId?: StringNullableFilter | string | null
    payedDate?: DateTimeNullableFilter | Date | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    Product?: XOR<ProductRelationFilter, ProductWhereInput>
    ProductVariant?: XOR<ProductVariantRelationFilter, ProductVariantWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput> | null
  }

  export type QPayInvoiceOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    productVariantId?: SortOrder
    invoiceData?: SortOrder
    userId?: SortOrder
    payedDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Product?: ProductOrderByWithRelationInput
    ProductVariant?: ProductVariantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type QPayInvoiceWhereUniqueInput = {
    id?: string
  }

  export type QPayInvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    productVariantId?: SortOrder
    invoiceData?: SortOrder
    userId?: SortOrder
    payedDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QPayInvoiceCountOrderByAggregateInput
    _max?: QPayInvoiceMaxOrderByAggregateInput
    _min?: QPayInvoiceMinOrderByAggregateInput
  }

  export type QPayInvoiceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<QPayInvoiceScalarWhereWithAggregatesInput>
    OR?: Enumerable<QPayInvoiceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<QPayInvoiceScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    productId?: StringWithAggregatesFilter | string
    productVariantId?: StringWithAggregatesFilter | string
    invoiceData?: JsonNullableWithAggregatesFilter
    userId?: StringNullableWithAggregatesFilter | string | null
    payedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type MessageWhereInput = {
    AND?: Enumerable<MessageWhereInput>
    OR?: Enumerable<MessageWhereInput>
    NOT?: Enumerable<MessageWhereInput>
    id?: StringFilter | string
    phoneNumber?: StringFilter | string
    message?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    hospitalId?: StringFilter | string
    hospital?: XOR<HospitalRelationFilter, HospitalWhereInput>
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hospitalId?: SortOrder
    hospital?: HospitalOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = {
    id?: string
  }

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hospitalId?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MessageScalarWhereWithAggregatesInput>
    OR?: Enumerable<MessageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MessageScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    phoneNumber?: StringWithAggregatesFilter | string
    message?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    hospitalId?: StringWithAggregatesFilter | string
  }

  export type PromoCodeWhereInput = {
    AND?: Enumerable<PromoCodeWhereInput>
    OR?: Enumerable<PromoCodeWhereInput>
    NOT?: Enumerable<PromoCodeWhereInput>
    id?: StringFilter | string
    code?: StringFilter | string
    promoImageUrl?: StringFilter | string
    description?: StringFilter | string
    expiryDate?: DateTimeNullableFilter | Date | string | null
    isActive?: BoolFilter | boolean
    fixedAmount?: DecimalFilter | Decimal | DecimalJsLike | number | string
    percentageAmount?: DecimalFilter | Decimal | DecimalJsLike | number | string
    maxUses?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    userPromoCode?: UserPromoCodeListRelationFilter
  }

  export type PromoCodeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    promoImageUrl?: SortOrder
    description?: SortOrder
    expiryDate?: SortOrder
    isActive?: SortOrder
    fixedAmount?: SortOrder
    percentageAmount?: SortOrder
    maxUses?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userPromoCode?: UserPromoCodeOrderByRelationAggregateInput
  }

  export type PromoCodeWhereUniqueInput = {
    id?: string
  }

  export type PromoCodeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    promoImageUrl?: SortOrder
    description?: SortOrder
    expiryDate?: SortOrder
    isActive?: SortOrder
    fixedAmount?: SortOrder
    percentageAmount?: SortOrder
    maxUses?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PromoCodeCountOrderByAggregateInput
    _avg?: PromoCodeAvgOrderByAggregateInput
    _max?: PromoCodeMaxOrderByAggregateInput
    _min?: PromoCodeMinOrderByAggregateInput
    _sum?: PromoCodeSumOrderByAggregateInput
  }

  export type PromoCodeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PromoCodeScalarWhereWithAggregatesInput>
    OR?: Enumerable<PromoCodeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PromoCodeScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    promoImageUrl?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    expiryDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    isActive?: BoolWithAggregatesFilter | boolean
    fixedAmount?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    percentageAmount?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    maxUses?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserPromoCodeWhereInput = {
    AND?: Enumerable<UserPromoCodeWhereInput>
    OR?: Enumerable<UserPromoCodeWhereInput>
    NOT?: Enumerable<UserPromoCodeWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    promoCodeId?: StringFilter | string
    promoCodeUsedAt?: DateTimeNullableFilter | Date | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    promoCode?: XOR<PromoCodeRelationFilter, PromoCodeWhereInput>
  }

  export type UserPromoCodeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    promoCodeId?: SortOrder
    promoCodeUsedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    promoCode?: PromoCodeOrderByWithRelationInput
  }

  export type UserPromoCodeWhereUniqueInput = {
    id?: string
  }

  export type UserPromoCodeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    promoCodeId?: SortOrder
    promoCodeUsedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserPromoCodeCountOrderByAggregateInput
    _max?: UserPromoCodeMaxOrderByAggregateInput
    _min?: UserPromoCodeMinOrderByAggregateInput
  }

  export type UserPromoCodeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserPromoCodeScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserPromoCodeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserPromoCodeScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    promoCodeId?: StringWithAggregatesFilter | string
    promoCodeUsedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type FreeTrialWhereInput = {
    AND?: Enumerable<FreeTrialWhereInput>
    OR?: Enumerable<FreeTrialWhereInput>
    NOT?: Enumerable<FreeTrialWhereInput>
    id?: StringFilter | string
    hospitalName?: StringFilter | string
    phoneNumber?: StringFilter | string
    hospitalChair?: StringFilter | string
    registrationNumber?: StringFilter | string
    directorInfo?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type FreeTrialOrderByWithRelationInput = {
    id?: SortOrder
    hospitalName?: SortOrder
    phoneNumber?: SortOrder
    hospitalChair?: SortOrder
    registrationNumber?: SortOrder
    directorInfo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FreeTrialWhereUniqueInput = {
    id?: string
  }

  export type FreeTrialOrderByWithAggregationInput = {
    id?: SortOrder
    hospitalName?: SortOrder
    phoneNumber?: SortOrder
    hospitalChair?: SortOrder
    registrationNumber?: SortOrder
    directorInfo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FreeTrialCountOrderByAggregateInput
    _max?: FreeTrialMaxOrderByAggregateInput
    _min?: FreeTrialMinOrderByAggregateInput
  }

  export type FreeTrialScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FreeTrialScalarWhereWithAggregatesInput>
    OR?: Enumerable<FreeTrialScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FreeTrialScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    hospitalName?: StringWithAggregatesFilter | string
    phoneNumber?: StringWithAggregatesFilter | string
    hospitalChair?: StringWithAggregatesFilter | string
    registrationNumber?: StringWithAggregatesFilter | string
    directorInfo?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email?: string | null
    emailVerified?: Date | string | null
    passwordDigest?: string | null
    phoneNumber: string
    phoneNumberVerified?: Date | string | null
    role?: UserRole
    inviteToken?: string | null
    isTokenUsed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invitedBy?: string | null
    pin?: string | null
    pinCreatedAt?: Date | string | null
    pinType?: string | null
    pinVerifiedAt?: Date | string | null
    hospitalId?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    hospital?: HospitalCreateNestedManyWithoutUserInput
    ProductPayment?: ProductPaymentCreateNestedManyWithoutUserInput
    QPayInvoice?: QPayInvoiceCreateNestedManyWithoutUserInput
    UserPromoCode?: UserPromoCodeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email?: string | null
    emailVerified?: Date | string | null
    passwordDigest?: string | null
    phoneNumber: string
    phoneNumberVerified?: Date | string | null
    role?: UserRole
    inviteToken?: string | null
    isTokenUsed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invitedBy?: string | null
    pin?: string | null
    pinCreatedAt?: Date | string | null
    pinType?: string | null
    pinVerifiedAt?: Date | string | null
    hospitalId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    hospital?: HospitalUncheckedCreateNestedManyWithoutUserInput
    ProductPayment?: ProductPaymentUncheckedCreateNestedManyWithoutUserInput
    QPayInvoice?: QPayInvoiceUncheckedCreateNestedManyWithoutUserInput
    UserPromoCode?: UserPromoCodeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordDigest?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneNumberVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    isTokenUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    pinCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pinType?: NullableStringFieldUpdateOperationsInput | string | null
    pinVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hospitalId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    hospital?: HospitalUpdateManyWithoutUserNestedInput
    ProductPayment?: ProductPaymentUpdateManyWithoutUserNestedInput
    QPayInvoice?: QPayInvoiceUpdateManyWithoutUserNestedInput
    UserPromoCode?: UserPromoCodeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordDigest?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneNumberVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    isTokenUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    pinCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pinType?: NullableStringFieldUpdateOperationsInput | string | null
    pinVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hospitalId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    hospital?: HospitalUncheckedUpdateManyWithoutUserNestedInput
    ProductPayment?: ProductPaymentUncheckedUpdateManyWithoutUserNestedInput
    QPayInvoice?: QPayInvoiceUncheckedUpdateManyWithoutUserNestedInput
    UserPromoCode?: UserPromoCodeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email?: string | null
    emailVerified?: Date | string | null
    passwordDigest?: string | null
    phoneNumber: string
    phoneNumberVerified?: Date | string | null
    role?: UserRole
    inviteToken?: string | null
    isTokenUsed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invitedBy?: string | null
    pin?: string | null
    pinCreatedAt?: Date | string | null
    pinType?: string | null
    pinVerifiedAt?: Date | string | null
    hospitalId?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordDigest?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneNumberVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    isTokenUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    pinCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pinType?: NullableStringFieldUpdateOperationsInput | string | null
    pinVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hospitalId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordDigest?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneNumberVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    isTokenUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    pinCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pinType?: NullableStringFieldUpdateOperationsInput | string | null
    pinVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hospitalId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refreshToken?: string | null
    accessToken?: string | null
    tokenType?: string | null
    expiresAt?: number | null
    scope?: string | null
    idToken?: string | null
    sessionState?: string | null
    oauthTokenSecret?: string | null
    oauthToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refreshToken?: string | null
    accessToken?: string | null
    tokenType?: string | null
    expiresAt?: number | null
    scope?: string | null
    idToken?: string | null
    sessionState?: string | null
    oauthTokenSecret?: string | null
    oauthToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableIntFieldUpdateOperationsInput | number | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionState?: NullableStringFieldUpdateOperationsInput | string | null
    oauthTokenSecret?: NullableStringFieldUpdateOperationsInput | string | null
    oauthToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableIntFieldUpdateOperationsInput | number | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionState?: NullableStringFieldUpdateOperationsInput | string | null
    oauthTokenSecret?: NullableStringFieldUpdateOperationsInput | string | null
    oauthToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refreshToken?: string | null
    accessToken?: string | null
    tokenType?: string | null
    expiresAt?: number | null
    scope?: string | null
    idToken?: string | null
    sessionState?: string | null
    oauthTokenSecret?: string | null
    oauthToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableIntFieldUpdateOperationsInput | number | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionState?: NullableStringFieldUpdateOperationsInput | string | null
    oauthTokenSecret?: NullableStringFieldUpdateOperationsInput | string | null
    oauthToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableIntFieldUpdateOperationsInput | number | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionState?: NullableStringFieldUpdateOperationsInput | string | null
    oauthTokenSecret?: NullableStringFieldUpdateOperationsInput | string | null
    oauthToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileCreateInput = {
    id?: string
    firstName?: string
    lastName?: string
    latinName?: string
    sex?: string | null
    dob?: string | null
    height?: number | null
    weight?: number | null
    picture?: string | null
    priceMin?: number | null
    priceMax?: number | null
    notifyEmail?: boolean
    notifyPush?: boolean
    notifyBadge?: boolean
    historyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    specialistDesc?: string | null
    patientCode?: string | null
    allowPatientAssign?: Date | string | null
    user: UserCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    latinName?: string
    sex?: string | null
    dob?: string | null
    height?: number | null
    weight?: number | null
    picture?: string | null
    priceMin?: number | null
    priceMax?: number | null
    notifyEmail?: boolean
    notifyPush?: boolean
    notifyBadge?: boolean
    historyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    specialistDesc?: string | null
    patientCode?: string | null
    allowPatientAssign?: Date | string | null
  }

  export type ProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    latinName?: StringFieldUpdateOperationsInput | string
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    priceMin?: NullableIntFieldUpdateOperationsInput | number | null
    priceMax?: NullableIntFieldUpdateOperationsInput | number | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    notifyBadge?: BoolFieldUpdateOperationsInput | boolean
    historyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    specialistDesc?: NullableStringFieldUpdateOperationsInput | string | null
    patientCode?: NullableStringFieldUpdateOperationsInput | string | null
    allowPatientAssign?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    latinName?: StringFieldUpdateOperationsInput | string
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    priceMin?: NullableIntFieldUpdateOperationsInput | number | null
    priceMax?: NullableIntFieldUpdateOperationsInput | number | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    notifyBadge?: BoolFieldUpdateOperationsInput | boolean
    historyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    specialistDesc?: NullableStringFieldUpdateOperationsInput | string | null
    patientCode?: NullableStringFieldUpdateOperationsInput | string | null
    allowPatientAssign?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProfileCreateManyInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    latinName?: string
    sex?: string | null
    dob?: string | null
    height?: number | null
    weight?: number | null
    picture?: string | null
    priceMin?: number | null
    priceMax?: number | null
    notifyEmail?: boolean
    notifyPush?: boolean
    notifyBadge?: boolean
    historyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    specialistDesc?: string | null
    patientCode?: string | null
    allowPatientAssign?: Date | string | null
  }

  export type ProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    latinName?: StringFieldUpdateOperationsInput | string
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    priceMin?: NullableIntFieldUpdateOperationsInput | number | null
    priceMax?: NullableIntFieldUpdateOperationsInput | number | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    notifyBadge?: BoolFieldUpdateOperationsInput | boolean
    historyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    specialistDesc?: NullableStringFieldUpdateOperationsInput | string | null
    patientCode?: NullableStringFieldUpdateOperationsInput | string | null
    allowPatientAssign?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    latinName?: StringFieldUpdateOperationsInput | string
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    priceMin?: NullableIntFieldUpdateOperationsInput | number | null
    priceMax?: NullableIntFieldUpdateOperationsInput | number | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    notifyBadge?: BoolFieldUpdateOperationsInput | boolean
    historyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    specialistDesc?: NullableStringFieldUpdateOperationsInput | string | null
    patientCode?: NullableStringFieldUpdateOperationsInput | string | null
    allowPatientAssign?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionCreateInput = {
    id: string
    sid: string
    data: string
    expiresAt: Date | string
  }

  export type SessionUncheckedCreateInput = {
    id: string
    sid: string
    data: string
    expiresAt: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sid?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sid?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id: string
    sid: string
    data: string
    expiresAt: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sid?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sid?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SmsRequestAttemptCreateInput = {
    id?: string
    phoneNumber: string
    ipAddress: string
    createdAt?: Date | string
  }

  export type SmsRequestAttemptUncheckedCreateInput = {
    id?: string
    phoneNumber: string
    ipAddress: string
    createdAt?: Date | string
  }

  export type SmsRequestAttemptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SmsRequestAttemptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SmsRequestAttemptCreateManyInput = {
    id?: string
    phoneNumber: string
    ipAddress: string
    createdAt?: Date | string
  }

  export type SmsRequestAttemptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SmsRequestAttemptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUploadCreateInput = {
    id?: string
    fileGroup?: string | null
    fileLink: string
    fileSource: string
    removedAt?: Date | string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fileCategory?: string | null
    fileSourceDate?: string | null
    fileMIMEType: string
  }

  export type FileUploadUncheckedCreateInput = {
    id?: string
    fileGroup?: string | null
    fileLink: string
    fileSource: string
    removedAt?: Date | string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fileCategory?: string | null
    fileSourceDate?: string | null
    fileMIMEType: string
  }

  export type FileUploadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileGroup?: NullableStringFieldUpdateOperationsInput | string | null
    fileLink?: StringFieldUpdateOperationsInput | string
    fileSource?: StringFieldUpdateOperationsInput | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileCategory?: NullableStringFieldUpdateOperationsInput | string | null
    fileSourceDate?: NullableStringFieldUpdateOperationsInput | string | null
    fileMIMEType?: StringFieldUpdateOperationsInput | string
  }

  export type FileUploadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileGroup?: NullableStringFieldUpdateOperationsInput | string | null
    fileLink?: StringFieldUpdateOperationsInput | string
    fileSource?: StringFieldUpdateOperationsInput | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileCategory?: NullableStringFieldUpdateOperationsInput | string | null
    fileSourceDate?: NullableStringFieldUpdateOperationsInput | string | null
    fileMIMEType?: StringFieldUpdateOperationsInput | string
  }

  export type FileUploadCreateManyInput = {
    id?: string
    fileGroup?: string | null
    fileLink: string
    fileSource: string
    removedAt?: Date | string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fileCategory?: string | null
    fileSourceDate?: string | null
    fileMIMEType: string
  }

  export type FileUploadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileGroup?: NullableStringFieldUpdateOperationsInput | string | null
    fileLink?: StringFieldUpdateOperationsInput | string
    fileSource?: StringFieldUpdateOperationsInput | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileCategory?: NullableStringFieldUpdateOperationsInput | string | null
    fileSourceDate?: NullableStringFieldUpdateOperationsInput | string | null
    fileMIMEType?: StringFieldUpdateOperationsInput | string
  }

  export type FileUploadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileGroup?: NullableStringFieldUpdateOperationsInput | string | null
    fileLink?: StringFieldUpdateOperationsInput | string
    fileSource?: StringFieldUpdateOperationsInput | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileCategory?: NullableStringFieldUpdateOperationsInput | string | null
    fileSourceDate?: NullableStringFieldUpdateOperationsInput | string | null
    fileMIMEType?: StringFieldUpdateOperationsInput | string
  }

  export type FirebaseTokenCreateInput = {
    id?: string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FirebaseTokenUncheckedCreateInput = {
    id?: string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FirebaseTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FirebaseTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FirebaseTokenCreateManyInput = {
    id?: string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FirebaseTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FirebaseTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WaitListPhoneNumberCreateInput = {
    id?: string
    phoneNumber: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WaitListPhoneNumberUncheckedCreateInput = {
    id?: string
    phoneNumber: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WaitListPhoneNumberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WaitListPhoneNumberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WaitListPhoneNumberCreateManyInput = {
    id?: string
    phoneNumber: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WaitListPhoneNumberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WaitListPhoneNumberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HospitalCreateInput = {
    id?: string
    hospitalLogo?: string | null
    subDomain?: string | null
    phoneNumber: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    User: UserCreateNestedOneWithoutHospitalInput
    HospitalUsers?: HospitalUsersCreateNestedManyWithoutHospitalInput
    subscription?: SubscriptionCreateNestedManyWithoutHospitalInput
    databaseConnection?: DatabaseConnectionCreateNestedManyWithoutHospitalInput
    Message?: MessageCreateNestedManyWithoutHospitalInput
  }

  export type HospitalUncheckedCreateInput = {
    id?: string
    hospitalLogo?: string | null
    subDomain?: string | null
    phoneNumber: string
    name: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    HospitalUsers?: HospitalUsersUncheckedCreateNestedManyWithoutHospitalInput
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutHospitalInput
    databaseConnection?: DatabaseConnectionUncheckedCreateNestedManyWithoutHospitalInput
    Message?: MessageUncheckedCreateNestedManyWithoutHospitalInput
  }

  export type HospitalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hospitalLogo?: NullableStringFieldUpdateOperationsInput | string | null
    subDomain?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutHospitalNestedInput
    HospitalUsers?: HospitalUsersUpdateManyWithoutHospitalNestedInput
    subscription?: SubscriptionUpdateManyWithoutHospitalNestedInput
    databaseConnection?: DatabaseConnectionUpdateManyWithoutHospitalNestedInput
    Message?: MessageUpdateManyWithoutHospitalNestedInput
  }

  export type HospitalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hospitalLogo?: NullableStringFieldUpdateOperationsInput | string | null
    subDomain?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    HospitalUsers?: HospitalUsersUncheckedUpdateManyWithoutHospitalNestedInput
    subscription?: SubscriptionUncheckedUpdateManyWithoutHospitalNestedInput
    databaseConnection?: DatabaseConnectionUncheckedUpdateManyWithoutHospitalNestedInput
    Message?: MessageUncheckedUpdateManyWithoutHospitalNestedInput
  }

  export type HospitalCreateManyInput = {
    id?: string
    hospitalLogo?: string | null
    subDomain?: string | null
    phoneNumber: string
    name: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HospitalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    hospitalLogo?: NullableStringFieldUpdateOperationsInput | string | null
    subDomain?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HospitalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    hospitalLogo?: NullableStringFieldUpdateOperationsInput | string | null
    subDomain?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateInput = {
    startDate?: Date | string | null
    endDate?: Date | string | null
    totalDays?: number
    isStart?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    machines?: MachineCreateNestedManyWithoutSubscriptionInput
    Hospital?: HospitalCreateNestedOneWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    totalDays?: number
    isStart?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    hospitalId?: string | null
    machines?: MachineUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUpdateInput = {
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalDays?: IntFieldUpdateOperationsInput | number
    isStart?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    machines?: MachineUpdateManyWithoutSubscriptionNestedInput
    Hospital?: HospitalUpdateOneWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalDays?: IntFieldUpdateOperationsInput | number
    isStart?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hospitalId?: NullableStringFieldUpdateOperationsInput | string | null
    machines?: MachineUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionCreateManyInput = {
    id?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    totalDays?: number
    isStart?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    hospitalId?: string | null
  }

  export type SubscriptionUpdateManyMutationInput = {
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalDays?: IntFieldUpdateOperationsInput | number
    isStart?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalDays?: IntFieldUpdateOperationsInput | number
    isStart?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hospitalId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MachineCreateInput = {
    machineName: string
    machineUniqueId: string
    registeredAt?: Date | string
    subscription: SubscriptionCreateNestedOneWithoutMachinesInput
  }

  export type MachineUncheckedCreateInput = {
    id?: number
    subscriptionId: number
    machineName: string
    machineUniqueId: string
    registeredAt?: Date | string
  }

  export type MachineUpdateInput = {
    machineName?: StringFieldUpdateOperationsInput | string
    machineUniqueId?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateOneRequiredWithoutMachinesNestedInput
  }

  export type MachineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    subscriptionId?: IntFieldUpdateOperationsInput | number
    machineName?: StringFieldUpdateOperationsInput | string
    machineUniqueId?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineCreateManyInput = {
    id?: number
    subscriptionId: number
    machineName: string
    machineUniqueId: string
    registeredAt?: Date | string
  }

  export type MachineUpdateManyMutationInput = {
    machineName?: StringFieldUpdateOperationsInput | string
    machineUniqueId?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    subscriptionId?: IntFieldUpdateOperationsInput | number
    machineName?: StringFieldUpdateOperationsInput | string
    machineUniqueId?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HospitalUsersCreateInput = {
    phoneNumber?: string | null
    userName: string
    role?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hospital: HospitalCreateNestedOneWithoutHospitalUsersInput
  }

  export type HospitalUsersUncheckedCreateInput = {
    id?: number
    hospitalId: string
    phoneNumber?: string | null
    userName: string
    role?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HospitalUsersUpdateInput = {
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hospital?: HospitalUpdateOneRequiredWithoutHospitalUsersNestedInput
  }

  export type HospitalUsersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospitalId?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HospitalUsersCreateManyInput = {
    id?: number
    hospitalId: string
    phoneNumber?: string | null
    userName: string
    role?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HospitalUsersUpdateManyMutationInput = {
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HospitalUsersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospitalId?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatabaseConnectionCreateInput = {
    id?: string
    connectionName: string
    connectionType: string
    host: string
    port: number
    databaseName: string
    username: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Hospital?: HospitalCreateNestedOneWithoutDatabaseConnectionInput
  }

  export type DatabaseConnectionUncheckedCreateInput = {
    id?: string
    connectionName: string
    connectionType: string
    host: string
    port: number
    databaseName: string
    username: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    hospitalId?: string | null
  }

  export type DatabaseConnectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectionName?: StringFieldUpdateOperationsInput | string
    connectionType?: StringFieldUpdateOperationsInput | string
    host?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    databaseName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Hospital?: HospitalUpdateOneWithoutDatabaseConnectionNestedInput
  }

  export type DatabaseConnectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectionName?: StringFieldUpdateOperationsInput | string
    connectionType?: StringFieldUpdateOperationsInput | string
    host?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    databaseName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hospitalId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DatabaseConnectionCreateManyInput = {
    id?: string
    connectionName: string
    connectionType: string
    host: string
    port: number
    databaseName: string
    username: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    hospitalId?: string | null
  }

  export type DatabaseConnectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectionName?: StringFieldUpdateOperationsInput | string
    connectionType?: StringFieldUpdateOperationsInput | string
    host?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    databaseName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatabaseConnectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectionName?: StringFieldUpdateOperationsInput | string
    connectionType?: StringFieldUpdateOperationsInput | string
    host?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    databaseName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hospitalId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCreateInput = {
    id?: string
    name: string
    productDescription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ProductVariant?: ProductVariantCreateNestedManyWithoutProductInput
    ProductPayment?: ProductPaymentCreateNestedManyWithoutProductInput
    QPayInvoice?: QPayInvoiceCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    name: string
    productDescription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ProductVariant?: ProductVariantUncheckedCreateNestedManyWithoutProductInput
    ProductPayment?: ProductPaymentUncheckedCreateNestedManyWithoutProductInput
    QPayInvoice?: QPayInvoiceUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    productDescription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ProductVariant?: ProductVariantUpdateManyWithoutProductNestedInput
    ProductPayment?: ProductPaymentUpdateManyWithoutProductNestedInput
    QPayInvoice?: QPayInvoiceUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    productDescription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ProductVariant?: ProductVariantUncheckedUpdateManyWithoutProductNestedInput
    ProductPayment?: ProductPaymentUncheckedUpdateManyWithoutProductNestedInput
    QPayInvoice?: QPayInvoiceUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    name: string
    productDescription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    productDescription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    productDescription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariantCreateInput = {
    id?: string
    name: string
    price: number
    unit: number
    duration: number
    discount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sits?: ProductVariantCreatesitsInput | Enumerable<number>
    Product: ProductCreateNestedOneWithoutProductVariantInput
    ProductPayment?: ProductPaymentCreateNestedManyWithoutProductVariantInput
    QPayInvoice?: QPayInvoiceCreateNestedManyWithoutProductVariantInput
  }

  export type ProductVariantUncheckedCreateInput = {
    id?: string
    productId: string
    name: string
    price: number
    unit: number
    duration: number
    discount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sits?: ProductVariantCreatesitsInput | Enumerable<number>
    ProductPayment?: ProductPaymentUncheckedCreateNestedManyWithoutProductVariantInput
    QPayInvoice?: QPayInvoiceUncheckedCreateNestedManyWithoutProductVariantInput
  }

  export type ProductVariantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    unit?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sits?: ProductVariantUpdatesitsInput | Enumerable<number>
    Product?: ProductUpdateOneRequiredWithoutProductVariantNestedInput
    ProductPayment?: ProductPaymentUpdateManyWithoutProductVariantNestedInput
    QPayInvoice?: QPayInvoiceUpdateManyWithoutProductVariantNestedInput
  }

  export type ProductVariantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    unit?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sits?: ProductVariantUpdatesitsInput | Enumerable<number>
    ProductPayment?: ProductPaymentUncheckedUpdateManyWithoutProductVariantNestedInput
    QPayInvoice?: QPayInvoiceUncheckedUpdateManyWithoutProductVariantNestedInput
  }

  export type ProductVariantCreateManyInput = {
    id?: string
    productId: string
    name: string
    price: number
    unit: number
    duration: number
    discount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sits?: ProductVariantCreatesitsInput | Enumerable<number>
  }

  export type ProductVariantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    unit?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sits?: ProductVariantUpdatesitsInput | Enumerable<number>
  }

  export type ProductVariantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    unit?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sits?: ProductVariantUpdatesitsInput | Enumerable<number>
  }

  export type ProductPaymentCreateInput = {
    id?: string
    paidSource?: string | null
    paidAmount?: Decimal | DecimalJsLike | number | string | null
    paidDate?: Date | string | null
    additionalNote?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentStatus: string
    Product: ProductCreateNestedOneWithoutProductPaymentInput
    ProductVariant: ProductVariantCreateNestedOneWithoutProductPaymentInput
    User: UserCreateNestedOneWithoutProductPaymentInput
  }

  export type ProductPaymentUncheckedCreateInput = {
    id?: string
    paidSource?: string | null
    paidAmount?: Decimal | DecimalJsLike | number | string | null
    paidDate?: Date | string | null
    additionalNote?: string
    productId: string
    productVariantId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentStatus: string
  }

  export type ProductPaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paidSource?: NullableStringFieldUpdateOperationsInput | string | null
    paidAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    additionalNote?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    Product?: ProductUpdateOneRequiredWithoutProductPaymentNestedInput
    ProductVariant?: ProductVariantUpdateOneRequiredWithoutProductPaymentNestedInput
    User?: UserUpdateOneRequiredWithoutProductPaymentNestedInput
  }

  export type ProductPaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paidSource?: NullableStringFieldUpdateOperationsInput | string | null
    paidAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    additionalNote?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    productVariantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
  }

  export type ProductPaymentCreateManyInput = {
    id?: string
    paidSource?: string | null
    paidAmount?: Decimal | DecimalJsLike | number | string | null
    paidDate?: Date | string | null
    additionalNote?: string
    productId: string
    productVariantId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentStatus: string
  }

  export type ProductPaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    paidSource?: NullableStringFieldUpdateOperationsInput | string | null
    paidAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    additionalNote?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
  }

  export type ProductPaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    paidSource?: NullableStringFieldUpdateOperationsInput | string | null
    paidAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    additionalNote?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    productVariantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
  }

  export type QPayInvoiceCreateInput = {
    id?: string
    invoiceData?: NullableJsonNullValueInput | InputJsonValue
    payedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Product: ProductCreateNestedOneWithoutQPayInvoiceInput
    ProductVariant: ProductVariantCreateNestedOneWithoutQPayInvoiceInput
    user?: UserCreateNestedOneWithoutQPayInvoiceInput
  }

  export type QPayInvoiceUncheckedCreateInput = {
    id?: string
    productId: string
    productVariantId: string
    invoiceData?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    payedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QPayInvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceData?: NullableJsonNullValueInput | InputJsonValue
    payedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Product?: ProductUpdateOneRequiredWithoutQPayInvoiceNestedInput
    ProductVariant?: ProductVariantUpdateOneRequiredWithoutQPayInvoiceNestedInput
    user?: UserUpdateOneWithoutQPayInvoiceNestedInput
  }

  export type QPayInvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    productVariantId?: StringFieldUpdateOperationsInput | string
    invoiceData?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    payedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QPayInvoiceCreateManyInput = {
    id?: string
    productId: string
    productVariantId: string
    invoiceData?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    payedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QPayInvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceData?: NullableJsonNullValueInput | InputJsonValue
    payedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QPayInvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    productVariantId?: StringFieldUpdateOperationsInput | string
    invoiceData?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    payedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    phoneNumber: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    hospital: HospitalCreateNestedOneWithoutMessageInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    phoneNumber: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    hospitalId: string
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hospital?: HospitalUpdateOneRequiredWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hospitalId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageCreateManyInput = {
    id?: string
    phoneNumber: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    hospitalId: string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hospitalId?: StringFieldUpdateOperationsInput | string
  }

  export type PromoCodeCreateInput = {
    id?: string
    code: string
    promoImageUrl?: string
    description: string
    expiryDate?: Date | string | null
    isActive?: boolean
    fixedAmount: Decimal | DecimalJsLike | number | string
    percentageAmount: Decimal | DecimalJsLike | number | string
    maxUses?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userPromoCode?: UserPromoCodeCreateNestedManyWithoutPromoCodeInput
  }

  export type PromoCodeUncheckedCreateInput = {
    id?: string
    code: string
    promoImageUrl?: string
    description: string
    expiryDate?: Date | string | null
    isActive?: boolean
    fixedAmount: Decimal | DecimalJsLike | number | string
    percentageAmount: Decimal | DecimalJsLike | number | string
    maxUses?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userPromoCode?: UserPromoCodeUncheckedCreateNestedManyWithoutPromoCodeInput
  }

  export type PromoCodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    promoImageUrl?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fixedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    percentageAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxUses?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userPromoCode?: UserPromoCodeUpdateManyWithoutPromoCodeNestedInput
  }

  export type PromoCodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    promoImageUrl?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fixedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    percentageAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxUses?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userPromoCode?: UserPromoCodeUncheckedUpdateManyWithoutPromoCodeNestedInput
  }

  export type PromoCodeCreateManyInput = {
    id?: string
    code: string
    promoImageUrl?: string
    description: string
    expiryDate?: Date | string | null
    isActive?: boolean
    fixedAmount: Decimal | DecimalJsLike | number | string
    percentageAmount: Decimal | DecimalJsLike | number | string
    maxUses?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromoCodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    promoImageUrl?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fixedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    percentageAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxUses?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoCodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    promoImageUrl?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fixedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    percentageAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxUses?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPromoCodeCreateInput = {
    id?: string
    promoCodeUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserPromoCodeInput
    promoCode: PromoCodeCreateNestedOneWithoutUserPromoCodeInput
  }

  export type UserPromoCodeUncheckedCreateInput = {
    id?: string
    userId: string
    promoCodeId: string
    promoCodeUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPromoCodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    promoCodeUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserPromoCodeNestedInput
    promoCode?: PromoCodeUpdateOneRequiredWithoutUserPromoCodeNestedInput
  }

  export type UserPromoCodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    promoCodeId?: StringFieldUpdateOperationsInput | string
    promoCodeUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPromoCodeCreateManyInput = {
    id?: string
    userId: string
    promoCodeId: string
    promoCodeUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPromoCodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    promoCodeUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPromoCodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    promoCodeId?: StringFieldUpdateOperationsInput | string
    promoCodeUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FreeTrialCreateInput = {
    id?: string
    hospitalName: string
    phoneNumber: string
    hospitalChair: string
    registrationNumber: string
    directorInfo: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FreeTrialUncheckedCreateInput = {
    id?: string
    hospitalName: string
    phoneNumber: string
    hospitalChair: string
    registrationNumber: string
    directorInfo: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FreeTrialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hospitalName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    hospitalChair?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    directorInfo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FreeTrialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hospitalName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    hospitalChair?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    directorInfo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FreeTrialCreateManyInput = {
    id?: string
    hospitalName: string
    phoneNumber: string
    hospitalChair: string
    registrationNumber: string
    directorInfo: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FreeTrialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    hospitalName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    hospitalChair?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    directorInfo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FreeTrialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    hospitalName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    hospitalChair?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    directorInfo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type EnumUserRoleFilter = {
    equals?: UserRole
    in?: Enumerable<UserRole>
    notIn?: Enumerable<UserRole>
    not?: NestedEnumUserRoleFilter | UserRole
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type ProfileRelationFilter = {
    is?: ProfileWhereInput | null
    isNot?: ProfileWhereInput | null
  }

  export type HospitalListRelationFilter = {
    every?: HospitalWhereInput
    some?: HospitalWhereInput
    none?: HospitalWhereInput
  }

  export type ProductPaymentListRelationFilter = {
    every?: ProductPaymentWhereInput
    some?: ProductPaymentWhereInput
    none?: ProductPaymentWhereInput
  }

  export type QPayInvoiceListRelationFilter = {
    every?: QPayInvoiceWhereInput
    some?: QPayInvoiceWhereInput
    none?: QPayInvoiceWhereInput
  }

  export type UserPromoCodeListRelationFilter = {
    every?: UserPromoCodeWhereInput
    some?: UserPromoCodeWhereInput
    none?: UserPromoCodeWhereInput
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HospitalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductPaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QPayInvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserPromoCodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    passwordDigest?: SortOrder
    phoneNumber?: SortOrder
    phoneNumberVerified?: SortOrder
    role?: SortOrder
    inviteToken?: SortOrder
    isTokenUsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invitedBy?: SortOrder
    pin?: SortOrder
    pinCreatedAt?: SortOrder
    pinType?: SortOrder
    pinVerifiedAt?: SortOrder
    hospitalId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    passwordDigest?: SortOrder
    phoneNumber?: SortOrder
    phoneNumberVerified?: SortOrder
    role?: SortOrder
    inviteToken?: SortOrder
    isTokenUsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invitedBy?: SortOrder
    pin?: SortOrder
    pinCreatedAt?: SortOrder
    pinType?: SortOrder
    pinVerifiedAt?: SortOrder
    hospitalId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    passwordDigest?: SortOrder
    phoneNumber?: SortOrder
    phoneNumberVerified?: SortOrder
    role?: SortOrder
    inviteToken?: SortOrder
    isTokenUsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invitedBy?: SortOrder
    pin?: SortOrder
    pinCreatedAt?: SortOrder
    pinType?: SortOrder
    pinVerifiedAt?: SortOrder
    hospitalId?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type EnumUserRoleWithAggregatesFilter = {
    equals?: UserRole
    in?: Enumerable<UserRole>
    notIn?: Enumerable<UserRole>
    not?: NestedEnumUserRoleWithAggregatesFilter | UserRole
    _count?: NestedIntFilter
    _min?: NestedEnumUserRoleFilter
    _max?: NestedEnumUserRoleFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refreshToken?: SortOrder
    accessToken?: SortOrder
    tokenType?: SortOrder
    expiresAt?: SortOrder
    scope?: SortOrder
    idToken?: SortOrder
    sessionState?: SortOrder
    oauthTokenSecret?: SortOrder
    oauthToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expiresAt?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refreshToken?: SortOrder
    accessToken?: SortOrder
    tokenType?: SortOrder
    expiresAt?: SortOrder
    scope?: SortOrder
    idToken?: SortOrder
    sessionState?: SortOrder
    oauthTokenSecret?: SortOrder
    oauthToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refreshToken?: SortOrder
    accessToken?: SortOrder
    tokenType?: SortOrder
    expiresAt?: SortOrder
    scope?: SortOrder
    idToken?: SortOrder
    sessionState?: SortOrder
    oauthTokenSecret?: SortOrder
    oauthToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expiresAt?: SortOrder
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type ProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    latinName?: SortOrder
    sex?: SortOrder
    dob?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    picture?: SortOrder
    priceMin?: SortOrder
    priceMax?: SortOrder
    notifyEmail?: SortOrder
    notifyPush?: SortOrder
    notifyBadge?: SortOrder
    historyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    specialistDesc?: SortOrder
    patientCode?: SortOrder
    allowPatientAssign?: SortOrder
  }

  export type ProfileAvgOrderByAggregateInput = {
    height?: SortOrder
    weight?: SortOrder
    priceMin?: SortOrder
    priceMax?: SortOrder
  }

  export type ProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    latinName?: SortOrder
    sex?: SortOrder
    dob?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    picture?: SortOrder
    priceMin?: SortOrder
    priceMax?: SortOrder
    notifyEmail?: SortOrder
    notifyPush?: SortOrder
    notifyBadge?: SortOrder
    historyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    specialistDesc?: SortOrder
    patientCode?: SortOrder
    allowPatientAssign?: SortOrder
  }

  export type ProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    latinName?: SortOrder
    sex?: SortOrder
    dob?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    picture?: SortOrder
    priceMin?: SortOrder
    priceMax?: SortOrder
    notifyEmail?: SortOrder
    notifyPush?: SortOrder
    notifyBadge?: SortOrder
    historyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    specialistDesc?: SortOrder
    patientCode?: SortOrder
    allowPatientAssign?: SortOrder
  }

  export type ProfileSumOrderByAggregateInput = {
    height?: SortOrder
    weight?: SortOrder
    priceMin?: SortOrder
    priceMax?: SortOrder
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sid?: SortOrder
    data?: SortOrder
    expiresAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sid?: SortOrder
    data?: SortOrder
    expiresAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sid?: SortOrder
    data?: SortOrder
    expiresAt?: SortOrder
  }

  export type SmsRequestAttemptCountOrderByAggregateInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type SmsRequestAttemptMaxOrderByAggregateInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type SmsRequestAttemptMinOrderByAggregateInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type FileUploadCountOrderByAggregateInput = {
    id?: SortOrder
    fileGroup?: SortOrder
    fileLink?: SortOrder
    fileSource?: SortOrder
    removedAt?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fileCategory?: SortOrder
    fileSourceDate?: SortOrder
    fileMIMEType?: SortOrder
  }

  export type FileUploadMaxOrderByAggregateInput = {
    id?: SortOrder
    fileGroup?: SortOrder
    fileLink?: SortOrder
    fileSource?: SortOrder
    removedAt?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fileCategory?: SortOrder
    fileSourceDate?: SortOrder
    fileMIMEType?: SortOrder
  }

  export type FileUploadMinOrderByAggregateInput = {
    id?: SortOrder
    fileGroup?: SortOrder
    fileLink?: SortOrder
    fileSource?: SortOrder
    removedAt?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fileCategory?: SortOrder
    fileSourceDate?: SortOrder
    fileMIMEType?: SortOrder
  }

  export type FirebaseTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FirebaseTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FirebaseTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WaitListPhoneNumberCountOrderByAggregateInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WaitListPhoneNumberMaxOrderByAggregateInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WaitListPhoneNumberMinOrderByAggregateInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HospitalUsersListRelationFilter = {
    every?: HospitalUsersWhereInput
    some?: HospitalUsersWhereInput
    none?: HospitalUsersWhereInput
  }

  export type SubscriptionListRelationFilter = {
    every?: SubscriptionWhereInput
    some?: SubscriptionWhereInput
    none?: SubscriptionWhereInput
  }

  export type DatabaseConnectionListRelationFilter = {
    every?: DatabaseConnectionWhereInput
    some?: DatabaseConnectionWhereInput
    none?: DatabaseConnectionWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type HospitalUsersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DatabaseConnectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HospitalCountOrderByAggregateInput = {
    id?: SortOrder
    hospitalLogo?: SortOrder
    subDomain?: SortOrder
    phoneNumber?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HospitalMaxOrderByAggregateInput = {
    id?: SortOrder
    hospitalLogo?: SortOrder
    subDomain?: SortOrder
    phoneNumber?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HospitalMinOrderByAggregateInput = {
    id?: SortOrder
    hospitalLogo?: SortOrder
    subDomain?: SortOrder
    phoneNumber?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type MachineListRelationFilter = {
    every?: MachineWhereInput
    some?: MachineWhereInput
    none?: MachineWhereInput
  }

  export type HospitalRelationFilter = {
    is?: HospitalWhereInput
    isNot?: HospitalWhereInput
  }

  export type MachineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    totalDays?: SortOrder
    isStart?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hospitalId?: SortOrder
  }

  export type SubscriptionAvgOrderByAggregateInput = {
    id?: SortOrder
    totalDays?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    totalDays?: SortOrder
    isStart?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hospitalId?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    totalDays?: SortOrder
    isStart?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hospitalId?: SortOrder
  }

  export type SubscriptionSumOrderByAggregateInput = {
    id?: SortOrder
    totalDays?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type SubscriptionRelationFilter = {
    is?: SubscriptionWhereInput
    isNot?: SubscriptionWhereInput
  }

  export type MachineCountOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    machineName?: SortOrder
    machineUniqueId?: SortOrder
    registeredAt?: SortOrder
  }

  export type MachineAvgOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
  }

  export type MachineMaxOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    machineName?: SortOrder
    machineUniqueId?: SortOrder
    registeredAt?: SortOrder
  }

  export type MachineMinOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    machineName?: SortOrder
    machineUniqueId?: SortOrder
    registeredAt?: SortOrder
  }

  export type MachineSumOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
  }

  export type HospitalUsersCountOrderByAggregateInput = {
    id?: SortOrder
    hospitalId?: SortOrder
    phoneNumber?: SortOrder
    userName?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HospitalUsersAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type HospitalUsersMaxOrderByAggregateInput = {
    id?: SortOrder
    hospitalId?: SortOrder
    phoneNumber?: SortOrder
    userName?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HospitalUsersMinOrderByAggregateInput = {
    id?: SortOrder
    hospitalId?: SortOrder
    phoneNumber?: SortOrder
    userName?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HospitalUsersSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DatabaseConnectionCountOrderByAggregateInput = {
    id?: SortOrder
    connectionName?: SortOrder
    connectionType?: SortOrder
    host?: SortOrder
    port?: SortOrder
    databaseName?: SortOrder
    username?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hospitalId?: SortOrder
  }

  export type DatabaseConnectionAvgOrderByAggregateInput = {
    port?: SortOrder
  }

  export type DatabaseConnectionMaxOrderByAggregateInput = {
    id?: SortOrder
    connectionName?: SortOrder
    connectionType?: SortOrder
    host?: SortOrder
    port?: SortOrder
    databaseName?: SortOrder
    username?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hospitalId?: SortOrder
  }

  export type DatabaseConnectionMinOrderByAggregateInput = {
    id?: SortOrder
    connectionName?: SortOrder
    connectionType?: SortOrder
    host?: SortOrder
    port?: SortOrder
    databaseName?: SortOrder
    username?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hospitalId?: SortOrder
  }

  export type DatabaseConnectionSumOrderByAggregateInput = {
    port?: SortOrder
  }
  export type JsonNullableFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase>, Exclude<keyof Required<JsonNullableFilterBase>, 'path'>>,
        Required<JsonNullableFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase>, 'path'>>

  export type JsonNullableFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type ProductVariantListRelationFilter = {
    every?: ProductVariantWhereInput
    some?: ProductVariantWhereInput
    none?: ProductVariantWhereInput
  }

  export type ProductVariantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    productDescription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
    _count?: NestedIntNullableFilter
    _min?: NestedJsonNullableFilter
    _max?: NestedJsonNullableFilter
  }

  export type IntNullableListFilter = {
    equals?: Enumerable<number> | null
    has?: number | null
    hasEvery?: Enumerable<number>
    hasSome?: Enumerable<number>
    isEmpty?: boolean
  }

  export type ProductRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type ProductVariantCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    unit?: SortOrder
    duration?: SortOrder
    discount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sits?: SortOrder
  }

  export type ProductVariantAvgOrderByAggregateInput = {
    price?: SortOrder
    unit?: SortOrder
    duration?: SortOrder
    discount?: SortOrder
    sits?: SortOrder
  }

  export type ProductVariantMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    unit?: SortOrder
    duration?: SortOrder
    discount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductVariantMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    unit?: SortOrder
    duration?: SortOrder
    discount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductVariantSumOrderByAggregateInput = {
    price?: SortOrder
    unit?: SortOrder
    duration?: SortOrder
    discount?: SortOrder
    sits?: SortOrder
  }

  export type DecimalNullableFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type ProductVariantRelationFilter = {
    is?: ProductVariantWhereInput
    isNot?: ProductVariantWhereInput
  }

  export type ProductPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    paidSource?: SortOrder
    paidAmount?: SortOrder
    paidDate?: SortOrder
    additionalNote?: SortOrder
    productId?: SortOrder
    productVariantId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paymentStatus?: SortOrder
  }

  export type ProductPaymentAvgOrderByAggregateInput = {
    paidAmount?: SortOrder
  }

  export type ProductPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    paidSource?: SortOrder
    paidAmount?: SortOrder
    paidDate?: SortOrder
    additionalNote?: SortOrder
    productId?: SortOrder
    productVariantId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paymentStatus?: SortOrder
  }

  export type ProductPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    paidSource?: SortOrder
    paidAmount?: SortOrder
    paidDate?: SortOrder
    additionalNote?: SortOrder
    productId?: SortOrder
    productVariantId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paymentStatus?: SortOrder
  }

  export type ProductPaymentSumOrderByAggregateInput = {
    paidAmount?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter
    _avg?: NestedDecimalNullableFilter
    _sum?: NestedDecimalNullableFilter
    _min?: NestedDecimalNullableFilter
    _max?: NestedDecimalNullableFilter
  }

  export type QPayInvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    productVariantId?: SortOrder
    invoiceData?: SortOrder
    userId?: SortOrder
    payedDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QPayInvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    productVariantId?: SortOrder
    userId?: SortOrder
    payedDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QPayInvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    productVariantId?: SortOrder
    userId?: SortOrder
    payedDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hospitalId?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hospitalId?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hospitalId?: SortOrder
  }

  export type DecimalFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type PromoCodeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    promoImageUrl?: SortOrder
    description?: SortOrder
    expiryDate?: SortOrder
    isActive?: SortOrder
    fixedAmount?: SortOrder
    percentageAmount?: SortOrder
    maxUses?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromoCodeAvgOrderByAggregateInput = {
    fixedAmount?: SortOrder
    percentageAmount?: SortOrder
    maxUses?: SortOrder
  }

  export type PromoCodeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    promoImageUrl?: SortOrder
    description?: SortOrder
    expiryDate?: SortOrder
    isActive?: SortOrder
    fixedAmount?: SortOrder
    percentageAmount?: SortOrder
    maxUses?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromoCodeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    promoImageUrl?: SortOrder
    description?: SortOrder
    expiryDate?: SortOrder
    isActive?: SortOrder
    fixedAmount?: SortOrder
    percentageAmount?: SortOrder
    maxUses?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromoCodeSumOrderByAggregateInput = {
    fixedAmount?: SortOrder
    percentageAmount?: SortOrder
    maxUses?: SortOrder
  }

  export type DecimalWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter
    _avg?: NestedDecimalFilter
    _sum?: NestedDecimalFilter
    _min?: NestedDecimalFilter
    _max?: NestedDecimalFilter
  }

  export type PromoCodeRelationFilter = {
    is?: PromoCodeWhereInput
    isNot?: PromoCodeWhereInput
  }

  export type UserPromoCodeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    promoCodeId?: SortOrder
    promoCodeUsedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPromoCodeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    promoCodeId?: SortOrder
    promoCodeUsedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPromoCodeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    promoCodeId?: SortOrder
    promoCodeUsedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FreeTrialCountOrderByAggregateInput = {
    id?: SortOrder
    hospitalName?: SortOrder
    phoneNumber?: SortOrder
    hospitalChair?: SortOrder
    registrationNumber?: SortOrder
    directorInfo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FreeTrialMaxOrderByAggregateInput = {
    id?: SortOrder
    hospitalName?: SortOrder
    phoneNumber?: SortOrder
    hospitalChair?: SortOrder
    registrationNumber?: SortOrder
    directorInfo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FreeTrialMinOrderByAggregateInput = {
    id?: SortOrder
    hospitalName?: SortOrder
    phoneNumber?: SortOrder
    hospitalChair?: SortOrder
    registrationNumber?: SortOrder
    directorInfo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AccountCreateWithoutUserInput>, Enumerable<AccountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutUserInput>
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: Enumerable<AccountWhereUniqueInput>
  }

  export type ProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type HospitalCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<HospitalCreateWithoutUserInput>, Enumerable<HospitalUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<HospitalCreateOrConnectWithoutUserInput>
    createMany?: HospitalCreateManyUserInputEnvelope
    connect?: Enumerable<HospitalWhereUniqueInput>
  }

  export type ProductPaymentCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ProductPaymentCreateWithoutUserInput>, Enumerable<ProductPaymentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ProductPaymentCreateOrConnectWithoutUserInput>
    createMany?: ProductPaymentCreateManyUserInputEnvelope
    connect?: Enumerable<ProductPaymentWhereUniqueInput>
  }

  export type QPayInvoiceCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<QPayInvoiceCreateWithoutUserInput>, Enumerable<QPayInvoiceUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<QPayInvoiceCreateOrConnectWithoutUserInput>
    createMany?: QPayInvoiceCreateManyUserInputEnvelope
    connect?: Enumerable<QPayInvoiceWhereUniqueInput>
  }

  export type UserPromoCodeCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserPromoCodeCreateWithoutUserInput>, Enumerable<UserPromoCodeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserPromoCodeCreateOrConnectWithoutUserInput>
    createMany?: UserPromoCodeCreateManyUserInputEnvelope
    connect?: Enumerable<UserPromoCodeWhereUniqueInput>
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AccountCreateWithoutUserInput>, Enumerable<AccountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutUserInput>
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: Enumerable<AccountWhereUniqueInput>
  }

  export type ProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type HospitalUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<HospitalCreateWithoutUserInput>, Enumerable<HospitalUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<HospitalCreateOrConnectWithoutUserInput>
    createMany?: HospitalCreateManyUserInputEnvelope
    connect?: Enumerable<HospitalWhereUniqueInput>
  }

  export type ProductPaymentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ProductPaymentCreateWithoutUserInput>, Enumerable<ProductPaymentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ProductPaymentCreateOrConnectWithoutUserInput>
    createMany?: ProductPaymentCreateManyUserInputEnvelope
    connect?: Enumerable<ProductPaymentWhereUniqueInput>
  }

  export type QPayInvoiceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<QPayInvoiceCreateWithoutUserInput>, Enumerable<QPayInvoiceUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<QPayInvoiceCreateOrConnectWithoutUserInput>
    createMany?: QPayInvoiceCreateManyUserInputEnvelope
    connect?: Enumerable<QPayInvoiceWhereUniqueInput>
  }

  export type UserPromoCodeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserPromoCodeCreateWithoutUserInput>, Enumerable<UserPromoCodeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserPromoCodeCreateOrConnectWithoutUserInput>
    createMany?: UserPromoCodeCreateManyUserInputEnvelope
    connect?: Enumerable<UserPromoCodeWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: UserRole
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AccountCreateWithoutUserInput>, Enumerable<AccountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AccountUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AccountCreateManyUserInputEnvelope
    set?: Enumerable<AccountWhereUniqueInput>
    disconnect?: Enumerable<AccountWhereUniqueInput>
    delete?: Enumerable<AccountWhereUniqueInput>
    connect?: Enumerable<AccountWhereUniqueInput>
    update?: Enumerable<AccountUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AccountUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AccountScalarWhereInput>
  }

  export type ProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type HospitalUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<HospitalCreateWithoutUserInput>, Enumerable<HospitalUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<HospitalCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<HospitalUpsertWithWhereUniqueWithoutUserInput>
    createMany?: HospitalCreateManyUserInputEnvelope
    set?: Enumerable<HospitalWhereUniqueInput>
    disconnect?: Enumerable<HospitalWhereUniqueInput>
    delete?: Enumerable<HospitalWhereUniqueInput>
    connect?: Enumerable<HospitalWhereUniqueInput>
    update?: Enumerable<HospitalUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<HospitalUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<HospitalScalarWhereInput>
  }

  export type ProductPaymentUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ProductPaymentCreateWithoutUserInput>, Enumerable<ProductPaymentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ProductPaymentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ProductPaymentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ProductPaymentCreateManyUserInputEnvelope
    set?: Enumerable<ProductPaymentWhereUniqueInput>
    disconnect?: Enumerable<ProductPaymentWhereUniqueInput>
    delete?: Enumerable<ProductPaymentWhereUniqueInput>
    connect?: Enumerable<ProductPaymentWhereUniqueInput>
    update?: Enumerable<ProductPaymentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ProductPaymentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ProductPaymentScalarWhereInput>
  }

  export type QPayInvoiceUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<QPayInvoiceCreateWithoutUserInput>, Enumerable<QPayInvoiceUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<QPayInvoiceCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<QPayInvoiceUpsertWithWhereUniqueWithoutUserInput>
    createMany?: QPayInvoiceCreateManyUserInputEnvelope
    set?: Enumerable<QPayInvoiceWhereUniqueInput>
    disconnect?: Enumerable<QPayInvoiceWhereUniqueInput>
    delete?: Enumerable<QPayInvoiceWhereUniqueInput>
    connect?: Enumerable<QPayInvoiceWhereUniqueInput>
    update?: Enumerable<QPayInvoiceUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<QPayInvoiceUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<QPayInvoiceScalarWhereInput>
  }

  export type UserPromoCodeUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserPromoCodeCreateWithoutUserInput>, Enumerable<UserPromoCodeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserPromoCodeCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserPromoCodeUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserPromoCodeCreateManyUserInputEnvelope
    set?: Enumerable<UserPromoCodeWhereUniqueInput>
    disconnect?: Enumerable<UserPromoCodeWhereUniqueInput>
    delete?: Enumerable<UserPromoCodeWhereUniqueInput>
    connect?: Enumerable<UserPromoCodeWhereUniqueInput>
    update?: Enumerable<UserPromoCodeUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserPromoCodeUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserPromoCodeScalarWhereInput>
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AccountCreateWithoutUserInput>, Enumerable<AccountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AccountUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AccountCreateManyUserInputEnvelope
    set?: Enumerable<AccountWhereUniqueInput>
    disconnect?: Enumerable<AccountWhereUniqueInput>
    delete?: Enumerable<AccountWhereUniqueInput>
    connect?: Enumerable<AccountWhereUniqueInput>
    update?: Enumerable<AccountUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AccountUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AccountScalarWhereInput>
  }

  export type ProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type HospitalUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<HospitalCreateWithoutUserInput>, Enumerable<HospitalUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<HospitalCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<HospitalUpsertWithWhereUniqueWithoutUserInput>
    createMany?: HospitalCreateManyUserInputEnvelope
    set?: Enumerable<HospitalWhereUniqueInput>
    disconnect?: Enumerable<HospitalWhereUniqueInput>
    delete?: Enumerable<HospitalWhereUniqueInput>
    connect?: Enumerable<HospitalWhereUniqueInput>
    update?: Enumerable<HospitalUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<HospitalUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<HospitalScalarWhereInput>
  }

  export type ProductPaymentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ProductPaymentCreateWithoutUserInput>, Enumerable<ProductPaymentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ProductPaymentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ProductPaymentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ProductPaymentCreateManyUserInputEnvelope
    set?: Enumerable<ProductPaymentWhereUniqueInput>
    disconnect?: Enumerable<ProductPaymentWhereUniqueInput>
    delete?: Enumerable<ProductPaymentWhereUniqueInput>
    connect?: Enumerable<ProductPaymentWhereUniqueInput>
    update?: Enumerable<ProductPaymentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ProductPaymentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ProductPaymentScalarWhereInput>
  }

  export type QPayInvoiceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<QPayInvoiceCreateWithoutUserInput>, Enumerable<QPayInvoiceUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<QPayInvoiceCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<QPayInvoiceUpsertWithWhereUniqueWithoutUserInput>
    createMany?: QPayInvoiceCreateManyUserInputEnvelope
    set?: Enumerable<QPayInvoiceWhereUniqueInput>
    disconnect?: Enumerable<QPayInvoiceWhereUniqueInput>
    delete?: Enumerable<QPayInvoiceWhereUniqueInput>
    connect?: Enumerable<QPayInvoiceWhereUniqueInput>
    update?: Enumerable<QPayInvoiceUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<QPayInvoiceUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<QPayInvoiceScalarWhereInput>
  }

  export type UserPromoCodeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserPromoCodeCreateWithoutUserInput>, Enumerable<UserPromoCodeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserPromoCodeCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserPromoCodeUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserPromoCodeCreateManyUserInputEnvelope
    set?: Enumerable<UserPromoCodeWhereUniqueInput>
    disconnect?: Enumerable<UserPromoCodeWhereUniqueInput>
    delete?: Enumerable<UserPromoCodeWhereUniqueInput>
    connect?: Enumerable<UserPromoCodeWhereUniqueInput>
    update?: Enumerable<UserPromoCodeUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserPromoCodeUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserPromoCodeScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    connect?: UserWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    upsert?: UserUpsertWithoutProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserCreateNestedOneWithoutHospitalInput = {
    create?: XOR<UserCreateWithoutHospitalInput, UserUncheckedCreateWithoutHospitalInput>
    connectOrCreate?: UserCreateOrConnectWithoutHospitalInput
    connect?: UserWhereUniqueInput
  }

  export type HospitalUsersCreateNestedManyWithoutHospitalInput = {
    create?: XOR<Enumerable<HospitalUsersCreateWithoutHospitalInput>, Enumerable<HospitalUsersUncheckedCreateWithoutHospitalInput>>
    connectOrCreate?: Enumerable<HospitalUsersCreateOrConnectWithoutHospitalInput>
    createMany?: HospitalUsersCreateManyHospitalInputEnvelope
    connect?: Enumerable<HospitalUsersWhereUniqueInput>
  }

  export type SubscriptionCreateNestedManyWithoutHospitalInput = {
    create?: XOR<Enumerable<SubscriptionCreateWithoutHospitalInput>, Enumerable<SubscriptionUncheckedCreateWithoutHospitalInput>>
    connectOrCreate?: Enumerable<SubscriptionCreateOrConnectWithoutHospitalInput>
    createMany?: SubscriptionCreateManyHospitalInputEnvelope
    connect?: Enumerable<SubscriptionWhereUniqueInput>
  }

  export type DatabaseConnectionCreateNestedManyWithoutHospitalInput = {
    create?: XOR<Enumerable<DatabaseConnectionCreateWithoutHospitalInput>, Enumerable<DatabaseConnectionUncheckedCreateWithoutHospitalInput>>
    connectOrCreate?: Enumerable<DatabaseConnectionCreateOrConnectWithoutHospitalInput>
    createMany?: DatabaseConnectionCreateManyHospitalInputEnvelope
    connect?: Enumerable<DatabaseConnectionWhereUniqueInput>
  }

  export type MessageCreateNestedManyWithoutHospitalInput = {
    create?: XOR<Enumerable<MessageCreateWithoutHospitalInput>, Enumerable<MessageUncheckedCreateWithoutHospitalInput>>
    connectOrCreate?: Enumerable<MessageCreateOrConnectWithoutHospitalInput>
    createMany?: MessageCreateManyHospitalInputEnvelope
    connect?: Enumerable<MessageWhereUniqueInput>
  }

  export type HospitalUsersUncheckedCreateNestedManyWithoutHospitalInput = {
    create?: XOR<Enumerable<HospitalUsersCreateWithoutHospitalInput>, Enumerable<HospitalUsersUncheckedCreateWithoutHospitalInput>>
    connectOrCreate?: Enumerable<HospitalUsersCreateOrConnectWithoutHospitalInput>
    createMany?: HospitalUsersCreateManyHospitalInputEnvelope
    connect?: Enumerable<HospitalUsersWhereUniqueInput>
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutHospitalInput = {
    create?: XOR<Enumerable<SubscriptionCreateWithoutHospitalInput>, Enumerable<SubscriptionUncheckedCreateWithoutHospitalInput>>
    connectOrCreate?: Enumerable<SubscriptionCreateOrConnectWithoutHospitalInput>
    createMany?: SubscriptionCreateManyHospitalInputEnvelope
    connect?: Enumerable<SubscriptionWhereUniqueInput>
  }

  export type DatabaseConnectionUncheckedCreateNestedManyWithoutHospitalInput = {
    create?: XOR<Enumerable<DatabaseConnectionCreateWithoutHospitalInput>, Enumerable<DatabaseConnectionUncheckedCreateWithoutHospitalInput>>
    connectOrCreate?: Enumerable<DatabaseConnectionCreateOrConnectWithoutHospitalInput>
    createMany?: DatabaseConnectionCreateManyHospitalInputEnvelope
    connect?: Enumerable<DatabaseConnectionWhereUniqueInput>
  }

  export type MessageUncheckedCreateNestedManyWithoutHospitalInput = {
    create?: XOR<Enumerable<MessageCreateWithoutHospitalInput>, Enumerable<MessageUncheckedCreateWithoutHospitalInput>>
    connectOrCreate?: Enumerable<MessageCreateOrConnectWithoutHospitalInput>
    createMany?: MessageCreateManyHospitalInputEnvelope
    connect?: Enumerable<MessageWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutHospitalNestedInput = {
    create?: XOR<UserCreateWithoutHospitalInput, UserUncheckedCreateWithoutHospitalInput>
    connectOrCreate?: UserCreateOrConnectWithoutHospitalInput
    upsert?: UserUpsertWithoutHospitalInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutHospitalInput, UserUncheckedUpdateWithoutHospitalInput>
  }

  export type HospitalUsersUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<Enumerable<HospitalUsersCreateWithoutHospitalInput>, Enumerable<HospitalUsersUncheckedCreateWithoutHospitalInput>>
    connectOrCreate?: Enumerable<HospitalUsersCreateOrConnectWithoutHospitalInput>
    upsert?: Enumerable<HospitalUsersUpsertWithWhereUniqueWithoutHospitalInput>
    createMany?: HospitalUsersCreateManyHospitalInputEnvelope
    set?: Enumerable<HospitalUsersWhereUniqueInput>
    disconnect?: Enumerable<HospitalUsersWhereUniqueInput>
    delete?: Enumerable<HospitalUsersWhereUniqueInput>
    connect?: Enumerable<HospitalUsersWhereUniqueInput>
    update?: Enumerable<HospitalUsersUpdateWithWhereUniqueWithoutHospitalInput>
    updateMany?: Enumerable<HospitalUsersUpdateManyWithWhereWithoutHospitalInput>
    deleteMany?: Enumerable<HospitalUsersScalarWhereInput>
  }

  export type SubscriptionUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<Enumerable<SubscriptionCreateWithoutHospitalInput>, Enumerable<SubscriptionUncheckedCreateWithoutHospitalInput>>
    connectOrCreate?: Enumerable<SubscriptionCreateOrConnectWithoutHospitalInput>
    upsert?: Enumerable<SubscriptionUpsertWithWhereUniqueWithoutHospitalInput>
    createMany?: SubscriptionCreateManyHospitalInputEnvelope
    set?: Enumerable<SubscriptionWhereUniqueInput>
    disconnect?: Enumerable<SubscriptionWhereUniqueInput>
    delete?: Enumerable<SubscriptionWhereUniqueInput>
    connect?: Enumerable<SubscriptionWhereUniqueInput>
    update?: Enumerable<SubscriptionUpdateWithWhereUniqueWithoutHospitalInput>
    updateMany?: Enumerable<SubscriptionUpdateManyWithWhereWithoutHospitalInput>
    deleteMany?: Enumerable<SubscriptionScalarWhereInput>
  }

  export type DatabaseConnectionUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<Enumerable<DatabaseConnectionCreateWithoutHospitalInput>, Enumerable<DatabaseConnectionUncheckedCreateWithoutHospitalInput>>
    connectOrCreate?: Enumerable<DatabaseConnectionCreateOrConnectWithoutHospitalInput>
    upsert?: Enumerable<DatabaseConnectionUpsertWithWhereUniqueWithoutHospitalInput>
    createMany?: DatabaseConnectionCreateManyHospitalInputEnvelope
    set?: Enumerable<DatabaseConnectionWhereUniqueInput>
    disconnect?: Enumerable<DatabaseConnectionWhereUniqueInput>
    delete?: Enumerable<DatabaseConnectionWhereUniqueInput>
    connect?: Enumerable<DatabaseConnectionWhereUniqueInput>
    update?: Enumerable<DatabaseConnectionUpdateWithWhereUniqueWithoutHospitalInput>
    updateMany?: Enumerable<DatabaseConnectionUpdateManyWithWhereWithoutHospitalInput>
    deleteMany?: Enumerable<DatabaseConnectionScalarWhereInput>
  }

  export type MessageUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<Enumerable<MessageCreateWithoutHospitalInput>, Enumerable<MessageUncheckedCreateWithoutHospitalInput>>
    connectOrCreate?: Enumerable<MessageCreateOrConnectWithoutHospitalInput>
    upsert?: Enumerable<MessageUpsertWithWhereUniqueWithoutHospitalInput>
    createMany?: MessageCreateManyHospitalInputEnvelope
    set?: Enumerable<MessageWhereUniqueInput>
    disconnect?: Enumerable<MessageWhereUniqueInput>
    delete?: Enumerable<MessageWhereUniqueInput>
    connect?: Enumerable<MessageWhereUniqueInput>
    update?: Enumerable<MessageUpdateWithWhereUniqueWithoutHospitalInput>
    updateMany?: Enumerable<MessageUpdateManyWithWhereWithoutHospitalInput>
    deleteMany?: Enumerable<MessageScalarWhereInput>
  }

  export type HospitalUsersUncheckedUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<Enumerable<HospitalUsersCreateWithoutHospitalInput>, Enumerable<HospitalUsersUncheckedCreateWithoutHospitalInput>>
    connectOrCreate?: Enumerable<HospitalUsersCreateOrConnectWithoutHospitalInput>
    upsert?: Enumerable<HospitalUsersUpsertWithWhereUniqueWithoutHospitalInput>
    createMany?: HospitalUsersCreateManyHospitalInputEnvelope
    set?: Enumerable<HospitalUsersWhereUniqueInput>
    disconnect?: Enumerable<HospitalUsersWhereUniqueInput>
    delete?: Enumerable<HospitalUsersWhereUniqueInput>
    connect?: Enumerable<HospitalUsersWhereUniqueInput>
    update?: Enumerable<HospitalUsersUpdateWithWhereUniqueWithoutHospitalInput>
    updateMany?: Enumerable<HospitalUsersUpdateManyWithWhereWithoutHospitalInput>
    deleteMany?: Enumerable<HospitalUsersScalarWhereInput>
  }

  export type SubscriptionUncheckedUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<Enumerable<SubscriptionCreateWithoutHospitalInput>, Enumerable<SubscriptionUncheckedCreateWithoutHospitalInput>>
    connectOrCreate?: Enumerable<SubscriptionCreateOrConnectWithoutHospitalInput>
    upsert?: Enumerable<SubscriptionUpsertWithWhereUniqueWithoutHospitalInput>
    createMany?: SubscriptionCreateManyHospitalInputEnvelope
    set?: Enumerable<SubscriptionWhereUniqueInput>
    disconnect?: Enumerable<SubscriptionWhereUniqueInput>
    delete?: Enumerable<SubscriptionWhereUniqueInput>
    connect?: Enumerable<SubscriptionWhereUniqueInput>
    update?: Enumerable<SubscriptionUpdateWithWhereUniqueWithoutHospitalInput>
    updateMany?: Enumerable<SubscriptionUpdateManyWithWhereWithoutHospitalInput>
    deleteMany?: Enumerable<SubscriptionScalarWhereInput>
  }

  export type DatabaseConnectionUncheckedUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<Enumerable<DatabaseConnectionCreateWithoutHospitalInput>, Enumerable<DatabaseConnectionUncheckedCreateWithoutHospitalInput>>
    connectOrCreate?: Enumerable<DatabaseConnectionCreateOrConnectWithoutHospitalInput>
    upsert?: Enumerable<DatabaseConnectionUpsertWithWhereUniqueWithoutHospitalInput>
    createMany?: DatabaseConnectionCreateManyHospitalInputEnvelope
    set?: Enumerable<DatabaseConnectionWhereUniqueInput>
    disconnect?: Enumerable<DatabaseConnectionWhereUniqueInput>
    delete?: Enumerable<DatabaseConnectionWhereUniqueInput>
    connect?: Enumerable<DatabaseConnectionWhereUniqueInput>
    update?: Enumerable<DatabaseConnectionUpdateWithWhereUniqueWithoutHospitalInput>
    updateMany?: Enumerable<DatabaseConnectionUpdateManyWithWhereWithoutHospitalInput>
    deleteMany?: Enumerable<DatabaseConnectionScalarWhereInput>
  }

  export type MessageUncheckedUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<Enumerable<MessageCreateWithoutHospitalInput>, Enumerable<MessageUncheckedCreateWithoutHospitalInput>>
    connectOrCreate?: Enumerable<MessageCreateOrConnectWithoutHospitalInput>
    upsert?: Enumerable<MessageUpsertWithWhereUniqueWithoutHospitalInput>
    createMany?: MessageCreateManyHospitalInputEnvelope
    set?: Enumerable<MessageWhereUniqueInput>
    disconnect?: Enumerable<MessageWhereUniqueInput>
    delete?: Enumerable<MessageWhereUniqueInput>
    connect?: Enumerable<MessageWhereUniqueInput>
    update?: Enumerable<MessageUpdateWithWhereUniqueWithoutHospitalInput>
    updateMany?: Enumerable<MessageUpdateManyWithWhereWithoutHospitalInput>
    deleteMany?: Enumerable<MessageScalarWhereInput>
  }

  export type MachineCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<Enumerable<MachineCreateWithoutSubscriptionInput>, Enumerable<MachineUncheckedCreateWithoutSubscriptionInput>>
    connectOrCreate?: Enumerable<MachineCreateOrConnectWithoutSubscriptionInput>
    createMany?: MachineCreateManySubscriptionInputEnvelope
    connect?: Enumerable<MachineWhereUniqueInput>
  }

  export type HospitalCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<HospitalCreateWithoutSubscriptionInput, HospitalUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: HospitalCreateOrConnectWithoutSubscriptionInput
    connect?: HospitalWhereUniqueInput
  }

  export type MachineUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<Enumerable<MachineCreateWithoutSubscriptionInput>, Enumerable<MachineUncheckedCreateWithoutSubscriptionInput>>
    connectOrCreate?: Enumerable<MachineCreateOrConnectWithoutSubscriptionInput>
    createMany?: MachineCreateManySubscriptionInputEnvelope
    connect?: Enumerable<MachineWhereUniqueInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MachineUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<Enumerable<MachineCreateWithoutSubscriptionInput>, Enumerable<MachineUncheckedCreateWithoutSubscriptionInput>>
    connectOrCreate?: Enumerable<MachineCreateOrConnectWithoutSubscriptionInput>
    upsert?: Enumerable<MachineUpsertWithWhereUniqueWithoutSubscriptionInput>
    createMany?: MachineCreateManySubscriptionInputEnvelope
    set?: Enumerable<MachineWhereUniqueInput>
    disconnect?: Enumerable<MachineWhereUniqueInput>
    delete?: Enumerable<MachineWhereUniqueInput>
    connect?: Enumerable<MachineWhereUniqueInput>
    update?: Enumerable<MachineUpdateWithWhereUniqueWithoutSubscriptionInput>
    updateMany?: Enumerable<MachineUpdateManyWithWhereWithoutSubscriptionInput>
    deleteMany?: Enumerable<MachineScalarWhereInput>
  }

  export type HospitalUpdateOneWithoutSubscriptionNestedInput = {
    create?: XOR<HospitalCreateWithoutSubscriptionInput, HospitalUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: HospitalCreateOrConnectWithoutSubscriptionInput
    upsert?: HospitalUpsertWithoutSubscriptionInput
    disconnect?: boolean
    delete?: boolean
    connect?: HospitalWhereUniqueInput
    update?: XOR<HospitalUpdateWithoutSubscriptionInput, HospitalUncheckedUpdateWithoutSubscriptionInput>
  }

  export type MachineUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<Enumerable<MachineCreateWithoutSubscriptionInput>, Enumerable<MachineUncheckedCreateWithoutSubscriptionInput>>
    connectOrCreate?: Enumerable<MachineCreateOrConnectWithoutSubscriptionInput>
    upsert?: Enumerable<MachineUpsertWithWhereUniqueWithoutSubscriptionInput>
    createMany?: MachineCreateManySubscriptionInputEnvelope
    set?: Enumerable<MachineWhereUniqueInput>
    disconnect?: Enumerable<MachineWhereUniqueInput>
    delete?: Enumerable<MachineWhereUniqueInput>
    connect?: Enumerable<MachineWhereUniqueInput>
    update?: Enumerable<MachineUpdateWithWhereUniqueWithoutSubscriptionInput>
    updateMany?: Enumerable<MachineUpdateManyWithWhereWithoutSubscriptionInput>
    deleteMany?: Enumerable<MachineScalarWhereInput>
  }

  export type SubscriptionCreateNestedOneWithoutMachinesInput = {
    create?: XOR<SubscriptionCreateWithoutMachinesInput, SubscriptionUncheckedCreateWithoutMachinesInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutMachinesInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type SubscriptionUpdateOneRequiredWithoutMachinesNestedInput = {
    create?: XOR<SubscriptionCreateWithoutMachinesInput, SubscriptionUncheckedCreateWithoutMachinesInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutMachinesInput
    upsert?: SubscriptionUpsertWithoutMachinesInput
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<SubscriptionUpdateWithoutMachinesInput, SubscriptionUncheckedUpdateWithoutMachinesInput>
  }

  export type HospitalCreateNestedOneWithoutHospitalUsersInput = {
    create?: XOR<HospitalCreateWithoutHospitalUsersInput, HospitalUncheckedCreateWithoutHospitalUsersInput>
    connectOrCreate?: HospitalCreateOrConnectWithoutHospitalUsersInput
    connect?: HospitalWhereUniqueInput
  }

  export type HospitalUpdateOneRequiredWithoutHospitalUsersNestedInput = {
    create?: XOR<HospitalCreateWithoutHospitalUsersInput, HospitalUncheckedCreateWithoutHospitalUsersInput>
    connectOrCreate?: HospitalCreateOrConnectWithoutHospitalUsersInput
    upsert?: HospitalUpsertWithoutHospitalUsersInput
    connect?: HospitalWhereUniqueInput
    update?: XOR<HospitalUpdateWithoutHospitalUsersInput, HospitalUncheckedUpdateWithoutHospitalUsersInput>
  }

  export type HospitalCreateNestedOneWithoutDatabaseConnectionInput = {
    create?: XOR<HospitalCreateWithoutDatabaseConnectionInput, HospitalUncheckedCreateWithoutDatabaseConnectionInput>
    connectOrCreate?: HospitalCreateOrConnectWithoutDatabaseConnectionInput
    connect?: HospitalWhereUniqueInput
  }

  export type HospitalUpdateOneWithoutDatabaseConnectionNestedInput = {
    create?: XOR<HospitalCreateWithoutDatabaseConnectionInput, HospitalUncheckedCreateWithoutDatabaseConnectionInput>
    connectOrCreate?: HospitalCreateOrConnectWithoutDatabaseConnectionInput
    upsert?: HospitalUpsertWithoutDatabaseConnectionInput
    disconnect?: boolean
    delete?: boolean
    connect?: HospitalWhereUniqueInput
    update?: XOR<HospitalUpdateWithoutDatabaseConnectionInput, HospitalUncheckedUpdateWithoutDatabaseConnectionInput>
  }

  export type ProductVariantCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<ProductVariantCreateWithoutProductInput>, Enumerable<ProductVariantUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ProductVariantCreateOrConnectWithoutProductInput>
    createMany?: ProductVariantCreateManyProductInputEnvelope
    connect?: Enumerable<ProductVariantWhereUniqueInput>
  }

  export type ProductPaymentCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<ProductPaymentCreateWithoutProductInput>, Enumerable<ProductPaymentUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ProductPaymentCreateOrConnectWithoutProductInput>
    createMany?: ProductPaymentCreateManyProductInputEnvelope
    connect?: Enumerable<ProductPaymentWhereUniqueInput>
  }

  export type QPayInvoiceCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<QPayInvoiceCreateWithoutProductInput>, Enumerable<QPayInvoiceUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<QPayInvoiceCreateOrConnectWithoutProductInput>
    createMany?: QPayInvoiceCreateManyProductInputEnvelope
    connect?: Enumerable<QPayInvoiceWhereUniqueInput>
  }

  export type ProductVariantUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<ProductVariantCreateWithoutProductInput>, Enumerable<ProductVariantUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ProductVariantCreateOrConnectWithoutProductInput>
    createMany?: ProductVariantCreateManyProductInputEnvelope
    connect?: Enumerable<ProductVariantWhereUniqueInput>
  }

  export type ProductPaymentUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<ProductPaymentCreateWithoutProductInput>, Enumerable<ProductPaymentUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ProductPaymentCreateOrConnectWithoutProductInput>
    createMany?: ProductPaymentCreateManyProductInputEnvelope
    connect?: Enumerable<ProductPaymentWhereUniqueInput>
  }

  export type QPayInvoiceUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<QPayInvoiceCreateWithoutProductInput>, Enumerable<QPayInvoiceUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<QPayInvoiceCreateOrConnectWithoutProductInput>
    createMany?: QPayInvoiceCreateManyProductInputEnvelope
    connect?: Enumerable<QPayInvoiceWhereUniqueInput>
  }

  export type ProductVariantUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<ProductVariantCreateWithoutProductInput>, Enumerable<ProductVariantUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ProductVariantCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<ProductVariantUpsertWithWhereUniqueWithoutProductInput>
    createMany?: ProductVariantCreateManyProductInputEnvelope
    set?: Enumerable<ProductVariantWhereUniqueInput>
    disconnect?: Enumerable<ProductVariantWhereUniqueInput>
    delete?: Enumerable<ProductVariantWhereUniqueInput>
    connect?: Enumerable<ProductVariantWhereUniqueInput>
    update?: Enumerable<ProductVariantUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<ProductVariantUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<ProductVariantScalarWhereInput>
  }

  export type ProductPaymentUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<ProductPaymentCreateWithoutProductInput>, Enumerable<ProductPaymentUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ProductPaymentCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<ProductPaymentUpsertWithWhereUniqueWithoutProductInput>
    createMany?: ProductPaymentCreateManyProductInputEnvelope
    set?: Enumerable<ProductPaymentWhereUniqueInput>
    disconnect?: Enumerable<ProductPaymentWhereUniqueInput>
    delete?: Enumerable<ProductPaymentWhereUniqueInput>
    connect?: Enumerable<ProductPaymentWhereUniqueInput>
    update?: Enumerable<ProductPaymentUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<ProductPaymentUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<ProductPaymentScalarWhereInput>
  }

  export type QPayInvoiceUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<QPayInvoiceCreateWithoutProductInput>, Enumerable<QPayInvoiceUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<QPayInvoiceCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<QPayInvoiceUpsertWithWhereUniqueWithoutProductInput>
    createMany?: QPayInvoiceCreateManyProductInputEnvelope
    set?: Enumerable<QPayInvoiceWhereUniqueInput>
    disconnect?: Enumerable<QPayInvoiceWhereUniqueInput>
    delete?: Enumerable<QPayInvoiceWhereUniqueInput>
    connect?: Enumerable<QPayInvoiceWhereUniqueInput>
    update?: Enumerable<QPayInvoiceUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<QPayInvoiceUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<QPayInvoiceScalarWhereInput>
  }

  export type ProductVariantUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<ProductVariantCreateWithoutProductInput>, Enumerable<ProductVariantUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ProductVariantCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<ProductVariantUpsertWithWhereUniqueWithoutProductInput>
    createMany?: ProductVariantCreateManyProductInputEnvelope
    set?: Enumerable<ProductVariantWhereUniqueInput>
    disconnect?: Enumerable<ProductVariantWhereUniqueInput>
    delete?: Enumerable<ProductVariantWhereUniqueInput>
    connect?: Enumerable<ProductVariantWhereUniqueInput>
    update?: Enumerable<ProductVariantUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<ProductVariantUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<ProductVariantScalarWhereInput>
  }

  export type ProductPaymentUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<ProductPaymentCreateWithoutProductInput>, Enumerable<ProductPaymentUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ProductPaymentCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<ProductPaymentUpsertWithWhereUniqueWithoutProductInput>
    createMany?: ProductPaymentCreateManyProductInputEnvelope
    set?: Enumerable<ProductPaymentWhereUniqueInput>
    disconnect?: Enumerable<ProductPaymentWhereUniqueInput>
    delete?: Enumerable<ProductPaymentWhereUniqueInput>
    connect?: Enumerable<ProductPaymentWhereUniqueInput>
    update?: Enumerable<ProductPaymentUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<ProductPaymentUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<ProductPaymentScalarWhereInput>
  }

  export type QPayInvoiceUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<QPayInvoiceCreateWithoutProductInput>, Enumerable<QPayInvoiceUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<QPayInvoiceCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<QPayInvoiceUpsertWithWhereUniqueWithoutProductInput>
    createMany?: QPayInvoiceCreateManyProductInputEnvelope
    set?: Enumerable<QPayInvoiceWhereUniqueInput>
    disconnect?: Enumerable<QPayInvoiceWhereUniqueInput>
    delete?: Enumerable<QPayInvoiceWhereUniqueInput>
    connect?: Enumerable<QPayInvoiceWhereUniqueInput>
    update?: Enumerable<QPayInvoiceUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<QPayInvoiceUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<QPayInvoiceScalarWhereInput>
  }

  export type ProductVariantCreatesitsInput = {
    set: Enumerable<number>
  }

  export type ProductCreateNestedOneWithoutProductVariantInput = {
    create?: XOR<ProductCreateWithoutProductVariantInput, ProductUncheckedCreateWithoutProductVariantInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductVariantInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductPaymentCreateNestedManyWithoutProductVariantInput = {
    create?: XOR<Enumerable<ProductPaymentCreateWithoutProductVariantInput>, Enumerable<ProductPaymentUncheckedCreateWithoutProductVariantInput>>
    connectOrCreate?: Enumerable<ProductPaymentCreateOrConnectWithoutProductVariantInput>
    createMany?: ProductPaymentCreateManyProductVariantInputEnvelope
    connect?: Enumerable<ProductPaymentWhereUniqueInput>
  }

  export type QPayInvoiceCreateNestedManyWithoutProductVariantInput = {
    create?: XOR<Enumerable<QPayInvoiceCreateWithoutProductVariantInput>, Enumerable<QPayInvoiceUncheckedCreateWithoutProductVariantInput>>
    connectOrCreate?: Enumerable<QPayInvoiceCreateOrConnectWithoutProductVariantInput>
    createMany?: QPayInvoiceCreateManyProductVariantInputEnvelope
    connect?: Enumerable<QPayInvoiceWhereUniqueInput>
  }

  export type ProductPaymentUncheckedCreateNestedManyWithoutProductVariantInput = {
    create?: XOR<Enumerable<ProductPaymentCreateWithoutProductVariantInput>, Enumerable<ProductPaymentUncheckedCreateWithoutProductVariantInput>>
    connectOrCreate?: Enumerable<ProductPaymentCreateOrConnectWithoutProductVariantInput>
    createMany?: ProductPaymentCreateManyProductVariantInputEnvelope
    connect?: Enumerable<ProductPaymentWhereUniqueInput>
  }

  export type QPayInvoiceUncheckedCreateNestedManyWithoutProductVariantInput = {
    create?: XOR<Enumerable<QPayInvoiceCreateWithoutProductVariantInput>, Enumerable<QPayInvoiceUncheckedCreateWithoutProductVariantInput>>
    connectOrCreate?: Enumerable<QPayInvoiceCreateOrConnectWithoutProductVariantInput>
    createMany?: QPayInvoiceCreateManyProductVariantInputEnvelope
    connect?: Enumerable<QPayInvoiceWhereUniqueInput>
  }

  export type ProductVariantUpdatesitsInput = {
    set?: Enumerable<number>
    push?: number | Enumerable<number>
  }

  export type ProductUpdateOneRequiredWithoutProductVariantNestedInput = {
    create?: XOR<ProductCreateWithoutProductVariantInput, ProductUncheckedCreateWithoutProductVariantInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductVariantInput
    upsert?: ProductUpsertWithoutProductVariantInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutProductVariantInput, ProductUncheckedUpdateWithoutProductVariantInput>
  }

  export type ProductPaymentUpdateManyWithoutProductVariantNestedInput = {
    create?: XOR<Enumerable<ProductPaymentCreateWithoutProductVariantInput>, Enumerable<ProductPaymentUncheckedCreateWithoutProductVariantInput>>
    connectOrCreate?: Enumerable<ProductPaymentCreateOrConnectWithoutProductVariantInput>
    upsert?: Enumerable<ProductPaymentUpsertWithWhereUniqueWithoutProductVariantInput>
    createMany?: ProductPaymentCreateManyProductVariantInputEnvelope
    set?: Enumerable<ProductPaymentWhereUniqueInput>
    disconnect?: Enumerable<ProductPaymentWhereUniqueInput>
    delete?: Enumerable<ProductPaymentWhereUniqueInput>
    connect?: Enumerable<ProductPaymentWhereUniqueInput>
    update?: Enumerable<ProductPaymentUpdateWithWhereUniqueWithoutProductVariantInput>
    updateMany?: Enumerable<ProductPaymentUpdateManyWithWhereWithoutProductVariantInput>
    deleteMany?: Enumerable<ProductPaymentScalarWhereInput>
  }

  export type QPayInvoiceUpdateManyWithoutProductVariantNestedInput = {
    create?: XOR<Enumerable<QPayInvoiceCreateWithoutProductVariantInput>, Enumerable<QPayInvoiceUncheckedCreateWithoutProductVariantInput>>
    connectOrCreate?: Enumerable<QPayInvoiceCreateOrConnectWithoutProductVariantInput>
    upsert?: Enumerable<QPayInvoiceUpsertWithWhereUniqueWithoutProductVariantInput>
    createMany?: QPayInvoiceCreateManyProductVariantInputEnvelope
    set?: Enumerable<QPayInvoiceWhereUniqueInput>
    disconnect?: Enumerable<QPayInvoiceWhereUniqueInput>
    delete?: Enumerable<QPayInvoiceWhereUniqueInput>
    connect?: Enumerable<QPayInvoiceWhereUniqueInput>
    update?: Enumerable<QPayInvoiceUpdateWithWhereUniqueWithoutProductVariantInput>
    updateMany?: Enumerable<QPayInvoiceUpdateManyWithWhereWithoutProductVariantInput>
    deleteMany?: Enumerable<QPayInvoiceScalarWhereInput>
  }

  export type ProductPaymentUncheckedUpdateManyWithoutProductVariantNestedInput = {
    create?: XOR<Enumerable<ProductPaymentCreateWithoutProductVariantInput>, Enumerable<ProductPaymentUncheckedCreateWithoutProductVariantInput>>
    connectOrCreate?: Enumerable<ProductPaymentCreateOrConnectWithoutProductVariantInput>
    upsert?: Enumerable<ProductPaymentUpsertWithWhereUniqueWithoutProductVariantInput>
    createMany?: ProductPaymentCreateManyProductVariantInputEnvelope
    set?: Enumerable<ProductPaymentWhereUniqueInput>
    disconnect?: Enumerable<ProductPaymentWhereUniqueInput>
    delete?: Enumerable<ProductPaymentWhereUniqueInput>
    connect?: Enumerable<ProductPaymentWhereUniqueInput>
    update?: Enumerable<ProductPaymentUpdateWithWhereUniqueWithoutProductVariantInput>
    updateMany?: Enumerable<ProductPaymentUpdateManyWithWhereWithoutProductVariantInput>
    deleteMany?: Enumerable<ProductPaymentScalarWhereInput>
  }

  export type QPayInvoiceUncheckedUpdateManyWithoutProductVariantNestedInput = {
    create?: XOR<Enumerable<QPayInvoiceCreateWithoutProductVariantInput>, Enumerable<QPayInvoiceUncheckedCreateWithoutProductVariantInput>>
    connectOrCreate?: Enumerable<QPayInvoiceCreateOrConnectWithoutProductVariantInput>
    upsert?: Enumerable<QPayInvoiceUpsertWithWhereUniqueWithoutProductVariantInput>
    createMany?: QPayInvoiceCreateManyProductVariantInputEnvelope
    set?: Enumerable<QPayInvoiceWhereUniqueInput>
    disconnect?: Enumerable<QPayInvoiceWhereUniqueInput>
    delete?: Enumerable<QPayInvoiceWhereUniqueInput>
    connect?: Enumerable<QPayInvoiceWhereUniqueInput>
    update?: Enumerable<QPayInvoiceUpdateWithWhereUniqueWithoutProductVariantInput>
    updateMany?: Enumerable<QPayInvoiceUpdateManyWithWhereWithoutProductVariantInput>
    deleteMany?: Enumerable<QPayInvoiceScalarWhereInput>
  }

  export type ProductCreateNestedOneWithoutProductPaymentInput = {
    create?: XOR<ProductCreateWithoutProductPaymentInput, ProductUncheckedCreateWithoutProductPaymentInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductPaymentInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductVariantCreateNestedOneWithoutProductPaymentInput = {
    create?: XOR<ProductVariantCreateWithoutProductPaymentInput, ProductVariantUncheckedCreateWithoutProductPaymentInput>
    connectOrCreate?: ProductVariantCreateOrConnectWithoutProductPaymentInput
    connect?: ProductVariantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProductPaymentInput = {
    create?: XOR<UserCreateWithoutProductPaymentInput, UserUncheckedCreateWithoutProductPaymentInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductPaymentInput
    connect?: UserWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ProductUpdateOneRequiredWithoutProductPaymentNestedInput = {
    create?: XOR<ProductCreateWithoutProductPaymentInput, ProductUncheckedCreateWithoutProductPaymentInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductPaymentInput
    upsert?: ProductUpsertWithoutProductPaymentInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutProductPaymentInput, ProductUncheckedUpdateWithoutProductPaymentInput>
  }

  export type ProductVariantUpdateOneRequiredWithoutProductPaymentNestedInput = {
    create?: XOR<ProductVariantCreateWithoutProductPaymentInput, ProductVariantUncheckedCreateWithoutProductPaymentInput>
    connectOrCreate?: ProductVariantCreateOrConnectWithoutProductPaymentInput
    upsert?: ProductVariantUpsertWithoutProductPaymentInput
    connect?: ProductVariantWhereUniqueInput
    update?: XOR<ProductVariantUpdateWithoutProductPaymentInput, ProductVariantUncheckedUpdateWithoutProductPaymentInput>
  }

  export type UserUpdateOneRequiredWithoutProductPaymentNestedInput = {
    create?: XOR<UserCreateWithoutProductPaymentInput, UserUncheckedCreateWithoutProductPaymentInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductPaymentInput
    upsert?: UserUpsertWithoutProductPaymentInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutProductPaymentInput, UserUncheckedUpdateWithoutProductPaymentInput>
  }

  export type ProductCreateNestedOneWithoutQPayInvoiceInput = {
    create?: XOR<ProductCreateWithoutQPayInvoiceInput, ProductUncheckedCreateWithoutQPayInvoiceInput>
    connectOrCreate?: ProductCreateOrConnectWithoutQPayInvoiceInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductVariantCreateNestedOneWithoutQPayInvoiceInput = {
    create?: XOR<ProductVariantCreateWithoutQPayInvoiceInput, ProductVariantUncheckedCreateWithoutQPayInvoiceInput>
    connectOrCreate?: ProductVariantCreateOrConnectWithoutQPayInvoiceInput
    connect?: ProductVariantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutQPayInvoiceInput = {
    create?: XOR<UserCreateWithoutQPayInvoiceInput, UserUncheckedCreateWithoutQPayInvoiceInput>
    connectOrCreate?: UserCreateOrConnectWithoutQPayInvoiceInput
    connect?: UserWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutQPayInvoiceNestedInput = {
    create?: XOR<ProductCreateWithoutQPayInvoiceInput, ProductUncheckedCreateWithoutQPayInvoiceInput>
    connectOrCreate?: ProductCreateOrConnectWithoutQPayInvoiceInput
    upsert?: ProductUpsertWithoutQPayInvoiceInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutQPayInvoiceInput, ProductUncheckedUpdateWithoutQPayInvoiceInput>
  }

  export type ProductVariantUpdateOneRequiredWithoutQPayInvoiceNestedInput = {
    create?: XOR<ProductVariantCreateWithoutQPayInvoiceInput, ProductVariantUncheckedCreateWithoutQPayInvoiceInput>
    connectOrCreate?: ProductVariantCreateOrConnectWithoutQPayInvoiceInput
    upsert?: ProductVariantUpsertWithoutQPayInvoiceInput
    connect?: ProductVariantWhereUniqueInput
    update?: XOR<ProductVariantUpdateWithoutQPayInvoiceInput, ProductVariantUncheckedUpdateWithoutQPayInvoiceInput>
  }

  export type UserUpdateOneWithoutQPayInvoiceNestedInput = {
    create?: XOR<UserCreateWithoutQPayInvoiceInput, UserUncheckedCreateWithoutQPayInvoiceInput>
    connectOrCreate?: UserCreateOrConnectWithoutQPayInvoiceInput
    upsert?: UserUpsertWithoutQPayInvoiceInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutQPayInvoiceInput, UserUncheckedUpdateWithoutQPayInvoiceInput>
  }

  export type HospitalCreateNestedOneWithoutMessageInput = {
    create?: XOR<HospitalCreateWithoutMessageInput, HospitalUncheckedCreateWithoutMessageInput>
    connectOrCreate?: HospitalCreateOrConnectWithoutMessageInput
    connect?: HospitalWhereUniqueInput
  }

  export type HospitalUpdateOneRequiredWithoutMessageNestedInput = {
    create?: XOR<HospitalCreateWithoutMessageInput, HospitalUncheckedCreateWithoutMessageInput>
    connectOrCreate?: HospitalCreateOrConnectWithoutMessageInput
    upsert?: HospitalUpsertWithoutMessageInput
    connect?: HospitalWhereUniqueInput
    update?: XOR<HospitalUpdateWithoutMessageInput, HospitalUncheckedUpdateWithoutMessageInput>
  }

  export type UserPromoCodeCreateNestedManyWithoutPromoCodeInput = {
    create?: XOR<Enumerable<UserPromoCodeCreateWithoutPromoCodeInput>, Enumerable<UserPromoCodeUncheckedCreateWithoutPromoCodeInput>>
    connectOrCreate?: Enumerable<UserPromoCodeCreateOrConnectWithoutPromoCodeInput>
    createMany?: UserPromoCodeCreateManyPromoCodeInputEnvelope
    connect?: Enumerable<UserPromoCodeWhereUniqueInput>
  }

  export type UserPromoCodeUncheckedCreateNestedManyWithoutPromoCodeInput = {
    create?: XOR<Enumerable<UserPromoCodeCreateWithoutPromoCodeInput>, Enumerable<UserPromoCodeUncheckedCreateWithoutPromoCodeInput>>
    connectOrCreate?: Enumerable<UserPromoCodeCreateOrConnectWithoutPromoCodeInput>
    createMany?: UserPromoCodeCreateManyPromoCodeInputEnvelope
    connect?: Enumerable<UserPromoCodeWhereUniqueInput>
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserPromoCodeUpdateManyWithoutPromoCodeNestedInput = {
    create?: XOR<Enumerable<UserPromoCodeCreateWithoutPromoCodeInput>, Enumerable<UserPromoCodeUncheckedCreateWithoutPromoCodeInput>>
    connectOrCreate?: Enumerable<UserPromoCodeCreateOrConnectWithoutPromoCodeInput>
    upsert?: Enumerable<UserPromoCodeUpsertWithWhereUniqueWithoutPromoCodeInput>
    createMany?: UserPromoCodeCreateManyPromoCodeInputEnvelope
    set?: Enumerable<UserPromoCodeWhereUniqueInput>
    disconnect?: Enumerable<UserPromoCodeWhereUniqueInput>
    delete?: Enumerable<UserPromoCodeWhereUniqueInput>
    connect?: Enumerable<UserPromoCodeWhereUniqueInput>
    update?: Enumerable<UserPromoCodeUpdateWithWhereUniqueWithoutPromoCodeInput>
    updateMany?: Enumerable<UserPromoCodeUpdateManyWithWhereWithoutPromoCodeInput>
    deleteMany?: Enumerable<UserPromoCodeScalarWhereInput>
  }

  export type UserPromoCodeUncheckedUpdateManyWithoutPromoCodeNestedInput = {
    create?: XOR<Enumerable<UserPromoCodeCreateWithoutPromoCodeInput>, Enumerable<UserPromoCodeUncheckedCreateWithoutPromoCodeInput>>
    connectOrCreate?: Enumerable<UserPromoCodeCreateOrConnectWithoutPromoCodeInput>
    upsert?: Enumerable<UserPromoCodeUpsertWithWhereUniqueWithoutPromoCodeInput>
    createMany?: UserPromoCodeCreateManyPromoCodeInputEnvelope
    set?: Enumerable<UserPromoCodeWhereUniqueInput>
    disconnect?: Enumerable<UserPromoCodeWhereUniqueInput>
    delete?: Enumerable<UserPromoCodeWhereUniqueInput>
    connect?: Enumerable<UserPromoCodeWhereUniqueInput>
    update?: Enumerable<UserPromoCodeUpdateWithWhereUniqueWithoutPromoCodeInput>
    updateMany?: Enumerable<UserPromoCodeUpdateManyWithWhereWithoutPromoCodeInput>
    deleteMany?: Enumerable<UserPromoCodeScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutUserPromoCodeInput = {
    create?: XOR<UserCreateWithoutUserPromoCodeInput, UserUncheckedCreateWithoutUserPromoCodeInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserPromoCodeInput
    connect?: UserWhereUniqueInput
  }

  export type PromoCodeCreateNestedOneWithoutUserPromoCodeInput = {
    create?: XOR<PromoCodeCreateWithoutUserPromoCodeInput, PromoCodeUncheckedCreateWithoutUserPromoCodeInput>
    connectOrCreate?: PromoCodeCreateOrConnectWithoutUserPromoCodeInput
    connect?: PromoCodeWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserPromoCodeNestedInput = {
    create?: XOR<UserCreateWithoutUserPromoCodeInput, UserUncheckedCreateWithoutUserPromoCodeInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserPromoCodeInput
    upsert?: UserUpsertWithoutUserPromoCodeInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUserPromoCodeInput, UserUncheckedUpdateWithoutUserPromoCodeInput>
  }

  export type PromoCodeUpdateOneRequiredWithoutUserPromoCodeNestedInput = {
    create?: XOR<PromoCodeCreateWithoutUserPromoCodeInput, PromoCodeUncheckedCreateWithoutUserPromoCodeInput>
    connectOrCreate?: PromoCodeCreateOrConnectWithoutUserPromoCodeInput
    upsert?: PromoCodeUpsertWithoutUserPromoCodeInput
    connect?: PromoCodeWhereUniqueInput
    update?: XOR<PromoCodeUpdateWithoutUserPromoCodeInput, PromoCodeUncheckedUpdateWithoutUserPromoCodeInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedEnumUserRoleFilter = {
    equals?: UserRole
    in?: Enumerable<UserRole>
    notIn?: Enumerable<UserRole>
    not?: NestedEnumUserRoleFilter | UserRole
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedEnumUserRoleWithAggregatesFilter = {
    equals?: UserRole
    in?: Enumerable<UserRole>
    notIn?: Enumerable<UserRole>
    not?: NestedEnumUserRoleWithAggregatesFilter | UserRole
    _count?: NestedIntFilter
    _min?: NestedEnumUserRoleFilter
    _max?: NestedEnumUserRoleFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }
  export type NestedJsonNullableFilter = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase>, Exclude<keyof Required<NestedJsonNullableFilterBase>, 'path'>>,
        Required<NestedJsonNullableFilterBase>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase>, 'path'>>

  export type NestedJsonNullableFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type NestedDecimalNullableFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter
    _avg?: NestedDecimalNullableFilter
    _sum?: NestedDecimalNullableFilter
    _min?: NestedDecimalNullableFilter
    _max?: NestedDecimalNullableFilter
  }

  export type NestedDecimalFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter
    _avg?: NestedDecimalFilter
    _sum?: NestedDecimalFilter
    _min?: NestedDecimalFilter
    _max?: NestedDecimalFilter
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refreshToken?: string | null
    accessToken?: string | null
    tokenType?: string | null
    expiresAt?: number | null
    scope?: string | null
    idToken?: string | null
    sessionState?: string | null
    oauthTokenSecret?: string | null
    oauthToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refreshToken?: string | null
    accessToken?: string | null
    tokenType?: string | null
    expiresAt?: number | null
    scope?: string | null
    idToken?: string | null
    sessionState?: string | null
    oauthTokenSecret?: string | null
    oauthToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: Enumerable<AccountCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ProfileCreateWithoutUserInput = {
    id?: string
    firstName?: string
    lastName?: string
    latinName?: string
    sex?: string | null
    dob?: string | null
    height?: number | null
    weight?: number | null
    picture?: string | null
    priceMin?: number | null
    priceMax?: number | null
    notifyEmail?: boolean
    notifyPush?: boolean
    notifyBadge?: boolean
    historyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    specialistDesc?: string | null
    patientCode?: string | null
    allowPatientAssign?: Date | string | null
  }

  export type ProfileUncheckedCreateWithoutUserInput = {
    id?: string
    firstName?: string
    lastName?: string
    latinName?: string
    sex?: string | null
    dob?: string | null
    height?: number | null
    weight?: number | null
    picture?: string | null
    priceMin?: number | null
    priceMax?: number | null
    notifyEmail?: boolean
    notifyPush?: boolean
    notifyBadge?: boolean
    historyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    specialistDesc?: string | null
    patientCode?: string | null
    allowPatientAssign?: Date | string | null
  }

  export type ProfileCreateOrConnectWithoutUserInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
  }

  export type HospitalCreateWithoutUserInput = {
    id?: string
    hospitalLogo?: string | null
    subDomain?: string | null
    phoneNumber: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    HospitalUsers?: HospitalUsersCreateNestedManyWithoutHospitalInput
    subscription?: SubscriptionCreateNestedManyWithoutHospitalInput
    databaseConnection?: DatabaseConnectionCreateNestedManyWithoutHospitalInput
    Message?: MessageCreateNestedManyWithoutHospitalInput
  }

  export type HospitalUncheckedCreateWithoutUserInput = {
    id?: string
    hospitalLogo?: string | null
    subDomain?: string | null
    phoneNumber: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    HospitalUsers?: HospitalUsersUncheckedCreateNestedManyWithoutHospitalInput
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutHospitalInput
    databaseConnection?: DatabaseConnectionUncheckedCreateNestedManyWithoutHospitalInput
    Message?: MessageUncheckedCreateNestedManyWithoutHospitalInput
  }

  export type HospitalCreateOrConnectWithoutUserInput = {
    where: HospitalWhereUniqueInput
    create: XOR<HospitalCreateWithoutUserInput, HospitalUncheckedCreateWithoutUserInput>
  }

  export type HospitalCreateManyUserInputEnvelope = {
    data: Enumerable<HospitalCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ProductPaymentCreateWithoutUserInput = {
    id?: string
    paidSource?: string | null
    paidAmount?: Decimal | DecimalJsLike | number | string | null
    paidDate?: Date | string | null
    additionalNote?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentStatus: string
    Product: ProductCreateNestedOneWithoutProductPaymentInput
    ProductVariant: ProductVariantCreateNestedOneWithoutProductPaymentInput
  }

  export type ProductPaymentUncheckedCreateWithoutUserInput = {
    id?: string
    paidSource?: string | null
    paidAmount?: Decimal | DecimalJsLike | number | string | null
    paidDate?: Date | string | null
    additionalNote?: string
    productId: string
    productVariantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentStatus: string
  }

  export type ProductPaymentCreateOrConnectWithoutUserInput = {
    where: ProductPaymentWhereUniqueInput
    create: XOR<ProductPaymentCreateWithoutUserInput, ProductPaymentUncheckedCreateWithoutUserInput>
  }

  export type ProductPaymentCreateManyUserInputEnvelope = {
    data: Enumerable<ProductPaymentCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type QPayInvoiceCreateWithoutUserInput = {
    id?: string
    invoiceData?: NullableJsonNullValueInput | InputJsonValue
    payedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Product: ProductCreateNestedOneWithoutQPayInvoiceInput
    ProductVariant: ProductVariantCreateNestedOneWithoutQPayInvoiceInput
  }

  export type QPayInvoiceUncheckedCreateWithoutUserInput = {
    id?: string
    productId: string
    productVariantId: string
    invoiceData?: NullableJsonNullValueInput | InputJsonValue
    payedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QPayInvoiceCreateOrConnectWithoutUserInput = {
    where: QPayInvoiceWhereUniqueInput
    create: XOR<QPayInvoiceCreateWithoutUserInput, QPayInvoiceUncheckedCreateWithoutUserInput>
  }

  export type QPayInvoiceCreateManyUserInputEnvelope = {
    data: Enumerable<QPayInvoiceCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type UserPromoCodeCreateWithoutUserInput = {
    id?: string
    promoCodeUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    promoCode: PromoCodeCreateNestedOneWithoutUserPromoCodeInput
  }

  export type UserPromoCodeUncheckedCreateWithoutUserInput = {
    id?: string
    promoCodeId: string
    promoCodeUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPromoCodeCreateOrConnectWithoutUserInput = {
    where: UserPromoCodeWhereUniqueInput
    create: XOR<UserPromoCodeCreateWithoutUserInput, UserPromoCodeUncheckedCreateWithoutUserInput>
  }

  export type UserPromoCodeCreateManyUserInputEnvelope = {
    data: Enumerable<UserPromoCodeCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutAccountsInput>
  }

  export type AccountScalarWhereInput = {
    AND?: Enumerable<AccountScalarWhereInput>
    OR?: Enumerable<AccountScalarWhereInput>
    NOT?: Enumerable<AccountScalarWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    type?: StringFilter | string
    provider?: StringFilter | string
    providerAccountId?: StringFilter | string
    refreshToken?: StringNullableFilter | string | null
    accessToken?: StringNullableFilter | string | null
    tokenType?: StringNullableFilter | string | null
    expiresAt?: IntNullableFilter | number | null
    scope?: StringNullableFilter | string | null
    idToken?: StringNullableFilter | string | null
    sessionState?: StringNullableFilter | string | null
    oauthTokenSecret?: StringNullableFilter | string | null
    oauthToken?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ProfileUpsertWithoutUserInput = {
    update: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
  }

  export type ProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    latinName?: StringFieldUpdateOperationsInput | string
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    priceMin?: NullableIntFieldUpdateOperationsInput | number | null
    priceMax?: NullableIntFieldUpdateOperationsInput | number | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    notifyBadge?: BoolFieldUpdateOperationsInput | boolean
    historyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    specialistDesc?: NullableStringFieldUpdateOperationsInput | string | null
    patientCode?: NullableStringFieldUpdateOperationsInput | string | null
    allowPatientAssign?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    latinName?: StringFieldUpdateOperationsInput | string
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    priceMin?: NullableIntFieldUpdateOperationsInput | number | null
    priceMax?: NullableIntFieldUpdateOperationsInput | number | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    notifyBadge?: BoolFieldUpdateOperationsInput | boolean
    historyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    specialistDesc?: NullableStringFieldUpdateOperationsInput | string | null
    patientCode?: NullableStringFieldUpdateOperationsInput | string | null
    allowPatientAssign?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HospitalUpsertWithWhereUniqueWithoutUserInput = {
    where: HospitalWhereUniqueInput
    update: XOR<HospitalUpdateWithoutUserInput, HospitalUncheckedUpdateWithoutUserInput>
    create: XOR<HospitalCreateWithoutUserInput, HospitalUncheckedCreateWithoutUserInput>
  }

  export type HospitalUpdateWithWhereUniqueWithoutUserInput = {
    where: HospitalWhereUniqueInput
    data: XOR<HospitalUpdateWithoutUserInput, HospitalUncheckedUpdateWithoutUserInput>
  }

  export type HospitalUpdateManyWithWhereWithoutUserInput = {
    where: HospitalScalarWhereInput
    data: XOR<HospitalUpdateManyMutationInput, HospitalUncheckedUpdateManyWithoutHospitalInput>
  }

  export type HospitalScalarWhereInput = {
    AND?: Enumerable<HospitalScalarWhereInput>
    OR?: Enumerable<HospitalScalarWhereInput>
    NOT?: Enumerable<HospitalScalarWhereInput>
    id?: StringFilter | string
    hospitalLogo?: StringNullableFilter | string | null
    subDomain?: StringNullableFilter | string | null
    phoneNumber?: StringFilter | string
    name?: StringFilter | string
    userId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ProductPaymentUpsertWithWhereUniqueWithoutUserInput = {
    where: ProductPaymentWhereUniqueInput
    update: XOR<ProductPaymentUpdateWithoutUserInput, ProductPaymentUncheckedUpdateWithoutUserInput>
    create: XOR<ProductPaymentCreateWithoutUserInput, ProductPaymentUncheckedCreateWithoutUserInput>
  }

  export type ProductPaymentUpdateWithWhereUniqueWithoutUserInput = {
    where: ProductPaymentWhereUniqueInput
    data: XOR<ProductPaymentUpdateWithoutUserInput, ProductPaymentUncheckedUpdateWithoutUserInput>
  }

  export type ProductPaymentUpdateManyWithWhereWithoutUserInput = {
    where: ProductPaymentScalarWhereInput
    data: XOR<ProductPaymentUpdateManyMutationInput, ProductPaymentUncheckedUpdateManyWithoutProductPaymentInput>
  }

  export type ProductPaymentScalarWhereInput = {
    AND?: Enumerable<ProductPaymentScalarWhereInput>
    OR?: Enumerable<ProductPaymentScalarWhereInput>
    NOT?: Enumerable<ProductPaymentScalarWhereInput>
    id?: StringFilter | string
    paidSource?: StringNullableFilter | string | null
    paidAmount?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    paidDate?: DateTimeNullableFilter | Date | string | null
    additionalNote?: StringFilter | string
    productId?: StringFilter | string
    productVariantId?: StringFilter | string
    userId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    paymentStatus?: StringFilter | string
  }

  export type QPayInvoiceUpsertWithWhereUniqueWithoutUserInput = {
    where: QPayInvoiceWhereUniqueInput
    update: XOR<QPayInvoiceUpdateWithoutUserInput, QPayInvoiceUncheckedUpdateWithoutUserInput>
    create: XOR<QPayInvoiceCreateWithoutUserInput, QPayInvoiceUncheckedCreateWithoutUserInput>
  }

  export type QPayInvoiceUpdateWithWhereUniqueWithoutUserInput = {
    where: QPayInvoiceWhereUniqueInput
    data: XOR<QPayInvoiceUpdateWithoutUserInput, QPayInvoiceUncheckedUpdateWithoutUserInput>
  }

  export type QPayInvoiceUpdateManyWithWhereWithoutUserInput = {
    where: QPayInvoiceScalarWhereInput
    data: XOR<QPayInvoiceUpdateManyMutationInput, QPayInvoiceUncheckedUpdateManyWithoutQPayInvoiceInput>
  }

  export type QPayInvoiceScalarWhereInput = {
    AND?: Enumerable<QPayInvoiceScalarWhereInput>
    OR?: Enumerable<QPayInvoiceScalarWhereInput>
    NOT?: Enumerable<QPayInvoiceScalarWhereInput>
    id?: StringFilter | string
    productId?: StringFilter | string
    productVariantId?: StringFilter | string
    invoiceData?: JsonNullableFilter
    userId?: StringNullableFilter | string | null
    payedDate?: DateTimeNullableFilter | Date | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type UserPromoCodeUpsertWithWhereUniqueWithoutUserInput = {
    where: UserPromoCodeWhereUniqueInput
    update: XOR<UserPromoCodeUpdateWithoutUserInput, UserPromoCodeUncheckedUpdateWithoutUserInput>
    create: XOR<UserPromoCodeCreateWithoutUserInput, UserPromoCodeUncheckedCreateWithoutUserInput>
  }

  export type UserPromoCodeUpdateWithWhereUniqueWithoutUserInput = {
    where: UserPromoCodeWhereUniqueInput
    data: XOR<UserPromoCodeUpdateWithoutUserInput, UserPromoCodeUncheckedUpdateWithoutUserInput>
  }

  export type UserPromoCodeUpdateManyWithWhereWithoutUserInput = {
    where: UserPromoCodeScalarWhereInput
    data: XOR<UserPromoCodeUpdateManyMutationInput, UserPromoCodeUncheckedUpdateManyWithoutUserPromoCodeInput>
  }

  export type UserPromoCodeScalarWhereInput = {
    AND?: Enumerable<UserPromoCodeScalarWhereInput>
    OR?: Enumerable<UserPromoCodeScalarWhereInput>
    NOT?: Enumerable<UserPromoCodeScalarWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    promoCodeId?: StringFilter | string
    promoCodeUsedAt?: DateTimeNullableFilter | Date | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    email?: string | null
    emailVerified?: Date | string | null
    passwordDigest?: string | null
    phoneNumber: string
    phoneNumberVerified?: Date | string | null
    role?: UserRole
    inviteToken?: string | null
    isTokenUsed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invitedBy?: string | null
    pin?: string | null
    pinCreatedAt?: Date | string | null
    pinType?: string | null
    pinVerifiedAt?: Date | string | null
    hospitalId?: string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    hospital?: HospitalCreateNestedManyWithoutUserInput
    ProductPayment?: ProductPaymentCreateNestedManyWithoutUserInput
    QPayInvoice?: QPayInvoiceCreateNestedManyWithoutUserInput
    UserPromoCode?: UserPromoCodeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    email?: string | null
    emailVerified?: Date | string | null
    passwordDigest?: string | null
    phoneNumber: string
    phoneNumberVerified?: Date | string | null
    role?: UserRole
    inviteToken?: string | null
    isTokenUsed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invitedBy?: string | null
    pin?: string | null
    pinCreatedAt?: Date | string | null
    pinType?: string | null
    pinVerifiedAt?: Date | string | null
    hospitalId?: string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    hospital?: HospitalUncheckedCreateNestedManyWithoutUserInput
    ProductPayment?: ProductPaymentUncheckedCreateNestedManyWithoutUserInput
    QPayInvoice?: QPayInvoiceUncheckedCreateNestedManyWithoutUserInput
    UserPromoCode?: UserPromoCodeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordDigest?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneNumberVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    isTokenUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    pinCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pinType?: NullableStringFieldUpdateOperationsInput | string | null
    pinVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hospitalId?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    hospital?: HospitalUpdateManyWithoutUserNestedInput
    ProductPayment?: ProductPaymentUpdateManyWithoutUserNestedInput
    QPayInvoice?: QPayInvoiceUpdateManyWithoutUserNestedInput
    UserPromoCode?: UserPromoCodeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordDigest?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneNumberVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    isTokenUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    pinCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pinType?: NullableStringFieldUpdateOperationsInput | string | null
    pinVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hospitalId?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    hospital?: HospitalUncheckedUpdateManyWithoutUserNestedInput
    ProductPayment?: ProductPaymentUncheckedUpdateManyWithoutUserNestedInput
    QPayInvoice?: QPayInvoiceUncheckedUpdateManyWithoutUserNestedInput
    UserPromoCode?: UserPromoCodeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutProfileInput = {
    id?: string
    email?: string | null
    emailVerified?: Date | string | null
    passwordDigest?: string | null
    phoneNumber: string
    phoneNumberVerified?: Date | string | null
    role?: UserRole
    inviteToken?: string | null
    isTokenUsed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invitedBy?: string | null
    pin?: string | null
    pinCreatedAt?: Date | string | null
    pinType?: string | null
    pinVerifiedAt?: Date | string | null
    hospitalId?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    hospital?: HospitalCreateNestedManyWithoutUserInput
    ProductPayment?: ProductPaymentCreateNestedManyWithoutUserInput
    QPayInvoice?: QPayInvoiceCreateNestedManyWithoutUserInput
    UserPromoCode?: UserPromoCodeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProfileInput = {
    id?: string
    email?: string | null
    emailVerified?: Date | string | null
    passwordDigest?: string | null
    phoneNumber: string
    phoneNumberVerified?: Date | string | null
    role?: UserRole
    inviteToken?: string | null
    isTokenUsed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invitedBy?: string | null
    pin?: string | null
    pinCreatedAt?: Date | string | null
    pinType?: string | null
    pinVerifiedAt?: Date | string | null
    hospitalId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    hospital?: HospitalUncheckedCreateNestedManyWithoutUserInput
    ProductPayment?: ProductPaymentUncheckedCreateNestedManyWithoutUserInput
    QPayInvoice?: QPayInvoiceUncheckedCreateNestedManyWithoutUserInput
    UserPromoCode?: UserPromoCodeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type UserUpsertWithoutProfileInput = {
    update: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type UserUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordDigest?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneNumberVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    isTokenUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    pinCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pinType?: NullableStringFieldUpdateOperationsInput | string | null
    pinVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hospitalId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    hospital?: HospitalUpdateManyWithoutUserNestedInput
    ProductPayment?: ProductPaymentUpdateManyWithoutUserNestedInput
    QPayInvoice?: QPayInvoiceUpdateManyWithoutUserNestedInput
    UserPromoCode?: UserPromoCodeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordDigest?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneNumberVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    isTokenUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    pinCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pinType?: NullableStringFieldUpdateOperationsInput | string | null
    pinVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hospitalId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    hospital?: HospitalUncheckedUpdateManyWithoutUserNestedInput
    ProductPayment?: ProductPaymentUncheckedUpdateManyWithoutUserNestedInput
    QPayInvoice?: QPayInvoiceUncheckedUpdateManyWithoutUserNestedInput
    UserPromoCode?: UserPromoCodeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutHospitalInput = {
    id?: string
    email?: string | null
    emailVerified?: Date | string | null
    passwordDigest?: string | null
    phoneNumber: string
    phoneNumberVerified?: Date | string | null
    role?: UserRole
    inviteToken?: string | null
    isTokenUsed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invitedBy?: string | null
    pin?: string | null
    pinCreatedAt?: Date | string | null
    pinType?: string | null
    pinVerifiedAt?: Date | string | null
    hospitalId?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    ProductPayment?: ProductPaymentCreateNestedManyWithoutUserInput
    QPayInvoice?: QPayInvoiceCreateNestedManyWithoutUserInput
    UserPromoCode?: UserPromoCodeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutHospitalInput = {
    id?: string
    email?: string | null
    emailVerified?: Date | string | null
    passwordDigest?: string | null
    phoneNumber: string
    phoneNumberVerified?: Date | string | null
    role?: UserRole
    inviteToken?: string | null
    isTokenUsed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invitedBy?: string | null
    pin?: string | null
    pinCreatedAt?: Date | string | null
    pinType?: string | null
    pinVerifiedAt?: Date | string | null
    hospitalId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    ProductPayment?: ProductPaymentUncheckedCreateNestedManyWithoutUserInput
    QPayInvoice?: QPayInvoiceUncheckedCreateNestedManyWithoutUserInput
    UserPromoCode?: UserPromoCodeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutHospitalInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHospitalInput, UserUncheckedCreateWithoutHospitalInput>
  }

  export type HospitalUsersCreateWithoutHospitalInput = {
    phoneNumber?: string | null
    userName: string
    role?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HospitalUsersUncheckedCreateWithoutHospitalInput = {
    id?: number
    phoneNumber?: string | null
    userName: string
    role?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HospitalUsersCreateOrConnectWithoutHospitalInput = {
    where: HospitalUsersWhereUniqueInput
    create: XOR<HospitalUsersCreateWithoutHospitalInput, HospitalUsersUncheckedCreateWithoutHospitalInput>
  }

  export type HospitalUsersCreateManyHospitalInputEnvelope = {
    data: Enumerable<HospitalUsersCreateManyHospitalInput>
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutHospitalInput = {
    startDate?: Date | string | null
    endDate?: Date | string | null
    totalDays?: number
    isStart?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    machines?: MachineCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutHospitalInput = {
    id?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    totalDays?: number
    isStart?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    machines?: MachineUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutHospitalInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutHospitalInput, SubscriptionUncheckedCreateWithoutHospitalInput>
  }

  export type SubscriptionCreateManyHospitalInputEnvelope = {
    data: Enumerable<SubscriptionCreateManyHospitalInput>
    skipDuplicates?: boolean
  }

  export type DatabaseConnectionCreateWithoutHospitalInput = {
    id?: string
    connectionName: string
    connectionType: string
    host: string
    port: number
    databaseName: string
    username: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DatabaseConnectionUncheckedCreateWithoutHospitalInput = {
    id?: string
    connectionName: string
    connectionType: string
    host: string
    port: number
    databaseName: string
    username: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DatabaseConnectionCreateOrConnectWithoutHospitalInput = {
    where: DatabaseConnectionWhereUniqueInput
    create: XOR<DatabaseConnectionCreateWithoutHospitalInput, DatabaseConnectionUncheckedCreateWithoutHospitalInput>
  }

  export type DatabaseConnectionCreateManyHospitalInputEnvelope = {
    data: Enumerable<DatabaseConnectionCreateManyHospitalInput>
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutHospitalInput = {
    id?: string
    phoneNumber: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUncheckedCreateWithoutHospitalInput = {
    id?: string
    phoneNumber: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutHospitalInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutHospitalInput, MessageUncheckedCreateWithoutHospitalInput>
  }

  export type MessageCreateManyHospitalInputEnvelope = {
    data: Enumerable<MessageCreateManyHospitalInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutHospitalInput = {
    update: XOR<UserUpdateWithoutHospitalInput, UserUncheckedUpdateWithoutHospitalInput>
    create: XOR<UserCreateWithoutHospitalInput, UserUncheckedCreateWithoutHospitalInput>
  }

  export type UserUpdateWithoutHospitalInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordDigest?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneNumberVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    isTokenUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    pinCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pinType?: NullableStringFieldUpdateOperationsInput | string | null
    pinVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hospitalId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    ProductPayment?: ProductPaymentUpdateManyWithoutUserNestedInput
    QPayInvoice?: QPayInvoiceUpdateManyWithoutUserNestedInput
    UserPromoCode?: UserPromoCodeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutHospitalInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordDigest?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneNumberVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    isTokenUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    pinCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pinType?: NullableStringFieldUpdateOperationsInput | string | null
    pinVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hospitalId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    ProductPayment?: ProductPaymentUncheckedUpdateManyWithoutUserNestedInput
    QPayInvoice?: QPayInvoiceUncheckedUpdateManyWithoutUserNestedInput
    UserPromoCode?: UserPromoCodeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type HospitalUsersUpsertWithWhereUniqueWithoutHospitalInput = {
    where: HospitalUsersWhereUniqueInput
    update: XOR<HospitalUsersUpdateWithoutHospitalInput, HospitalUsersUncheckedUpdateWithoutHospitalInput>
    create: XOR<HospitalUsersCreateWithoutHospitalInput, HospitalUsersUncheckedCreateWithoutHospitalInput>
  }

  export type HospitalUsersUpdateWithWhereUniqueWithoutHospitalInput = {
    where: HospitalUsersWhereUniqueInput
    data: XOR<HospitalUsersUpdateWithoutHospitalInput, HospitalUsersUncheckedUpdateWithoutHospitalInput>
  }

  export type HospitalUsersUpdateManyWithWhereWithoutHospitalInput = {
    where: HospitalUsersScalarWhereInput
    data: XOR<HospitalUsersUpdateManyMutationInput, HospitalUsersUncheckedUpdateManyWithoutHospitalUsersInput>
  }

  export type HospitalUsersScalarWhereInput = {
    AND?: Enumerable<HospitalUsersScalarWhereInput>
    OR?: Enumerable<HospitalUsersScalarWhereInput>
    NOT?: Enumerable<HospitalUsersScalarWhereInput>
    id?: IntFilter | number
    hospitalId?: StringFilter | string
    phoneNumber?: StringNullableFilter | string | null
    userName?: StringFilter | string
    role?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutHospitalInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutHospitalInput, SubscriptionUncheckedUpdateWithoutHospitalInput>
    create: XOR<SubscriptionCreateWithoutHospitalInput, SubscriptionUncheckedCreateWithoutHospitalInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutHospitalInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutHospitalInput, SubscriptionUncheckedUpdateWithoutHospitalInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutHospitalInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type SubscriptionScalarWhereInput = {
    AND?: Enumerable<SubscriptionScalarWhereInput>
    OR?: Enumerable<SubscriptionScalarWhereInput>
    NOT?: Enumerable<SubscriptionScalarWhereInput>
    id?: IntFilter | number
    startDate?: DateTimeNullableFilter | Date | string | null
    endDate?: DateTimeNullableFilter | Date | string | null
    totalDays?: IntFilter | number
    isStart?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    hospitalId?: StringNullableFilter | string | null
  }

  export type DatabaseConnectionUpsertWithWhereUniqueWithoutHospitalInput = {
    where: DatabaseConnectionWhereUniqueInput
    update: XOR<DatabaseConnectionUpdateWithoutHospitalInput, DatabaseConnectionUncheckedUpdateWithoutHospitalInput>
    create: XOR<DatabaseConnectionCreateWithoutHospitalInput, DatabaseConnectionUncheckedCreateWithoutHospitalInput>
  }

  export type DatabaseConnectionUpdateWithWhereUniqueWithoutHospitalInput = {
    where: DatabaseConnectionWhereUniqueInput
    data: XOR<DatabaseConnectionUpdateWithoutHospitalInput, DatabaseConnectionUncheckedUpdateWithoutHospitalInput>
  }

  export type DatabaseConnectionUpdateManyWithWhereWithoutHospitalInput = {
    where: DatabaseConnectionScalarWhereInput
    data: XOR<DatabaseConnectionUpdateManyMutationInput, DatabaseConnectionUncheckedUpdateManyWithoutDatabaseConnectionInput>
  }

  export type DatabaseConnectionScalarWhereInput = {
    AND?: Enumerable<DatabaseConnectionScalarWhereInput>
    OR?: Enumerable<DatabaseConnectionScalarWhereInput>
    NOT?: Enumerable<DatabaseConnectionScalarWhereInput>
    id?: StringFilter | string
    connectionName?: StringFilter | string
    connectionType?: StringFilter | string
    host?: StringFilter | string
    port?: IntFilter | number
    databaseName?: StringFilter | string
    username?: StringFilter | string
    password?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    hospitalId?: StringNullableFilter | string | null
  }

  export type MessageUpsertWithWhereUniqueWithoutHospitalInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutHospitalInput, MessageUncheckedUpdateWithoutHospitalInput>
    create: XOR<MessageCreateWithoutHospitalInput, MessageUncheckedCreateWithoutHospitalInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutHospitalInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutHospitalInput, MessageUncheckedUpdateWithoutHospitalInput>
  }

  export type MessageUpdateManyWithWhereWithoutHospitalInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutMessageInput>
  }

  export type MessageScalarWhereInput = {
    AND?: Enumerable<MessageScalarWhereInput>
    OR?: Enumerable<MessageScalarWhereInput>
    NOT?: Enumerable<MessageScalarWhereInput>
    id?: StringFilter | string
    phoneNumber?: StringFilter | string
    message?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    hospitalId?: StringFilter | string
  }

  export type MachineCreateWithoutSubscriptionInput = {
    machineName: string
    machineUniqueId: string
    registeredAt?: Date | string
  }

  export type MachineUncheckedCreateWithoutSubscriptionInput = {
    id?: number
    machineName: string
    machineUniqueId: string
    registeredAt?: Date | string
  }

  export type MachineCreateOrConnectWithoutSubscriptionInput = {
    where: MachineWhereUniqueInput
    create: XOR<MachineCreateWithoutSubscriptionInput, MachineUncheckedCreateWithoutSubscriptionInput>
  }

  export type MachineCreateManySubscriptionInputEnvelope = {
    data: Enumerable<MachineCreateManySubscriptionInput>
    skipDuplicates?: boolean
  }

  export type HospitalCreateWithoutSubscriptionInput = {
    id?: string
    hospitalLogo?: string | null
    subDomain?: string | null
    phoneNumber: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    User: UserCreateNestedOneWithoutHospitalInput
    HospitalUsers?: HospitalUsersCreateNestedManyWithoutHospitalInput
    databaseConnection?: DatabaseConnectionCreateNestedManyWithoutHospitalInput
    Message?: MessageCreateNestedManyWithoutHospitalInput
  }

  export type HospitalUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    hospitalLogo?: string | null
    subDomain?: string | null
    phoneNumber: string
    name: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    HospitalUsers?: HospitalUsersUncheckedCreateNestedManyWithoutHospitalInput
    databaseConnection?: DatabaseConnectionUncheckedCreateNestedManyWithoutHospitalInput
    Message?: MessageUncheckedCreateNestedManyWithoutHospitalInput
  }

  export type HospitalCreateOrConnectWithoutSubscriptionInput = {
    where: HospitalWhereUniqueInput
    create: XOR<HospitalCreateWithoutSubscriptionInput, HospitalUncheckedCreateWithoutSubscriptionInput>
  }

  export type MachineUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: MachineWhereUniqueInput
    update: XOR<MachineUpdateWithoutSubscriptionInput, MachineUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<MachineCreateWithoutSubscriptionInput, MachineUncheckedCreateWithoutSubscriptionInput>
  }

  export type MachineUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: MachineWhereUniqueInput
    data: XOR<MachineUpdateWithoutSubscriptionInput, MachineUncheckedUpdateWithoutSubscriptionInput>
  }

  export type MachineUpdateManyWithWhereWithoutSubscriptionInput = {
    where: MachineScalarWhereInput
    data: XOR<MachineUpdateManyMutationInput, MachineUncheckedUpdateManyWithoutMachinesInput>
  }

  export type MachineScalarWhereInput = {
    AND?: Enumerable<MachineScalarWhereInput>
    OR?: Enumerable<MachineScalarWhereInput>
    NOT?: Enumerable<MachineScalarWhereInput>
    id?: IntFilter | number
    subscriptionId?: IntFilter | number
    machineName?: StringFilter | string
    machineUniqueId?: StringFilter | string
    registeredAt?: DateTimeFilter | Date | string
  }

  export type HospitalUpsertWithoutSubscriptionInput = {
    update: XOR<HospitalUpdateWithoutSubscriptionInput, HospitalUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<HospitalCreateWithoutSubscriptionInput, HospitalUncheckedCreateWithoutSubscriptionInput>
  }

  export type HospitalUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    hospitalLogo?: NullableStringFieldUpdateOperationsInput | string | null
    subDomain?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutHospitalNestedInput
    HospitalUsers?: HospitalUsersUpdateManyWithoutHospitalNestedInput
    databaseConnection?: DatabaseConnectionUpdateManyWithoutHospitalNestedInput
    Message?: MessageUpdateManyWithoutHospitalNestedInput
  }

  export type HospitalUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    hospitalLogo?: NullableStringFieldUpdateOperationsInput | string | null
    subDomain?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    HospitalUsers?: HospitalUsersUncheckedUpdateManyWithoutHospitalNestedInput
    databaseConnection?: DatabaseConnectionUncheckedUpdateManyWithoutHospitalNestedInput
    Message?: MessageUncheckedUpdateManyWithoutHospitalNestedInput
  }

  export type SubscriptionCreateWithoutMachinesInput = {
    startDate?: Date | string | null
    endDate?: Date | string | null
    totalDays?: number
    isStart?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Hospital?: HospitalCreateNestedOneWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutMachinesInput = {
    id?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    totalDays?: number
    isStart?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    hospitalId?: string | null
  }

  export type SubscriptionCreateOrConnectWithoutMachinesInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutMachinesInput, SubscriptionUncheckedCreateWithoutMachinesInput>
  }

  export type SubscriptionUpsertWithoutMachinesInput = {
    update: XOR<SubscriptionUpdateWithoutMachinesInput, SubscriptionUncheckedUpdateWithoutMachinesInput>
    create: XOR<SubscriptionCreateWithoutMachinesInput, SubscriptionUncheckedCreateWithoutMachinesInput>
  }

  export type SubscriptionUpdateWithoutMachinesInput = {
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalDays?: IntFieldUpdateOperationsInput | number
    isStart?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Hospital?: HospitalUpdateOneWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutMachinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalDays?: IntFieldUpdateOperationsInput | number
    isStart?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hospitalId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HospitalCreateWithoutHospitalUsersInput = {
    id?: string
    hospitalLogo?: string | null
    subDomain?: string | null
    phoneNumber: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    User: UserCreateNestedOneWithoutHospitalInput
    subscription?: SubscriptionCreateNestedManyWithoutHospitalInput
    databaseConnection?: DatabaseConnectionCreateNestedManyWithoutHospitalInput
    Message?: MessageCreateNestedManyWithoutHospitalInput
  }

  export type HospitalUncheckedCreateWithoutHospitalUsersInput = {
    id?: string
    hospitalLogo?: string | null
    subDomain?: string | null
    phoneNumber: string
    name: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutHospitalInput
    databaseConnection?: DatabaseConnectionUncheckedCreateNestedManyWithoutHospitalInput
    Message?: MessageUncheckedCreateNestedManyWithoutHospitalInput
  }

  export type HospitalCreateOrConnectWithoutHospitalUsersInput = {
    where: HospitalWhereUniqueInput
    create: XOR<HospitalCreateWithoutHospitalUsersInput, HospitalUncheckedCreateWithoutHospitalUsersInput>
  }

  export type HospitalUpsertWithoutHospitalUsersInput = {
    update: XOR<HospitalUpdateWithoutHospitalUsersInput, HospitalUncheckedUpdateWithoutHospitalUsersInput>
    create: XOR<HospitalCreateWithoutHospitalUsersInput, HospitalUncheckedCreateWithoutHospitalUsersInput>
  }

  export type HospitalUpdateWithoutHospitalUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    hospitalLogo?: NullableStringFieldUpdateOperationsInput | string | null
    subDomain?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutHospitalNestedInput
    subscription?: SubscriptionUpdateManyWithoutHospitalNestedInput
    databaseConnection?: DatabaseConnectionUpdateManyWithoutHospitalNestedInput
    Message?: MessageUpdateManyWithoutHospitalNestedInput
  }

  export type HospitalUncheckedUpdateWithoutHospitalUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    hospitalLogo?: NullableStringFieldUpdateOperationsInput | string | null
    subDomain?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUncheckedUpdateManyWithoutHospitalNestedInput
    databaseConnection?: DatabaseConnectionUncheckedUpdateManyWithoutHospitalNestedInput
    Message?: MessageUncheckedUpdateManyWithoutHospitalNestedInput
  }

  export type HospitalCreateWithoutDatabaseConnectionInput = {
    id?: string
    hospitalLogo?: string | null
    subDomain?: string | null
    phoneNumber: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    User: UserCreateNestedOneWithoutHospitalInput
    HospitalUsers?: HospitalUsersCreateNestedManyWithoutHospitalInput
    subscription?: SubscriptionCreateNestedManyWithoutHospitalInput
    Message?: MessageCreateNestedManyWithoutHospitalInput
  }

  export type HospitalUncheckedCreateWithoutDatabaseConnectionInput = {
    id?: string
    hospitalLogo?: string | null
    subDomain?: string | null
    phoneNumber: string
    name: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    HospitalUsers?: HospitalUsersUncheckedCreateNestedManyWithoutHospitalInput
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutHospitalInput
    Message?: MessageUncheckedCreateNestedManyWithoutHospitalInput
  }

  export type HospitalCreateOrConnectWithoutDatabaseConnectionInput = {
    where: HospitalWhereUniqueInput
    create: XOR<HospitalCreateWithoutDatabaseConnectionInput, HospitalUncheckedCreateWithoutDatabaseConnectionInput>
  }

  export type HospitalUpsertWithoutDatabaseConnectionInput = {
    update: XOR<HospitalUpdateWithoutDatabaseConnectionInput, HospitalUncheckedUpdateWithoutDatabaseConnectionInput>
    create: XOR<HospitalCreateWithoutDatabaseConnectionInput, HospitalUncheckedCreateWithoutDatabaseConnectionInput>
  }

  export type HospitalUpdateWithoutDatabaseConnectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    hospitalLogo?: NullableStringFieldUpdateOperationsInput | string | null
    subDomain?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutHospitalNestedInput
    HospitalUsers?: HospitalUsersUpdateManyWithoutHospitalNestedInput
    subscription?: SubscriptionUpdateManyWithoutHospitalNestedInput
    Message?: MessageUpdateManyWithoutHospitalNestedInput
  }

  export type HospitalUncheckedUpdateWithoutDatabaseConnectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    hospitalLogo?: NullableStringFieldUpdateOperationsInput | string | null
    subDomain?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    HospitalUsers?: HospitalUsersUncheckedUpdateManyWithoutHospitalNestedInput
    subscription?: SubscriptionUncheckedUpdateManyWithoutHospitalNestedInput
    Message?: MessageUncheckedUpdateManyWithoutHospitalNestedInput
  }

  export type ProductVariantCreateWithoutProductInput = {
    id?: string
    name: string
    price: number
    unit: number
    duration: number
    discount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sits?: ProductVariantCreatesitsInput | Enumerable<number>
    ProductPayment?: ProductPaymentCreateNestedManyWithoutProductVariantInput
    QPayInvoice?: QPayInvoiceCreateNestedManyWithoutProductVariantInput
  }

  export type ProductVariantUncheckedCreateWithoutProductInput = {
    id?: string
    name: string
    price: number
    unit: number
    duration: number
    discount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sits?: ProductVariantCreatesitsInput | Enumerable<number>
    ProductPayment?: ProductPaymentUncheckedCreateNestedManyWithoutProductVariantInput
    QPayInvoice?: QPayInvoiceUncheckedCreateNestedManyWithoutProductVariantInput
  }

  export type ProductVariantCreateOrConnectWithoutProductInput = {
    where: ProductVariantWhereUniqueInput
    create: XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput>
  }

  export type ProductVariantCreateManyProductInputEnvelope = {
    data: Enumerable<ProductVariantCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type ProductPaymentCreateWithoutProductInput = {
    id?: string
    paidSource?: string | null
    paidAmount?: Decimal | DecimalJsLike | number | string | null
    paidDate?: Date | string | null
    additionalNote?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentStatus: string
    ProductVariant: ProductVariantCreateNestedOneWithoutProductPaymentInput
    User: UserCreateNestedOneWithoutProductPaymentInput
  }

  export type ProductPaymentUncheckedCreateWithoutProductInput = {
    id?: string
    paidSource?: string | null
    paidAmount?: Decimal | DecimalJsLike | number | string | null
    paidDate?: Date | string | null
    additionalNote?: string
    productVariantId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentStatus: string
  }

  export type ProductPaymentCreateOrConnectWithoutProductInput = {
    where: ProductPaymentWhereUniqueInput
    create: XOR<ProductPaymentCreateWithoutProductInput, ProductPaymentUncheckedCreateWithoutProductInput>
  }

  export type ProductPaymentCreateManyProductInputEnvelope = {
    data: Enumerable<ProductPaymentCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type QPayInvoiceCreateWithoutProductInput = {
    id?: string
    invoiceData?: NullableJsonNullValueInput | InputJsonValue
    payedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ProductVariant: ProductVariantCreateNestedOneWithoutQPayInvoiceInput
    user?: UserCreateNestedOneWithoutQPayInvoiceInput
  }

  export type QPayInvoiceUncheckedCreateWithoutProductInput = {
    id?: string
    productVariantId: string
    invoiceData?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    payedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QPayInvoiceCreateOrConnectWithoutProductInput = {
    where: QPayInvoiceWhereUniqueInput
    create: XOR<QPayInvoiceCreateWithoutProductInput, QPayInvoiceUncheckedCreateWithoutProductInput>
  }

  export type QPayInvoiceCreateManyProductInputEnvelope = {
    data: Enumerable<QPayInvoiceCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type ProductVariantUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductVariantWhereUniqueInput
    update: XOR<ProductVariantUpdateWithoutProductInput, ProductVariantUncheckedUpdateWithoutProductInput>
    create: XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput>
  }

  export type ProductVariantUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductVariantWhereUniqueInput
    data: XOR<ProductVariantUpdateWithoutProductInput, ProductVariantUncheckedUpdateWithoutProductInput>
  }

  export type ProductVariantUpdateManyWithWhereWithoutProductInput = {
    where: ProductVariantScalarWhereInput
    data: XOR<ProductVariantUpdateManyMutationInput, ProductVariantUncheckedUpdateManyWithoutProductVariantInput>
  }

  export type ProductVariantScalarWhereInput = {
    AND?: Enumerable<ProductVariantScalarWhereInput>
    OR?: Enumerable<ProductVariantScalarWhereInput>
    NOT?: Enumerable<ProductVariantScalarWhereInput>
    id?: StringFilter | string
    productId?: StringFilter | string
    name?: StringFilter | string
    price?: IntFilter | number
    unit?: IntFilter | number
    duration?: IntFilter | number
    discount?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    sits?: IntNullableListFilter
  }

  export type ProductPaymentUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductPaymentWhereUniqueInput
    update: XOR<ProductPaymentUpdateWithoutProductInput, ProductPaymentUncheckedUpdateWithoutProductInput>
    create: XOR<ProductPaymentCreateWithoutProductInput, ProductPaymentUncheckedCreateWithoutProductInput>
  }

  export type ProductPaymentUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductPaymentWhereUniqueInput
    data: XOR<ProductPaymentUpdateWithoutProductInput, ProductPaymentUncheckedUpdateWithoutProductInput>
  }

  export type ProductPaymentUpdateManyWithWhereWithoutProductInput = {
    where: ProductPaymentScalarWhereInput
    data: XOR<ProductPaymentUpdateManyMutationInput, ProductPaymentUncheckedUpdateManyWithoutProductPaymentInput>
  }

  export type QPayInvoiceUpsertWithWhereUniqueWithoutProductInput = {
    where: QPayInvoiceWhereUniqueInput
    update: XOR<QPayInvoiceUpdateWithoutProductInput, QPayInvoiceUncheckedUpdateWithoutProductInput>
    create: XOR<QPayInvoiceCreateWithoutProductInput, QPayInvoiceUncheckedCreateWithoutProductInput>
  }

  export type QPayInvoiceUpdateWithWhereUniqueWithoutProductInput = {
    where: QPayInvoiceWhereUniqueInput
    data: XOR<QPayInvoiceUpdateWithoutProductInput, QPayInvoiceUncheckedUpdateWithoutProductInput>
  }

  export type QPayInvoiceUpdateManyWithWhereWithoutProductInput = {
    where: QPayInvoiceScalarWhereInput
    data: XOR<QPayInvoiceUpdateManyMutationInput, QPayInvoiceUncheckedUpdateManyWithoutQPayInvoiceInput>
  }

  export type ProductCreateWithoutProductVariantInput = {
    id?: string
    name: string
    productDescription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ProductPayment?: ProductPaymentCreateNestedManyWithoutProductInput
    QPayInvoice?: QPayInvoiceCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductVariantInput = {
    id?: string
    name: string
    productDescription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ProductPayment?: ProductPaymentUncheckedCreateNestedManyWithoutProductInput
    QPayInvoice?: QPayInvoiceUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductVariantInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductVariantInput, ProductUncheckedCreateWithoutProductVariantInput>
  }

  export type ProductPaymentCreateWithoutProductVariantInput = {
    id?: string
    paidSource?: string | null
    paidAmount?: Decimal | DecimalJsLike | number | string | null
    paidDate?: Date | string | null
    additionalNote?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentStatus: string
    Product: ProductCreateNestedOneWithoutProductPaymentInput
    User: UserCreateNestedOneWithoutProductPaymentInput
  }

  export type ProductPaymentUncheckedCreateWithoutProductVariantInput = {
    id?: string
    paidSource?: string | null
    paidAmount?: Decimal | DecimalJsLike | number | string | null
    paidDate?: Date | string | null
    additionalNote?: string
    productId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentStatus: string
  }

  export type ProductPaymentCreateOrConnectWithoutProductVariantInput = {
    where: ProductPaymentWhereUniqueInput
    create: XOR<ProductPaymentCreateWithoutProductVariantInput, ProductPaymentUncheckedCreateWithoutProductVariantInput>
  }

  export type ProductPaymentCreateManyProductVariantInputEnvelope = {
    data: Enumerable<ProductPaymentCreateManyProductVariantInput>
    skipDuplicates?: boolean
  }

  export type QPayInvoiceCreateWithoutProductVariantInput = {
    id?: string
    invoiceData?: NullableJsonNullValueInput | InputJsonValue
    payedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Product: ProductCreateNestedOneWithoutQPayInvoiceInput
    user?: UserCreateNestedOneWithoutQPayInvoiceInput
  }

  export type QPayInvoiceUncheckedCreateWithoutProductVariantInput = {
    id?: string
    productId: string
    invoiceData?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    payedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QPayInvoiceCreateOrConnectWithoutProductVariantInput = {
    where: QPayInvoiceWhereUniqueInput
    create: XOR<QPayInvoiceCreateWithoutProductVariantInput, QPayInvoiceUncheckedCreateWithoutProductVariantInput>
  }

  export type QPayInvoiceCreateManyProductVariantInputEnvelope = {
    data: Enumerable<QPayInvoiceCreateManyProductVariantInput>
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithoutProductVariantInput = {
    update: XOR<ProductUpdateWithoutProductVariantInput, ProductUncheckedUpdateWithoutProductVariantInput>
    create: XOR<ProductCreateWithoutProductVariantInput, ProductUncheckedCreateWithoutProductVariantInput>
  }

  export type ProductUpdateWithoutProductVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    productDescription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ProductPayment?: ProductPaymentUpdateManyWithoutProductNestedInput
    QPayInvoice?: QPayInvoiceUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProductVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    productDescription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ProductPayment?: ProductPaymentUncheckedUpdateManyWithoutProductNestedInput
    QPayInvoice?: QPayInvoiceUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductPaymentUpsertWithWhereUniqueWithoutProductVariantInput = {
    where: ProductPaymentWhereUniqueInput
    update: XOR<ProductPaymentUpdateWithoutProductVariantInput, ProductPaymentUncheckedUpdateWithoutProductVariantInput>
    create: XOR<ProductPaymentCreateWithoutProductVariantInput, ProductPaymentUncheckedCreateWithoutProductVariantInput>
  }

  export type ProductPaymentUpdateWithWhereUniqueWithoutProductVariantInput = {
    where: ProductPaymentWhereUniqueInput
    data: XOR<ProductPaymentUpdateWithoutProductVariantInput, ProductPaymentUncheckedUpdateWithoutProductVariantInput>
  }

  export type ProductPaymentUpdateManyWithWhereWithoutProductVariantInput = {
    where: ProductPaymentScalarWhereInput
    data: XOR<ProductPaymentUpdateManyMutationInput, ProductPaymentUncheckedUpdateManyWithoutProductPaymentInput>
  }

  export type QPayInvoiceUpsertWithWhereUniqueWithoutProductVariantInput = {
    where: QPayInvoiceWhereUniqueInput
    update: XOR<QPayInvoiceUpdateWithoutProductVariantInput, QPayInvoiceUncheckedUpdateWithoutProductVariantInput>
    create: XOR<QPayInvoiceCreateWithoutProductVariantInput, QPayInvoiceUncheckedCreateWithoutProductVariantInput>
  }

  export type QPayInvoiceUpdateWithWhereUniqueWithoutProductVariantInput = {
    where: QPayInvoiceWhereUniqueInput
    data: XOR<QPayInvoiceUpdateWithoutProductVariantInput, QPayInvoiceUncheckedUpdateWithoutProductVariantInput>
  }

  export type QPayInvoiceUpdateManyWithWhereWithoutProductVariantInput = {
    where: QPayInvoiceScalarWhereInput
    data: XOR<QPayInvoiceUpdateManyMutationInput, QPayInvoiceUncheckedUpdateManyWithoutQPayInvoiceInput>
  }

  export type ProductCreateWithoutProductPaymentInput = {
    id?: string
    name: string
    productDescription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ProductVariant?: ProductVariantCreateNestedManyWithoutProductInput
    QPayInvoice?: QPayInvoiceCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductPaymentInput = {
    id?: string
    name: string
    productDescription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ProductVariant?: ProductVariantUncheckedCreateNestedManyWithoutProductInput
    QPayInvoice?: QPayInvoiceUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductPaymentInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductPaymentInput, ProductUncheckedCreateWithoutProductPaymentInput>
  }

  export type ProductVariantCreateWithoutProductPaymentInput = {
    id?: string
    name: string
    price: number
    unit: number
    duration: number
    discount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sits?: ProductVariantCreatesitsInput | Enumerable<number>
    Product: ProductCreateNestedOneWithoutProductVariantInput
    QPayInvoice?: QPayInvoiceCreateNestedManyWithoutProductVariantInput
  }

  export type ProductVariantUncheckedCreateWithoutProductPaymentInput = {
    id?: string
    productId: string
    name: string
    price: number
    unit: number
    duration: number
    discount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sits?: ProductVariantCreatesitsInput | Enumerable<number>
    QPayInvoice?: QPayInvoiceUncheckedCreateNestedManyWithoutProductVariantInput
  }

  export type ProductVariantCreateOrConnectWithoutProductPaymentInput = {
    where: ProductVariantWhereUniqueInput
    create: XOR<ProductVariantCreateWithoutProductPaymentInput, ProductVariantUncheckedCreateWithoutProductPaymentInput>
  }

  export type UserCreateWithoutProductPaymentInput = {
    id?: string
    email?: string | null
    emailVerified?: Date | string | null
    passwordDigest?: string | null
    phoneNumber: string
    phoneNumberVerified?: Date | string | null
    role?: UserRole
    inviteToken?: string | null
    isTokenUsed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invitedBy?: string | null
    pin?: string | null
    pinCreatedAt?: Date | string | null
    pinType?: string | null
    pinVerifiedAt?: Date | string | null
    hospitalId?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    hospital?: HospitalCreateNestedManyWithoutUserInput
    QPayInvoice?: QPayInvoiceCreateNestedManyWithoutUserInput
    UserPromoCode?: UserPromoCodeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProductPaymentInput = {
    id?: string
    email?: string | null
    emailVerified?: Date | string | null
    passwordDigest?: string | null
    phoneNumber: string
    phoneNumberVerified?: Date | string | null
    role?: UserRole
    inviteToken?: string | null
    isTokenUsed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invitedBy?: string | null
    pin?: string | null
    pinCreatedAt?: Date | string | null
    pinType?: string | null
    pinVerifiedAt?: Date | string | null
    hospitalId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    hospital?: HospitalUncheckedCreateNestedManyWithoutUserInput
    QPayInvoice?: QPayInvoiceUncheckedCreateNestedManyWithoutUserInput
    UserPromoCode?: UserPromoCodeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProductPaymentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProductPaymentInput, UserUncheckedCreateWithoutProductPaymentInput>
  }

  export type ProductUpsertWithoutProductPaymentInput = {
    update: XOR<ProductUpdateWithoutProductPaymentInput, ProductUncheckedUpdateWithoutProductPaymentInput>
    create: XOR<ProductCreateWithoutProductPaymentInput, ProductUncheckedCreateWithoutProductPaymentInput>
  }

  export type ProductUpdateWithoutProductPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    productDescription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ProductVariant?: ProductVariantUpdateManyWithoutProductNestedInput
    QPayInvoice?: QPayInvoiceUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProductPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    productDescription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ProductVariant?: ProductVariantUncheckedUpdateManyWithoutProductNestedInput
    QPayInvoice?: QPayInvoiceUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductVariantUpsertWithoutProductPaymentInput = {
    update: XOR<ProductVariantUpdateWithoutProductPaymentInput, ProductVariantUncheckedUpdateWithoutProductPaymentInput>
    create: XOR<ProductVariantCreateWithoutProductPaymentInput, ProductVariantUncheckedCreateWithoutProductPaymentInput>
  }

  export type ProductVariantUpdateWithoutProductPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    unit?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sits?: ProductVariantUpdatesitsInput | Enumerable<number>
    Product?: ProductUpdateOneRequiredWithoutProductVariantNestedInput
    QPayInvoice?: QPayInvoiceUpdateManyWithoutProductVariantNestedInput
  }

  export type ProductVariantUncheckedUpdateWithoutProductPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    unit?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sits?: ProductVariantUpdatesitsInput | Enumerable<number>
    QPayInvoice?: QPayInvoiceUncheckedUpdateManyWithoutProductVariantNestedInput
  }

  export type UserUpsertWithoutProductPaymentInput = {
    update: XOR<UserUpdateWithoutProductPaymentInput, UserUncheckedUpdateWithoutProductPaymentInput>
    create: XOR<UserCreateWithoutProductPaymentInput, UserUncheckedCreateWithoutProductPaymentInput>
  }

  export type UserUpdateWithoutProductPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordDigest?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneNumberVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    isTokenUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    pinCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pinType?: NullableStringFieldUpdateOperationsInput | string | null
    pinVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hospitalId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    hospital?: HospitalUpdateManyWithoutUserNestedInput
    QPayInvoice?: QPayInvoiceUpdateManyWithoutUserNestedInput
    UserPromoCode?: UserPromoCodeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProductPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordDigest?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneNumberVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    isTokenUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    pinCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pinType?: NullableStringFieldUpdateOperationsInput | string | null
    pinVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hospitalId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    hospital?: HospitalUncheckedUpdateManyWithoutUserNestedInput
    QPayInvoice?: QPayInvoiceUncheckedUpdateManyWithoutUserNestedInput
    UserPromoCode?: UserPromoCodeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductCreateWithoutQPayInvoiceInput = {
    id?: string
    name: string
    productDescription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ProductVariant?: ProductVariantCreateNestedManyWithoutProductInput
    ProductPayment?: ProductPaymentCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutQPayInvoiceInput = {
    id?: string
    name: string
    productDescription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ProductVariant?: ProductVariantUncheckedCreateNestedManyWithoutProductInput
    ProductPayment?: ProductPaymentUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutQPayInvoiceInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutQPayInvoiceInput, ProductUncheckedCreateWithoutQPayInvoiceInput>
  }

  export type ProductVariantCreateWithoutQPayInvoiceInput = {
    id?: string
    name: string
    price: number
    unit: number
    duration: number
    discount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sits?: ProductVariantCreatesitsInput | Enumerable<number>
    Product: ProductCreateNestedOneWithoutProductVariantInput
    ProductPayment?: ProductPaymentCreateNestedManyWithoutProductVariantInput
  }

  export type ProductVariantUncheckedCreateWithoutQPayInvoiceInput = {
    id?: string
    productId: string
    name: string
    price: number
    unit: number
    duration: number
    discount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sits?: ProductVariantCreatesitsInput | Enumerable<number>
    ProductPayment?: ProductPaymentUncheckedCreateNestedManyWithoutProductVariantInput
  }

  export type ProductVariantCreateOrConnectWithoutQPayInvoiceInput = {
    where: ProductVariantWhereUniqueInput
    create: XOR<ProductVariantCreateWithoutQPayInvoiceInput, ProductVariantUncheckedCreateWithoutQPayInvoiceInput>
  }

  export type UserCreateWithoutQPayInvoiceInput = {
    id?: string
    email?: string | null
    emailVerified?: Date | string | null
    passwordDigest?: string | null
    phoneNumber: string
    phoneNumberVerified?: Date | string | null
    role?: UserRole
    inviteToken?: string | null
    isTokenUsed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invitedBy?: string | null
    pin?: string | null
    pinCreatedAt?: Date | string | null
    pinType?: string | null
    pinVerifiedAt?: Date | string | null
    hospitalId?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    hospital?: HospitalCreateNestedManyWithoutUserInput
    ProductPayment?: ProductPaymentCreateNestedManyWithoutUserInput
    UserPromoCode?: UserPromoCodeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutQPayInvoiceInput = {
    id?: string
    email?: string | null
    emailVerified?: Date | string | null
    passwordDigest?: string | null
    phoneNumber: string
    phoneNumberVerified?: Date | string | null
    role?: UserRole
    inviteToken?: string | null
    isTokenUsed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invitedBy?: string | null
    pin?: string | null
    pinCreatedAt?: Date | string | null
    pinType?: string | null
    pinVerifiedAt?: Date | string | null
    hospitalId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    hospital?: HospitalUncheckedCreateNestedManyWithoutUserInput
    ProductPayment?: ProductPaymentUncheckedCreateNestedManyWithoutUserInput
    UserPromoCode?: UserPromoCodeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutQPayInvoiceInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQPayInvoiceInput, UserUncheckedCreateWithoutQPayInvoiceInput>
  }

  export type ProductUpsertWithoutQPayInvoiceInput = {
    update: XOR<ProductUpdateWithoutQPayInvoiceInput, ProductUncheckedUpdateWithoutQPayInvoiceInput>
    create: XOR<ProductCreateWithoutQPayInvoiceInput, ProductUncheckedCreateWithoutQPayInvoiceInput>
  }

  export type ProductUpdateWithoutQPayInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    productDescription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ProductVariant?: ProductVariantUpdateManyWithoutProductNestedInput
    ProductPayment?: ProductPaymentUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutQPayInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    productDescription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ProductVariant?: ProductVariantUncheckedUpdateManyWithoutProductNestedInput
    ProductPayment?: ProductPaymentUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductVariantUpsertWithoutQPayInvoiceInput = {
    update: XOR<ProductVariantUpdateWithoutQPayInvoiceInput, ProductVariantUncheckedUpdateWithoutQPayInvoiceInput>
    create: XOR<ProductVariantCreateWithoutQPayInvoiceInput, ProductVariantUncheckedCreateWithoutQPayInvoiceInput>
  }

  export type ProductVariantUpdateWithoutQPayInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    unit?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sits?: ProductVariantUpdatesitsInput | Enumerable<number>
    Product?: ProductUpdateOneRequiredWithoutProductVariantNestedInput
    ProductPayment?: ProductPaymentUpdateManyWithoutProductVariantNestedInput
  }

  export type ProductVariantUncheckedUpdateWithoutQPayInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    unit?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sits?: ProductVariantUpdatesitsInput | Enumerable<number>
    ProductPayment?: ProductPaymentUncheckedUpdateManyWithoutProductVariantNestedInput
  }

  export type UserUpsertWithoutQPayInvoiceInput = {
    update: XOR<UserUpdateWithoutQPayInvoiceInput, UserUncheckedUpdateWithoutQPayInvoiceInput>
    create: XOR<UserCreateWithoutQPayInvoiceInput, UserUncheckedCreateWithoutQPayInvoiceInput>
  }

  export type UserUpdateWithoutQPayInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordDigest?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneNumberVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    isTokenUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    pinCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pinType?: NullableStringFieldUpdateOperationsInput | string | null
    pinVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hospitalId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    hospital?: HospitalUpdateManyWithoutUserNestedInput
    ProductPayment?: ProductPaymentUpdateManyWithoutUserNestedInput
    UserPromoCode?: UserPromoCodeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutQPayInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordDigest?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneNumberVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    isTokenUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    pinCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pinType?: NullableStringFieldUpdateOperationsInput | string | null
    pinVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hospitalId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    hospital?: HospitalUncheckedUpdateManyWithoutUserNestedInput
    ProductPayment?: ProductPaymentUncheckedUpdateManyWithoutUserNestedInput
    UserPromoCode?: UserPromoCodeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type HospitalCreateWithoutMessageInput = {
    id?: string
    hospitalLogo?: string | null
    subDomain?: string | null
    phoneNumber: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    User: UserCreateNestedOneWithoutHospitalInput
    HospitalUsers?: HospitalUsersCreateNestedManyWithoutHospitalInput
    subscription?: SubscriptionCreateNestedManyWithoutHospitalInput
    databaseConnection?: DatabaseConnectionCreateNestedManyWithoutHospitalInput
  }

  export type HospitalUncheckedCreateWithoutMessageInput = {
    id?: string
    hospitalLogo?: string | null
    subDomain?: string | null
    phoneNumber: string
    name: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    HospitalUsers?: HospitalUsersUncheckedCreateNestedManyWithoutHospitalInput
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutHospitalInput
    databaseConnection?: DatabaseConnectionUncheckedCreateNestedManyWithoutHospitalInput
  }

  export type HospitalCreateOrConnectWithoutMessageInput = {
    where: HospitalWhereUniqueInput
    create: XOR<HospitalCreateWithoutMessageInput, HospitalUncheckedCreateWithoutMessageInput>
  }

  export type HospitalUpsertWithoutMessageInput = {
    update: XOR<HospitalUpdateWithoutMessageInput, HospitalUncheckedUpdateWithoutMessageInput>
    create: XOR<HospitalCreateWithoutMessageInput, HospitalUncheckedCreateWithoutMessageInput>
  }

  export type HospitalUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    hospitalLogo?: NullableStringFieldUpdateOperationsInput | string | null
    subDomain?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutHospitalNestedInput
    HospitalUsers?: HospitalUsersUpdateManyWithoutHospitalNestedInput
    subscription?: SubscriptionUpdateManyWithoutHospitalNestedInput
    databaseConnection?: DatabaseConnectionUpdateManyWithoutHospitalNestedInput
  }

  export type HospitalUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    hospitalLogo?: NullableStringFieldUpdateOperationsInput | string | null
    subDomain?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    HospitalUsers?: HospitalUsersUncheckedUpdateManyWithoutHospitalNestedInput
    subscription?: SubscriptionUncheckedUpdateManyWithoutHospitalNestedInput
    databaseConnection?: DatabaseConnectionUncheckedUpdateManyWithoutHospitalNestedInput
  }

  export type UserPromoCodeCreateWithoutPromoCodeInput = {
    id?: string
    promoCodeUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserPromoCodeInput
  }

  export type UserPromoCodeUncheckedCreateWithoutPromoCodeInput = {
    id?: string
    userId: string
    promoCodeUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPromoCodeCreateOrConnectWithoutPromoCodeInput = {
    where: UserPromoCodeWhereUniqueInput
    create: XOR<UserPromoCodeCreateWithoutPromoCodeInput, UserPromoCodeUncheckedCreateWithoutPromoCodeInput>
  }

  export type UserPromoCodeCreateManyPromoCodeInputEnvelope = {
    data: Enumerable<UserPromoCodeCreateManyPromoCodeInput>
    skipDuplicates?: boolean
  }

  export type UserPromoCodeUpsertWithWhereUniqueWithoutPromoCodeInput = {
    where: UserPromoCodeWhereUniqueInput
    update: XOR<UserPromoCodeUpdateWithoutPromoCodeInput, UserPromoCodeUncheckedUpdateWithoutPromoCodeInput>
    create: XOR<UserPromoCodeCreateWithoutPromoCodeInput, UserPromoCodeUncheckedCreateWithoutPromoCodeInput>
  }

  export type UserPromoCodeUpdateWithWhereUniqueWithoutPromoCodeInput = {
    where: UserPromoCodeWhereUniqueInput
    data: XOR<UserPromoCodeUpdateWithoutPromoCodeInput, UserPromoCodeUncheckedUpdateWithoutPromoCodeInput>
  }

  export type UserPromoCodeUpdateManyWithWhereWithoutPromoCodeInput = {
    where: UserPromoCodeScalarWhereInput
    data: XOR<UserPromoCodeUpdateManyMutationInput, UserPromoCodeUncheckedUpdateManyWithoutUserPromoCodeInput>
  }

  export type UserCreateWithoutUserPromoCodeInput = {
    id?: string
    email?: string | null
    emailVerified?: Date | string | null
    passwordDigest?: string | null
    phoneNumber: string
    phoneNumberVerified?: Date | string | null
    role?: UserRole
    inviteToken?: string | null
    isTokenUsed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invitedBy?: string | null
    pin?: string | null
    pinCreatedAt?: Date | string | null
    pinType?: string | null
    pinVerifiedAt?: Date | string | null
    hospitalId?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    hospital?: HospitalCreateNestedManyWithoutUserInput
    ProductPayment?: ProductPaymentCreateNestedManyWithoutUserInput
    QPayInvoice?: QPayInvoiceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserPromoCodeInput = {
    id?: string
    email?: string | null
    emailVerified?: Date | string | null
    passwordDigest?: string | null
    phoneNumber: string
    phoneNumberVerified?: Date | string | null
    role?: UserRole
    inviteToken?: string | null
    isTokenUsed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invitedBy?: string | null
    pin?: string | null
    pinCreatedAt?: Date | string | null
    pinType?: string | null
    pinVerifiedAt?: Date | string | null
    hospitalId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    hospital?: HospitalUncheckedCreateNestedManyWithoutUserInput
    ProductPayment?: ProductPaymentUncheckedCreateNestedManyWithoutUserInput
    QPayInvoice?: QPayInvoiceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserPromoCodeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserPromoCodeInput, UserUncheckedCreateWithoutUserPromoCodeInput>
  }

  export type PromoCodeCreateWithoutUserPromoCodeInput = {
    id?: string
    code: string
    promoImageUrl?: string
    description: string
    expiryDate?: Date | string | null
    isActive?: boolean
    fixedAmount: Decimal | DecimalJsLike | number | string
    percentageAmount: Decimal | DecimalJsLike | number | string
    maxUses?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromoCodeUncheckedCreateWithoutUserPromoCodeInput = {
    id?: string
    code: string
    promoImageUrl?: string
    description: string
    expiryDate?: Date | string | null
    isActive?: boolean
    fixedAmount: Decimal | DecimalJsLike | number | string
    percentageAmount: Decimal | DecimalJsLike | number | string
    maxUses?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromoCodeCreateOrConnectWithoutUserPromoCodeInput = {
    where: PromoCodeWhereUniqueInput
    create: XOR<PromoCodeCreateWithoutUserPromoCodeInput, PromoCodeUncheckedCreateWithoutUserPromoCodeInput>
  }

  export type UserUpsertWithoutUserPromoCodeInput = {
    update: XOR<UserUpdateWithoutUserPromoCodeInput, UserUncheckedUpdateWithoutUserPromoCodeInput>
    create: XOR<UserCreateWithoutUserPromoCodeInput, UserUncheckedCreateWithoutUserPromoCodeInput>
  }

  export type UserUpdateWithoutUserPromoCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordDigest?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneNumberVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    isTokenUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    pinCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pinType?: NullableStringFieldUpdateOperationsInput | string | null
    pinVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hospitalId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    hospital?: HospitalUpdateManyWithoutUserNestedInput
    ProductPayment?: ProductPaymentUpdateManyWithoutUserNestedInput
    QPayInvoice?: QPayInvoiceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserPromoCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordDigest?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneNumberVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    isTokenUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    pinCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pinType?: NullableStringFieldUpdateOperationsInput | string | null
    pinVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hospitalId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    hospital?: HospitalUncheckedUpdateManyWithoutUserNestedInput
    ProductPayment?: ProductPaymentUncheckedUpdateManyWithoutUserNestedInput
    QPayInvoice?: QPayInvoiceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PromoCodeUpsertWithoutUserPromoCodeInput = {
    update: XOR<PromoCodeUpdateWithoutUserPromoCodeInput, PromoCodeUncheckedUpdateWithoutUserPromoCodeInput>
    create: XOR<PromoCodeCreateWithoutUserPromoCodeInput, PromoCodeUncheckedCreateWithoutUserPromoCodeInput>
  }

  export type PromoCodeUpdateWithoutUserPromoCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    promoImageUrl?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fixedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    percentageAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxUses?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoCodeUncheckedUpdateWithoutUserPromoCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    promoImageUrl?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fixedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    percentageAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxUses?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refreshToken?: string | null
    accessToken?: string | null
    tokenType?: string | null
    expiresAt?: number | null
    scope?: string | null
    idToken?: string | null
    sessionState?: string | null
    oauthTokenSecret?: string | null
    oauthToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HospitalCreateManyUserInput = {
    id?: string
    hospitalLogo?: string | null
    subDomain?: string | null
    phoneNumber: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductPaymentCreateManyUserInput = {
    id?: string
    paidSource?: string | null
    paidAmount?: Decimal | DecimalJsLike | number | string | null
    paidDate?: Date | string | null
    additionalNote?: string
    productId: string
    productVariantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentStatus: string
  }

  export type QPayInvoiceCreateManyUserInput = {
    id?: string
    productId: string
    productVariantId: string
    invoiceData?: NullableJsonNullValueInput | InputJsonValue
    payedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPromoCodeCreateManyUserInput = {
    id?: string
    promoCodeId: string
    promoCodeUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableIntFieldUpdateOperationsInput | number | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionState?: NullableStringFieldUpdateOperationsInput | string | null
    oauthTokenSecret?: NullableStringFieldUpdateOperationsInput | string | null
    oauthToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableIntFieldUpdateOperationsInput | number | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionState?: NullableStringFieldUpdateOperationsInput | string | null
    oauthTokenSecret?: NullableStringFieldUpdateOperationsInput | string | null
    oauthToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableIntFieldUpdateOperationsInput | number | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionState?: NullableStringFieldUpdateOperationsInput | string | null
    oauthTokenSecret?: NullableStringFieldUpdateOperationsInput | string | null
    oauthToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HospitalUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    hospitalLogo?: NullableStringFieldUpdateOperationsInput | string | null
    subDomain?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    HospitalUsers?: HospitalUsersUpdateManyWithoutHospitalNestedInput
    subscription?: SubscriptionUpdateManyWithoutHospitalNestedInput
    databaseConnection?: DatabaseConnectionUpdateManyWithoutHospitalNestedInput
    Message?: MessageUpdateManyWithoutHospitalNestedInput
  }

  export type HospitalUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    hospitalLogo?: NullableStringFieldUpdateOperationsInput | string | null
    subDomain?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    HospitalUsers?: HospitalUsersUncheckedUpdateManyWithoutHospitalNestedInput
    subscription?: SubscriptionUncheckedUpdateManyWithoutHospitalNestedInput
    databaseConnection?: DatabaseConnectionUncheckedUpdateManyWithoutHospitalNestedInput
    Message?: MessageUncheckedUpdateManyWithoutHospitalNestedInput
  }

  export type HospitalUncheckedUpdateManyWithoutHospitalInput = {
    id?: StringFieldUpdateOperationsInput | string
    hospitalLogo?: NullableStringFieldUpdateOperationsInput | string | null
    subDomain?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductPaymentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    paidSource?: NullableStringFieldUpdateOperationsInput | string | null
    paidAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    additionalNote?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    Product?: ProductUpdateOneRequiredWithoutProductPaymentNestedInput
    ProductVariant?: ProductVariantUpdateOneRequiredWithoutProductPaymentNestedInput
  }

  export type ProductPaymentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    paidSource?: NullableStringFieldUpdateOperationsInput | string | null
    paidAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    additionalNote?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    productVariantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
  }

  export type ProductPaymentUncheckedUpdateManyWithoutProductPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    paidSource?: NullableStringFieldUpdateOperationsInput | string | null
    paidAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    additionalNote?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    productVariantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
  }

  export type QPayInvoiceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceData?: NullableJsonNullValueInput | InputJsonValue
    payedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Product?: ProductUpdateOneRequiredWithoutQPayInvoiceNestedInput
    ProductVariant?: ProductVariantUpdateOneRequiredWithoutQPayInvoiceNestedInput
  }

  export type QPayInvoiceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    productVariantId?: StringFieldUpdateOperationsInput | string
    invoiceData?: NullableJsonNullValueInput | InputJsonValue
    payedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QPayInvoiceUncheckedUpdateManyWithoutQPayInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    productVariantId?: StringFieldUpdateOperationsInput | string
    invoiceData?: NullableJsonNullValueInput | InputJsonValue
    payedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPromoCodeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    promoCodeUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    promoCode?: PromoCodeUpdateOneRequiredWithoutUserPromoCodeNestedInput
  }

  export type UserPromoCodeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    promoCodeId?: StringFieldUpdateOperationsInput | string
    promoCodeUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPromoCodeUncheckedUpdateManyWithoutUserPromoCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    promoCodeId?: StringFieldUpdateOperationsInput | string
    promoCodeUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HospitalUsersCreateManyHospitalInput = {
    id?: number
    phoneNumber?: string | null
    userName: string
    role?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionCreateManyHospitalInput = {
    id?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    totalDays?: number
    isStart?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DatabaseConnectionCreateManyHospitalInput = {
    id?: string
    connectionName: string
    connectionType: string
    host: string
    port: number
    databaseName: string
    username: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateManyHospitalInput = {
    id?: string
    phoneNumber: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HospitalUsersUpdateWithoutHospitalInput = {
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HospitalUsersUncheckedUpdateWithoutHospitalInput = {
    id?: IntFieldUpdateOperationsInput | number
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HospitalUsersUncheckedUpdateManyWithoutHospitalUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUpdateWithoutHospitalInput = {
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalDays?: IntFieldUpdateOperationsInput | number
    isStart?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    machines?: MachineUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutHospitalInput = {
    id?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalDays?: IntFieldUpdateOperationsInput | number
    isStart?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    machines?: MachineUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalDays?: IntFieldUpdateOperationsInput | number
    isStart?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatabaseConnectionUpdateWithoutHospitalInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectionName?: StringFieldUpdateOperationsInput | string
    connectionType?: StringFieldUpdateOperationsInput | string
    host?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    databaseName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatabaseConnectionUncheckedUpdateWithoutHospitalInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectionName?: StringFieldUpdateOperationsInput | string
    connectionType?: StringFieldUpdateOperationsInput | string
    host?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    databaseName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatabaseConnectionUncheckedUpdateManyWithoutDatabaseConnectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectionName?: StringFieldUpdateOperationsInput | string
    connectionType?: StringFieldUpdateOperationsInput | string
    host?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    databaseName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutHospitalInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateWithoutHospitalInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineCreateManySubscriptionInput = {
    id?: number
    machineName: string
    machineUniqueId: string
    registeredAt?: Date | string
  }

  export type MachineUpdateWithoutSubscriptionInput = {
    machineName?: StringFieldUpdateOperationsInput | string
    machineUniqueId?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineUncheckedUpdateWithoutSubscriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    machineName?: StringFieldUpdateOperationsInput | string
    machineUniqueId?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineUncheckedUpdateManyWithoutMachinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    machineName?: StringFieldUpdateOperationsInput | string
    machineUniqueId?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariantCreateManyProductInput = {
    id?: string
    name: string
    price: number
    unit: number
    duration: number
    discount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sits?: ProductVariantCreatesitsInput | Enumerable<number>
  }

  export type ProductPaymentCreateManyProductInput = {
    id?: string
    paidSource?: string | null
    paidAmount?: Decimal | DecimalJsLike | number | string | null
    paidDate?: Date | string | null
    additionalNote?: string
    productVariantId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentStatus: string
  }

  export type QPayInvoiceCreateManyProductInput = {
    id?: string
    productVariantId: string
    invoiceData?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    payedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductVariantUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    unit?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sits?: ProductVariantUpdatesitsInput | Enumerable<number>
    ProductPayment?: ProductPaymentUpdateManyWithoutProductVariantNestedInput
    QPayInvoice?: QPayInvoiceUpdateManyWithoutProductVariantNestedInput
  }

  export type ProductVariantUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    unit?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sits?: ProductVariantUpdatesitsInput | Enumerable<number>
    ProductPayment?: ProductPaymentUncheckedUpdateManyWithoutProductVariantNestedInput
    QPayInvoice?: QPayInvoiceUncheckedUpdateManyWithoutProductVariantNestedInput
  }

  export type ProductVariantUncheckedUpdateManyWithoutProductVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    unit?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sits?: ProductVariantUpdatesitsInput | Enumerable<number>
  }

  export type ProductPaymentUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    paidSource?: NullableStringFieldUpdateOperationsInput | string | null
    paidAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    additionalNote?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    ProductVariant?: ProductVariantUpdateOneRequiredWithoutProductPaymentNestedInput
    User?: UserUpdateOneRequiredWithoutProductPaymentNestedInput
  }

  export type ProductPaymentUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    paidSource?: NullableStringFieldUpdateOperationsInput | string | null
    paidAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    additionalNote?: StringFieldUpdateOperationsInput | string
    productVariantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
  }

  export type QPayInvoiceUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceData?: NullableJsonNullValueInput | InputJsonValue
    payedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ProductVariant?: ProductVariantUpdateOneRequiredWithoutQPayInvoiceNestedInput
    user?: UserUpdateOneWithoutQPayInvoiceNestedInput
  }

  export type QPayInvoiceUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    productVariantId?: StringFieldUpdateOperationsInput | string
    invoiceData?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    payedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductPaymentCreateManyProductVariantInput = {
    id?: string
    paidSource?: string | null
    paidAmount?: Decimal | DecimalJsLike | number | string | null
    paidDate?: Date | string | null
    additionalNote?: string
    productId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentStatus: string
  }

  export type QPayInvoiceCreateManyProductVariantInput = {
    id?: string
    productId: string
    invoiceData?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    payedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductPaymentUpdateWithoutProductVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    paidSource?: NullableStringFieldUpdateOperationsInput | string | null
    paidAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    additionalNote?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    Product?: ProductUpdateOneRequiredWithoutProductPaymentNestedInput
    User?: UserUpdateOneRequiredWithoutProductPaymentNestedInput
  }

  export type ProductPaymentUncheckedUpdateWithoutProductVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    paidSource?: NullableStringFieldUpdateOperationsInput | string | null
    paidAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    additionalNote?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
  }

  export type QPayInvoiceUpdateWithoutProductVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceData?: NullableJsonNullValueInput | InputJsonValue
    payedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Product?: ProductUpdateOneRequiredWithoutQPayInvoiceNestedInput
    user?: UserUpdateOneWithoutQPayInvoiceNestedInput
  }

  export type QPayInvoiceUncheckedUpdateWithoutProductVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    invoiceData?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    payedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPromoCodeCreateManyPromoCodeInput = {
    id?: string
    userId: string
    promoCodeUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPromoCodeUpdateWithoutPromoCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    promoCodeUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserPromoCodeNestedInput
  }

  export type UserPromoCodeUncheckedUpdateWithoutPromoCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    promoCodeUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}