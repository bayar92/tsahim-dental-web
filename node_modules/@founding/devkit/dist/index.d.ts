import c from "chalk";
import { Table as  } from "console-table-printer";
import ora from "ora";
import p from "prompts";
import j from "jscodeshift";
import { Collection as  } from "jscodeshift/src/Collection";
import { Schema as , Enum as , Field as , type _Generator1 as , ModelAttribute as , Model as , Datasource as  } from "@mrleebo/prisma-ast";
import fs from "fs-extra";
import globby from "globby";
export type Package = {
    name: string;
    version?: string;
    isDevDep?: boolean;
    isExpoDep?: boolean;
};
export type ScaffoldPath = {
    src: string;
    dest: string;
};
export type Frameworks = "next" | "expo" | "bedrock" | "remix" | "blitz";
export type Language = "typescript" | "javascript";
export type Theme = "pico";
export type Context<T = {}> = {
    props: T;
    paths: {
        root: string;
        env: string;
        envExample: string;
        fxConfig: string;
        tsConfig: string;
        packageJson: string;
        scheme: string;
        lib: string;
        libCore: string;
        mobile: string;
        appJson: string;
        pages: string;
        api: string;
    };
    config: {
        frameworks: Frameworks[];
        language: Language;
        theme: Theme;
    };
    helpers: Record<string, any>;
    generatorMeta?: GeneratorMeta;
    h: Record<string, any>;
    p: T;
};
export type Generator<T = any> = {
    name?: string;
    description?: string;
    version?: number;
    setup: (context: Context, generatorOptions?: Record<string, any>) => Promise<T>;
    install: (context: Context<T>) => Promise<Package[]>;
    scaffold: (context: Context<T>) => Promise<ScaffoldPath[]>;
    codemods: (context: Context<T>) => Promise<string[]>;
    finish: (context: Context<T>) => Promise<void>;
    uninstall: (context: Context<T>) => Promise<{
        dependencies: string[];
        templates: string[];
    }>;
};
export enum GeneratorLocation {
    Local = 0,
    Remote = 1
}
export type GeneratorMeta = {
    feature: string;
    path: string;
    subdirectory?: string;
    localRootPath: string;
    localPackageJsonPath: string;
    location: GeneratorLocation;
};
export type Filter<T> = (context: T) => boolean;
export const filterDependencies: <T>(dependencies: (Package & {
    filters?: Filter<T>[] | undefined;
})[], context: T) => Package[];
export const filterTemplates: <T>(templates: (ScaffoldPath & {
    filters?: Filter<T>[] | undefined;
})[], context: T) => ScaffoldPath[];
export const execSync: (command: string, args: string[], options?: any) => import("child_process").SpawnSyncReturns<string>;
export const exec: (command: string, args: string[], withStdio?: boolean) => Promise<void>;
export const sleep: (ms: number) => Promise<unknown>;
export const table: typeof Table;
export const chalk: c.Chalk & c.ChalkFunction & {
    supportsColor: false | c.ColorSupport;
    Level: c.Level;
    Color: ("black" | "red" | "green" | "yellow" | "blue" | "magenta" | "cyan" | "white" | "gray" | "grey" | "blackBright" | "redBright" | "greenBright" | "yellowBright" | "blueBright" | "magentaBright" | "cyanBright" | "whiteBright") | ("bgBlack" | "bgRed" | "bgGreen" | "bgYellow" | "bgBlue" | "bgMagenta" | "bgCyan" | "bgWhite" | "bgGray" | "bgGrey" | "bgBlackBright" | "bgRedBright" | "bgGreenBright" | "bgYellowBright" | "bgBlueBright" | "bgMagentaBright" | "bgCyanBright" | "bgWhiteBright");
    ForegroundColor: "black" | "red" | "green" | "yellow" | "blue" | "magenta" | "cyan" | "white" | "gray" | "grey" | "blackBright" | "redBright" | "greenBright" | "yellowBright" | "blueBright" | "magentaBright" | "cyanBright" | "whiteBright";
    BackgroundColor: "bgBlack" | "bgRed" | "bgGreen" | "bgYellow" | "bgBlue" | "bgMagenta" | "bgCyan" | "bgWhite" | "bgGray" | "bgGrey" | "bgBlackBright" | "bgRedBright" | "bgGreenBright" | "bgYellowBright" | "bgBlueBright" | "bgMagentaBright" | "bgCyanBright" | "bgWhiteBright";
    Modifiers: "bold" | "reset" | "dim" | "italic" | "underline" | "inverse" | "hidden" | "strikethrough" | "visible";
    stderr: c.Chalk & {
        supportsColor: false | c.ColorSupport;
    };
};
export const logger: {
    withWarning(str: string): string;
    withCaret(str: string): string;
    withCheck(str: string): string;
    withX(str: string): string;
    withProgress(str: string): string;
    withError(str: string): string;
    withMeta(str: string): string;
    withVariable(str: string): string;
    withCommand(str: string): string;
    withIndent(str: string, indent?: number): string;
    spinner(str?: string | undefined): ora.Ora;
    clearLine(msg?: string | undefined): void;
    clearConsole(): void;
    title(msg: string): void;
    list(msgs: string[]): void;
    error(msg: string): void;
    warning(msg: string): void;
    meta(msg: string): void;
    progress(msg: string): void;
    success(msg: string): void;
    log(msg: string, indents?: number, newLine?: boolean): void;
    newLine(): void;
    table: typeof Table;
};
export const startDocker: () => Promise<void>;
export const stopDocker: () => Promise<void>;
export const runMigrations: (name?: string) => Promise<void>;
export const runPrismaCodegen: () => Promise<void>;
export const syncGeneratorMigrations: (migrationName: string) => Promise<void>;
export const throwHandledError: ({ command, message, error, }: {
    command: string;
    message: string;
    error?: any;
}) => never;
export const onPromptCancel: () => void;
export const prompts: <T extends string = string>(questions: p.PromptObject<T> | p.PromptObject<T>[], options?: p.Options | undefined) => Promise<p.Answers<T>>;
export const filetypeToPrettierParser: {
    ts: string;
    tsx: string;
    js: string;
    jsx: string;
    json: string;
    yml: string;
    yaml: string;
    md: string;
    html: string;
    css: string;
    scss: string;
    sass: string;
    less: string;
    graphql: string;
};
export const getPrettierParser: (filePath: string) => string | null;
export const transformPrettier: (filePath: string) => (source: string) => Promise<string>;
export const transformEjs: (source: string, context: any) => Promise<string>;
export const createJscodeshiftProgram: (source: string) => {
    program: import("jscodeshift/src/Collection").Collection<any>;
    jscodeshift: jscodeshift.JSCodeshift;
    j: jscodeshift.JSCodeshift;
};
export const createJscodeshiftTransform: (transform: any) => (source: string, context: any) => Promise<string>;
export const addImport: (program: Collection<j.Program>, importToAdd: j.ImportDeclaration) => Collection<import("ast-types").namedTypes.Program>;
export const findModuleExportsExpressions: (program: Collection<j.Program>) => Collection<import("ast-types").namedTypes.AssignmentExpression>;
/**
 * A file transformer that parses a schema.prisma string, offers you a callback
 * of the parsed document object, then takes your changes to the document and
 * writes out a new schema.prisma string with the changes applied.
 *
 * @param source - schema.prisma source file contents
 * @param producer - a callback function that can mutate the parsed data model
 * @returns The modified schema.prisma source
 */
export const produceSchema: (source: string, producer: (schema: Schema) => void) => Promise<string>;
/**
 * Adds an enum to your schema.prisma data model.
 *
 * @param source - schema.prisma source file contents
 * @param enumProps - the enum to add
 * @returns The modified schema.prisma source
 * @example Usage
 * ```
 *  addPrismaEnum(source, {
      type: "enum",
      name: "Role",
      enumerators: [
        {type: "enumerator", name: "USER"},
        {type: "enumerator", name: "ADMIN"},
      ],
    })
 * ```
 */
export const addPrismaEnum: (source: string, enumProps: Enum) => Promise<string>;
/**
 * Adds a field to a model in your schema.prisma data model.
 *
 * @param source - schema.prisma source file contents
 * @param modelName - name of the model to add a field to
 * @param fieldProps - the field to add
 * @returns The modified schema.prisma source
 * @example Usage
 * ```
 *  addPrismaField(source, "Project", {
      type: "field",
      name: "name",
      fieldType: "String",
      optional: false,
      attributes: [{type: "attribute", kind: "field", name: "unique"}],
    })
 * ```
 */
export const addPrismaField: (source: string, modelName: string, fieldProps: Field) => Promise<string>;
/**
 * Adds a generator to your schema.prisma data model.
 *
 * @param source - schema.prisma source file contents
 * @param generatorProps - the generator to add
 * @returns The modified schema.prisma source
 * @example Usage
 * ```
 *  addPrismaGenerator(source, {
      type: "generator",
      name: "nexusPrisma",
      assignments: [{type: "assignment", key: "provider", value: '"nexus-prisma"'}],
    })
 * ```
 */
export const addPrismaGenerator: (source: string, generatorProps: _Generator1) => Promise<string>;
/**
 * Adds a field to a model in your schema.prisma data model.
 *
 * @remarks Not ready for actual use
 * @param source - schema.prisma source file contents
 * @param modelName - name of the model to add a field to
 * @param attributeProps - the model attribute (such as an index) to add
 * @returns The modified schema.prisma source
 * @example Usage
 * ```
 * addPrismaModelAttribute(source, "Project", {
 *   type: "attribute",
 *   kind: "model",
 *   name: "index",
 *   args: [{ type: "attributeArgument", value: { type: "array", args: ["name"] } }]
 * });
 * ```
 */
export const addPrismaModelAttribute: (source: string, modelName: string, attributeProps: ModelAttribute) => Promise<string>;
/**
 * Adds an enum to your schema.prisma data model.
 *
 * @param source - schema.prisma source file contents
 * @param modelProps - the model to add
 * @returns The modified schema.prisma source
 * @example Usage
 * ```
 *  addPrismaModel(source, {
      type: "model",
      name: "Project",
      properties: [{type: "field", name: "id", fieldType: "String"}],
    })
 * ```
 */
export const addPrismaModel: (source: string, modelProps: Model) => Promise<string>;
/**
 * Modify the prisma datasource metadata to use the provider and url specified.
 *
 * @param source - schema.prisma source file contents
 * @param datasourceProps - datasource object to assign to the schema
 * @returns The modified schema.prisma source
 * @example Usage
 * ```
 *  setPrismaDataSource(source, {
      type: "datasource",
      name: "db",
      assignments: [
        {type: "assignment", key: "provider", value: '"postgresql"'},
        {
          type: "assignment",
          key: "url",
          value: {type: "function", name: "env", params: ['"DATABASE_URL"']},
        },
      ],
    })
 * ```
 */
export const setPrismaDataSource: (source: string, datasourceProps: Datasource) => Promise<string>;
export const logSchema: (source: string) => Promise<void>;
export const isWriteable: (directory: string) => Promise<boolean>;
export const makeDir: (root: string, options?: {
    recursive: boolean;
}) => void;
export const removeDir: (path: string) => void;
export const getFilePaths: (patterns: string, options?: globby.GlobbyOptions | undefined) => Promise<string[]>;
export const copyFiles: (source: string, destination: string) => Promise<void>;
export const fileExists: (path: string) => boolean;
export const readJson: (file: string, options?: string | fs.ReadOptions | undefined) => any;
export const writeJson: (file: string, object: any, options?: string | fs.WriteOptions | undefined) => void;
export const readFile: (filePath: string) => string;
export const writeFile: (filePath: string, content: string, options?: {
    force?: boolean;
    append?: boolean;
}) => void;
type Path = {
    src: string;
    dest?: string;
};
type Transform = (source: string, context: any) => Promise<string | void>;
export const runTransforms: (filePath: Path | string, ...transforms: [Transform, any?][]) => Promise<string | void>;
export const checkAndNotifyUpdates: (packageJson: Record<string, any>) => Promise<void>;

//# sourceMappingURL=index.d.ts.map
